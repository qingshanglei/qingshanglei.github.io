备战。。。。



写在面试开头。。。。
前三次面试，当走过场，过了最好，记住此时的心态；投了100多份简历还没人理,心态有点崩溃的说。



2023-9-13： 心态没摆正，面试八股文都没准备，之前的白跑了。
工作二则： ①说，②做。
说：1、简历。  2、面试（八股文）。
做： 工作。



面试分类：



1. 校招：相对简单。
2. 社招：跟全国人竞技。。。



简历好坏区别：



1. 好：你遛狗。
2. 坏：狗遛你。



# [Java SE：](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-1)



## 其他：



### 1、ﬁnal有哪些用法?



或final 关键字的作用...



1. 被ﬁnal修饰的类不可以被继承。
2. 被ﬁnal修饰的方法不可以被重写。
3. 被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
4. 被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率
5. 被ﬁnal修饰的常量,在编译阶段会存入常量池中.



### 2、 synchronized的优缺点:

1. 优点：解决了多线程的数据安全问题。
2. 缺点：当线程多的时候，每个线程都会上锁，会耗费很多资源，降低程序的运行效率。

### 3、**static**都有哪些用法?

   静态变量和静态方法，静态内部类，静态块，就是静态导包

1. static关键字这两个基本的用法:静态变量和静态方法，也就是被static所修饰的变量方法都属于类的静态资源,类实例所共享。
2. 除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作。



## 集合：



![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/Java%20SE/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png)



### 2、 HashMap 在 jdk 1.7 和 1.8 的区别？



### 3、 String、StringBuﬀer和StringBuilder 的区别是什么?



String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个ﬁnal类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。

StringBuﬀer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到,他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuﬀer和StringBuilder来进行操作。 另外StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。



### 4、ArrayList 和 LinkedList 的区别是什么？

1.  底层数据结构
   ① ArrayList是动态数组的数据结构
   ② LinkList是一个双链表的数据结构 
2.  操作数据效率
   ① ArrayList底层是数组，查询快，增删慢
   ② LinkList底层数据结构是链表，查询慢，增删快 
3.  空间
   ① ArrayList底层数组，内存连续，节省内存
   ② LinkList底层数据结构是链表，存储数据的时候，要多存两个指针，更占内存。 
4.  线程是否安全： ArrayList 和 LinkList都是线程不安全的。

**适用场景分析:**

- 当需要对数据进行对随机访问的时候，选用 ArrayList。
- 当需要对数据进行多次增加删除修改时，采用 LinkedList。
- 如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免 ArrayList 的扩容，以及非顺序的插入。



### 如何保证ArrayList和 LinkList的线程安全：

1. 在方法内使用，局部遍历则是线程安全。
2. 使用 synchronized方法。

```java
  List<Object> syncArrayList=Collections.synchroizedList(new ArrayList<>());
  List<Object> syncLinkedList=Collections.synchroizedList(new LinkedList<>());
```



### 5、**HashMap和HashTable的区别：**

   1. **发布的版本不一样：** 

       Hashtable 在JDK 1.0发布，HashMap 在JDK 1.2发布。 

2. **两者父类不同**

​    HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化,JDK1.8+）这三个接口。 

3. **对外提供的接口不同**
   Hashtable比HashMap多提供了elments() 和contains() 两个方法。 elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。
   contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。 
 4.  **对null的支持不同**
      Hashtable：key和value都不能为null。
      HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。 
  5.  **安全性不同**
      HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。
      Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。
      虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。
      ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。 
   4.  **初始容量大小和每次扩充容量大小不同**
          Hashtable 的初始长度是 11，之后每次扩充容量变为之前的2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。 
   5.  **计算hash值的方法不同**
      Hashtable 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。 

   注意：Hashtable 是线程安全，推荐使用 HashMap 代替 Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。



### 6、Collection包结构，与Collections的区别

1. Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set。
2. Collections是集合类的一个帮助类， 它包含各种有关集合操作的静态多态方法，常用于对集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

### 7、Java的四种引用，强弱软虚：

1.  强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收。使用方式： 

```java
String str = new String("str");
System.out.println(str);
```



1.  软引用：软引用在程序内存不足时，会被回收。 
2.  弱引用：弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。 
3.  虚引用：虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue 。 

### 8、Java创建对象有几种方式？

java中提供了以下四种创建对象的方式:

1. new创建新对象。
2. 通过反射机制。
3. 采用clone机制。
4. 通过序列化机制。

### 11、说说List,Set,Map三者的区别？

1. List(有序集合，序列集合)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象
2. Set:  不允许重复的集合。不会有多个元素引用相同的对象。
3. Map:  使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

### 用过 **ArrayList** 吗？说一下它有什么特点？

Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。

底层是使用数组实现，添加元素。如果 add(o)，添加到的是数组的尾部，如果要增加的数据量很大，应该使用 ensureCapacity()方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。如果使用 add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。

ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList 里面的 clone() 复制其实是浅复制。



### HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？

这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下ConcurrentHashMap 数据结构以及底层原理等。

### HashMap中的 **key** 我们可以使用任何类作为 **key** 吗？

平时可能大家使用的最多的就是使用 String 作为 HashMap 的 key，但是现在我们想使用某个自定义类作为 HashMap 的 key，那就需要注意以下几点：

1. 如果类重写了 equals 方法，它也应该重写 hashCode 方法。类的所有实例需要遵循与 equals 和 hashCode 相关的规则。
2. 如果一个类没有使用 equals，你不应该在 hashCode 中使用它。
3. 咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。



### **HashMap** 的长度为什么是 **2** **的** **N** 次方呢？

为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。

我们首先可能会想到 % 取模的操作来实现。

下面是回答的重点哟：

```plain
取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。
```

这就是为什么 HashMap 的长度需要 2 的 N 次方了。



### **HashMap** **与** **ConcurrentHashMap** 的异同:

1. 都是 key-value 形式的存储数据；
2. HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；
3. HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry，Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。



1、set集合特点：

1. ①不包含重复元素的集合
2. ②没有带索引的方法，所以不能使用普通for循环遍历
3. 注意： HashSet 对集合的迭代循环不做任何保证（如果要保证元素唯一性，需要重写hasCede()和equals()）



## 反射：

Java反射机制:是指在运行时去获取一个类的变量和方法信息。然后通过获取 到的信息来创建对象，调用方法的 一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成 确定，在运行期依然可以扩展

## 线程：

线程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。
①是系统进行资源分配和调用的独立单位。
②每一个进程都有它自己的内存空间和系统资源。



### 12、简述线程、程序、进程的基本概念。以及他们之间关系是什么?

进程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。
①是系统进行资源分配和调用的独立单位。
②每一个进程都有它自己的内存空间和系统资源。

   线程分为：并发、串行和并行。

1.  并发：同一时刻多个线程在访问同一个资源，多个线程对一个点。
         例子：春运抢票、微信抢红包、电商秒杀... 
2.  串行
   ①串行-同步串行：代表多任务按先后顺序执行，并且都是**同一个线程**来执行。
      ②串行-异步串行：代表多任务按先后顺序执行，并由**不同的线程**来执行 
3.  并行：多项任务一起执行，之后再汇总
   例子：泡方便面，电水壶一边烧水，一边撕调料倒入桶中。 
4.  任务合并：一个任务的执行依赖于前面多个任务执行的返回值，并且这些任务可以由同一个线程执行，也可以由不同的线程执行； 



### 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

1. **线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
2. **程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
3. **进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。



### 1、说说Java中实现多线程有几种方法:

创建线程的常用三种方式：

1.  继承Thread类 。 
2.  实现Runnable接口。 
3.  实现Callable接口（ JDK1.5>= ） 
4.  线程池方式创建。 

通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。



### 2、  采用实现**Runnable**、**Callable**接口的方式创建线程的优缺点

   **优点**：线类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。

**缺点**：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法



### 3、 采用继承**Thread**类的方式创建线程的优缺点：

   优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程

缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。



### 2、如何停止一个正在运行的线程

1.  使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 
2.  使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。 
3.  使用interrupt方法中断线程。 

```java
class MyThread extends Thread {
    volatile boolean stop = false;
    public void run() {
        while (!stop) {
            System.out.println(getName() + " is running");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("week up from blcok...");
                stop = true; // 在异常处理代码中修改共享变量的状态
            }
        }
        System.out.println(getName() + " is exiting...");
    }
}
class InterruptThreadDemo3 {
    public static void main(String[] args) throws InterruptedException {
        MyThread m1 = new MyThread();
        System.out.println("Starting thread...");
        m1.start();
        Thread.sleep(3000);
        System.out.println("Interrupt thread...: " + m1.getName());
        m1.stop = true; // 设置共享变量为true
        m1.interrupt(); // 阻塞时退出阻塞状态
        Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
        System.out.println("Stopping application...");
    }
}
```

 



### 3、**notify()**和**notifyAll()**有什么区别？

说明：  **notify可能会导致死锁，而notifyAll则不会。**

### 4、**sleep()**和**wait()** 有什么区别？

   sleep()方法属于Thread类中的。而wait()方法，则是属于Object类中的。

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。



### 5、**volatile** **是什么?**可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。
2. 禁止进行指令重排序。

volatile 不是原子性操作



### 6、什么叫保证部分有序性?

   当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；



### 6、Thread类中的**start()** 和 **run()** 方法有什么区别？

   start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。



7、为什么**wait, notify** **和** **notifyAll**这些方法不在**thread**类里面？

   JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。



8、为什么**wait**和**notify**方法要在同步块中调用？

1. 只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。
2. 如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。
3. 还有一个原因是为了避免wait和notify之间产生竞态条件。



wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。



在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:"特殊状态已经被设置"。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。



9、Java中**interrupted** 和 **isInterruptedd**方法的区别？

interrupted() 和 isInterrupted()的主要区别是前者会中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。



10、Java中**synchronized**和 **ReentrantLock**有什么不同？

相似点：它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.



区别：这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/ﬁnally语句块来完成。



### 11 、有三个线程T1,T2,T3,如何保证顺序执行？

在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一
个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调
用T2，T2调用T1)，这样T1就会先完成而T3最后完成。实际上先启动三个线程中哪一个都行， 因为在每个线程的run方法中用join方法限定了三个线程的
执行顺序。



### 12、**SynchronizedMap**和**ConcurrentHashMap**有什么区别？



SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModiﬁcationException。



### 13 、什么是线程安全

线程安全就是说多线程访问同一段代码，不会产生不确定的结果。
如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。



### 线程安全的几个级别：

（ 1 ）不可变

   像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用



（ 2 ）绝对线程安全

不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要 付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，例如CopyOnWriteArrayList、CopyOnWriteArraySet。



（ 3 ）相对线程安全

相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

（ 4 ）线程非安全：ArrayList、LinkedList、HashMap等都是线程非安全的类



### 14 、Thread类中的yield方法有什么作用？

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可
能在进入到暂停状态后马上又被执行。



### 15 、Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些
方法。



16 、说一说自己对于 synchronized 关键字的了解

   synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。

Java 6 后 Java 官方从 JVM 层面对synchronized 进行了优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优
化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。



### 17 、说说自己是怎么使用 synchronized 关键字？

1. 修饰实例方法:  作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
2. 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
3. 修饰代码块:  指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
4. 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！



### 18 、什么是线程安全？Vector是一个线程安全类吗？

1. 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。
2. Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。



### 19 、 volatile关键字的作用？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语

```plain
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对
其他线程来说是立即可见的。
禁止进行指令重排序。
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读
取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改
可见性和原子性。
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
```

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



### 20 、常用的线程池有哪些？

1. newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2. newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
3. newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
4. newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行
   任务的需求。
5. newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任
   务的需求。



## 21 、简述一下你对线程池的理解

（可以展开说一下线程池如何用、线程池的好处、线程池的启动策略）

合理利用线程池能够带来三个好处。

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



## 24 、说说进程和线程的区别？

1. 进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。
2. 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以 通信和同步等操作线程比进程更加容易）
3. 线程上下文的切换比进程上下文切换要快很多。 

   - 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。
   - 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。



### 29 ，线程安全需要保证几个基本特征？

1. 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
2. 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
3. 有序性，是保证线程内串行语义，避免指令重排等。



38 、多线程有什么用？

1. 发挥多核CPU的优势
2. 防止阻塞
3. 便于建模



# Spring:



## 1 、什么是spring?

1. Spring 是个java企业级应用的开源开发框架。
2. Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。
3. Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。



## 2 、你们项目中为什么使用Spring框架？

直接说Spring框架的好处就可以了。比如说Spring有以下特点：

```plain
轻量：Spring 是轻量的，基本的版本大约2MB。
控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
容器：Spring 包含并管理应用中对象的生命周期和配置。
MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。
```



## 3 、 Autowired和Resource关键字的区别？

@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。

1. [@Autowired ]() 根据类型注入。 
2. [@Resource ]() 默认根据名字注入，其次按照类型搜索。 
3. `@Autowired` `@Qualifie("userService")`两个结合起来可以根据名字和类型注入

注意：@Resource为Java自带的，[@Autowired ]() 为Spring框架的。 



1.  为什么重写 equals 还要重写 hashcode？ 
2.  == 和 equals 比较的区别 
3.  为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？ 
4.  介绍 Java 的集合类 
5.  什么是死锁？死锁产生的条件？ 
6.  线程有哪几种状态？ 
7.  有哪些进程调度算法？ 
8.  什么是缓冲区溢出？ 



## MyBatis:



## #{}和${}的区别是什么？

1. \#{}是预编译处理，${}是字符串替换。
2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理![img](https://www.yuque.com/api/services/graph/generate_redirect/latex?%7B%7D%E6%97%B6%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%8A){}替换成变量的值。
3. 使用#{}可以有效的防止SQL注入，提高系统安全性。



## 4 、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

1. 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。
2. 通过来映射字段名和实体类属性名的一一对应的关系。



# [MQ: ](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-11)



死信：无法被消费的消息。

应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。

消息成为死信的三种情况:

- 消息 TTL(Time To Live/存活时间) 过期
- 队列达到最大长度(队列满了，无法再添加数据到 MQ 中)
- 消息被拒绝消费消息，(basic.reject 或 basic.nack) 并且不把消息重新放入原模板队列， requeue = false。



## 延迟队列：

​    延迟队列(死信队列+TTL)：设置TTL在延迟多久之后消息成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。

注意：延迟队列基于死信队列。
队列内部是有序的。
延时队列就是用来存放需要在指定时间被处理的 元素的队列；需要在某个事件发生之后或者之前的指定时间点完成某一项任务。

使用场景：

1.  订单在十分钟之内未支付则自动取消。 
2.  新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 
3.  用户注册成功后，如果三天内没有登陆则进行短信提醒。 
4.  用户发起退款，如果三天内没有得到处理则通知相关运营人员。 
5.  预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。 
6.  使用消息队列有哪些优缺点？ 
7.  如何保证消息消费的幂等性？ 
8.  消息队列有哪些路由模型？ 
9.  你是否用过消息队列，解决过什么问题？ 



# Redis:

注意：主要减少mysql数据库的操作，及IO



## 怎么解决Redis和mysql数据不一致问题：

注意：只有是分布式中，数据的同步都是有延迟的，短暂的延迟一般也是可以接收的。但最终都是要数据一致的。

1.  先更新数据库，再更新缓存。 
2.  先删除缓存，再更新数据库。    注意：1和2数据库还是不一致。 
3.  先删除缓存，再更新数据库，再删除缓存（缓存延时双删  （缺点：会造成服务器的阻塞，不适合高并发。） 
4.  CANAL+MQ实现最终一致性。 



## 字符串(String):

-  string是redis最基本的类型，一个key对应一个value。 
-  string类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象 。 
-  string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。 
-  特点：单值单Value。 



使用场景：

1. 比如抖音无限点赞某个视频或者商品，点一下加一次
2. 是否喜欢的文章



## 列表(List):

   Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）它的底层实际是个双端链表，最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。
   它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的结点性能会较差。

特点:单键多值, 值可重复。

使用场景：微信公众号订阅消息。



## 哈希(Hash):

   Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）



## 集合(Set):

- Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。
- Redis 中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 

- - 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)

- 特点：单值多value，且无重复，可快速查找、添加、删除
- 例： set  k1  v1 v2 v3
   使用场景： 

1. 1. 微信抽奖小程序。



有序集合(ZSet):

-  set(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 
-  不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。 
-  zset的成员是唯一的,但分数(score)却可以重复。 
-  zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1 
-  例：  zset  k1  score1  v1  score2  v2
      使用场景：根据商品销售对商品进行排序显示。
      思路：定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。 



## 地理空间(GEO) 3.2+:

-  Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括
   添加地理位置的坐标。获取地理位置的坐标。计算两个位置之间的距离。根据用户给定的经纬度坐标来获取指定范围内的地理位置集合 

   地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。

问题：

1.  查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的 
2.  这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。 
3.  精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差
   注意： 核心思想就是将球体转换为平面，区块转换为一点。 



使用场景：

1. 美团地图附近位置的酒店推送
2. 高德地图附近位置的核酸检查点



# [Nginx](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-12)

1.  Nginx 有哪些作用？
   *Nginx* (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。
   ①部署网站
   ②通过Tomcat部署网站搭集群。 
2.  Nginx 有哪些负载均衡策略？ 



# [Spring Cloud](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-14)

1.  什么是微服务，有哪些优缺点？ 
2.  什么是注册中心，能解决什么问题？
   22、如何提高系统的并发能力？
   使用分布式系统。
   部署多台服务器，并做负载均衡。
   使用缓存（Redis）集群。
   数据库分库分表 + 读写分离。
   引入消息中间件集群。 

Nacos、OpenFeign、Gateway、Sentinel、Steata

# [SQL](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-5)

1.  MySQL 索引的最左原则 
2.  InnoDB 和 MyIsam 引擎的区别？ 
3.  有哪些优化数据库性能的方法？ 
4.  如何定位慢查询？ 
5.  MySQL 支持行锁还是表锁？分别有哪些优缺点？ 



# Git:



## Git如何解决冲突问题：

1.  两个分支中修改了同一个文件
   解决方法：当前分支上，直接修改代码，再  add(缓冲区)  commit(存储库) 
2.  两个分支中修改了同一个文件的名字
   解决方法：在本地当前分支上，修改冲突代码，再  add(缓冲区)  commit(存储库)   push(推送) 



## 什么是Git？：

1. Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本。
2. 与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。
3. 每个开发人员都可以“克隆”服务器存储库中的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要所有的恢复数据都在你队友的本地 Git 存储库中。
4. 还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享。



## **Git** **是用什么语言编写的？**

你需要说明使用它的原因，而不仅仅是说出语言的名称。
Git使用 C 语言编写(但不是 C# 或 C++)。 GIT 运算很快的原因，就是因为C 语言通过减少运行时的开销来做到这一点。



## 6、在Git中，你如何还原已经 push 并公开的提交？

```plain
There can be two answers to this question and make sure that you include both because any
of the below options can be used depending on the situation:
```

这个问题可以有两个答案，你回答时也要保包含这两个答案，因为根据具体情况可以使用以下选项：

1. 删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文 件进行必要的修改后，将其提交到我使用的远程存储库

```plain
git commit -m "commit message"
```

1. 创建一个新的提交，可以使用↓版本回退命令，撤消在错误提交中所做的所有更改。

```plain
git revert <name of bad commit>
```