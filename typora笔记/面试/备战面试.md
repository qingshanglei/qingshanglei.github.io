# 备战。。。

写在面试开头。。。。
前三次面试，当走过场，过了最好，记住此时的心态；投了100多份简历还没人理,心态有点崩溃的说。

2023-9-13： 心态没摆正，面试八股文都没准备，之前的白跑了。
工作二则： ①说，②做。
  说：1、简历。  2、面试 ①八股文30% ②项目经验70%。
  做： 工作。

​    找工作前：背八股文。     入职后：通宵实战写代码。

面试分类：

1. 校招：相对简单。
2. 社招：跟全国人竞技。。。

简历好坏区别：

1. 好：你遛狗。
2. 坏：狗遛你。



面试：

1. Java集成一定要扎实，
2. JUC一定要学通透，
3. 其他内容，就围摇简历上的技术，学60%,剩下全靠背面试题
4.  Redis 5大基本类型练明白了，其他的一背面试题。
5.   MQ基本交换机模型、生成、消费、死信队列、敲明白，其他的背面试题
6. JVM纯纯背面试题（内存模式、垃圾回收算法、堆区内存调整策略、垃圾回收器、各种分代算法区别、垃圾回收器其他特征）
7. 其他东西，就围腰面试题背
8. 项目

换个方法：直接在boos上问公司地址，直接去面试。

实习期不给工资，不签合同都是违法的：可直接去劳动局仲裁公司。

  笔试或机试在以下网站刷题等：在牛客网、GitHub、力扣网

我在学校学生只于还

面试：零经验从1~3到吹，`1~3`工作经验的冲着5年吹，5年冲者10年吹。



## 手上是否有offer:

   手里有offer吗，必须有两个，一个在天河建中路(1个半小时)，一个海珠区，目前一个工资5000，一个7500。一个考虑，那



## 进工厂：

​     20或25块一个小时，每天上10小时，一天就200块了，一个月最迟吗有6,000块，还包吃、保住。去工厂不香吗，就因为这个工作前景更好？



## 为什么没有参加学校的校招：





## 是否参加了实习，为什么从那个公司

   那个参加实习公司，工作时间，项目干了什么。







# [Java SE：](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-1)



## 其他：



### JDK&JRE&JVM的区别：

​    JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具（编译、开发工具）和Java核心类库。
Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含      JVM标准实现及Java核心类库。
​    JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。

   JDK包含JRE和Java编译、开发工具；
   JRE包含JVM和Java核心类库；
   运行Java仅需要JRE； 而开发Java需要JDK。

### 跨平台：

   字节码是在虚拟机上运行的，而不是编译器。换而言之，是因为JVM能跨平台安装，所以相应JAVA字节码便可以跟着在任何平台上运行。只要JVM自身的代码能在相应平台上运行，即JVM可行，则JAVA的程序员就可以不用考虑所写的程序要在哪里运行，反正都是在虚拟机上运行，然后变成相应平台的机器语言，而这个转变并不是程序员应该关心的。



### java 面向对象编程三大特性是什么？

- 面向对象的三个特性：封装；继承；多态
- 封装：将数据与操作数据的方法绑定起来，隐藏实现细节，对外提供接口。
- 继承：代码重用；可扩展性
- 多态：允许不同子类对象对同一消息做出不同响应

- 多态的三个必要条件：继承、方法的重写、父类引用指向子类对象



### 1、ﬁnal(快呢)有哪些用法?

或final 关键字的作用...

1. 被ﬁnal修饰的类不可以被继承。

2. 被ﬁnal修饰的方法不可以被重写，但是可以重载。

3. 被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变。

4. 被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率。

5. 被ﬁnal修饰的常量,在编译阶段会存入常量池中。

   

### 2、 synchronized(星克奶是)的优缺点:

1. 优点：解决了多线程的数据安全问题。
2. 缺点：当线程多的时候，每个线程都会上锁，会耗费很多资源，降低程序的运行效率。



### Volatile(窝了)和synchronized有什么区别？

1. synchronized关键字，用来加锁。
2. Volatile只是保持变量的线程可见性。通常适用于一个线程写，多个线程读的场景。



### Volatile能不能保证线程安全？

   不能，Volatile关键字只能保证线程可见性，不能保证原子性。



### DCL(Double Check Lock)单例为什么要加Volatile？

   Volatile可以防止指令重排。



### 3、**static**(是打体可)都有哪些用法?

   静态变量和静态方法，静态内部类，静态块，和静态导包。

1. static关键字这两个基本的用法:静态变量和静态方法，也就是被static所修饰的变量方法都属于类的静态资源,类实例所共享。
2. 除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作。



### ==和equals(忆口是)有什么区别？

   **==**： 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。

1.   比较的是操作符两端的操作数是否是同一个对象。
2.   两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。
3.   比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。

**equals**：

   equals比较的是两个对象的内容是否相等，由于所有的类都是继承自Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。



通俗点讲：是看看左右是不是一个东西。

-   ==（等于）。
- equals（相同）：equals是看看左右是不是长得一样。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。

## 如果重写equals不重写hashCode会怎样

- 两个值不同的对象的hashCode一定不一样，那么执行equals，结果为true，HashSet或HashMap的键会放入值相同的对象。



### Java自动装箱与拆箱

**装箱就是自动将基本数据类型转换为包装器类型**（int-->Integer）；调用方法：Integer的valueOf(int) 方法。

**拆箱就是自动将包装器类型转换为基本数据类型**（Integer-->int）。调用方法：Integer的 intValue方法。



### 重写与重载的区别：

**重写 ：** 

1. 发生在父类与子类之间
2.  方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private) 
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

**重载（Overload）：**
   在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。
     注意：重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。

### 7、Java 中能创建 volatile 数组吗？

   能，Java 中可以创建 volatile 类型数组，但是只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。



### 6、列出一些你常见的运行时异常？

1.  ArithmeticException（算术异常）
2.  ClassCastException （类转换异常）
3.  IllegalArgumentException （非法参数异常）
4.  IndexOutOfBoundsException （下标越界异常）
5.  NullPointerException （空指针异常）
6.  SecurityException （安全异常）



## 集合：



![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/Java%20SE/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png)



### 2、 HashMap 在 jdk 1.7 和 1.8 的区别？

1.    1.7 的底层是数组+ 链表；      1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询的效率。
2.  1.7中链表插入使用的是头插入法；      1.8中链表插入使用的是尾插入，因为1.8中插入key和value时需要判断链表元素格式，所以需要遍历链表统计表示元素个数，所以正好就直接使用尾插法。
3.  1.7中哈希算法比较复杂，存在各种右移与异或运算；     1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。



### 3、 String、StringBuﬀer和StringBuilder 的区别是什么?

​    String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个ﬁnal类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。
   StringBuﬀer和StringBuilder他们两都继承了AbstractStringBuilder (鸭死拽可特) 抽象类，从AbstractStringBuilder抽象类中我们可以看到,他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuﬀer和StringBuilder来进行操作。 另外StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

### 4、ArrayList 和 LinkedList 的区别是什么？

1.  底层数据结构
   ① ArrayList是动态数组的数据结构
   ② LinkList是一个双链表的数据结构 
2.  操作数据效率
   ① ArrayList底层是数组，查询快，增删慢
   ② LinkList底层数据结构是链表，查询慢，增删快 
3.  空间
   ① ArrayList底层数组，内存连续，节省内存
   ② LinkList底层数据结构是链表，存储数据的时候，要多存两个指针，更占内存。 
4.  线程是否安全： ArrayList 和 LinkList都是线程不安全的。

**适用场景分析:**

- 当需要对数据进行对随机访问的时候，选用 ArrayList。
- 当需要对数据进行多次增删修时，采用 LinkedList。
- 如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免 ArrayList 的扩容，以及非顺序的插入。



### 如何保证ArrayList和 LinkList的线程安全：

1. 在方法内使用，局部遍历则是线程安全。
2. 使用 synchronized关键字。

```java
  List<Object> syncArrayList=Collections.synchroizedList(new ArrayList<>());
  List<Object> syncLinkedList=Collections.synchroizedList(new LinkedList<>());
```



### 5、**HashMap和HashTable的区别：**

   1. **发布的版本不同：** 

       Hashtable 是JDK 1.0发布，HashMap 是JDK 1.2发布。 

2. **两者父类不同**

​    HashMap是继承自AbstractMap(鸭死拽可特Map)类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制, 扣了保）、Serializable（可序列化,JDK1.8+）这三个接口。 

3. **对外提供的接口不同**
   Hashtable比HashMap多提供了elments() 和contains() 两个方法。 elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。
   contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。 
 4.  **对null的支持不同**
      Hashtable：key和value都不能为null。
      HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。 
  5.  **安全性不同**
      HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。
      Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。
      虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap(看卡了HashMap)。
      ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。 
   4.  **初始容量大小和每次扩充容量大小不同**
          Hashtable 的初始长度是 11，之后每次扩充容量变为之前的2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。 
   5.  **计算hash值的方法不同**
      Hashtable 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。 

   注意：Hashtable 是线程安全，推荐使用 HashMap 代替 Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。



### 6、Collection(可辣肾)包结构，与Collections的区别

1. Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack。
2. Collections是集合类的一个帮助类， 它包含各种有关集合操作的静态多态方法，常用于对集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

### 7、Java的四种引用，强弱软虚：

1.  强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收。使用方式： 

```java
String str = new String("str");
System.out.println(str);
```

1.  软引用：软引用在程序内存不足时，会被回收。 
2.  弱引用：弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。 
3.  虚引用：虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue 。 

### 8、Java创建对象有几种方式？

java中提供了以下四种创建对象的方式:

1. new创建新对象。
2. 通过反射机制。
3. 采用clone机制。
4. 通过序列化机制。

### 11、说说List,Set,Map三者的区别？

1. List(有序集合，序列集合)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象
2. Set:  不允许重复的集合。不会有多个元素引用相同的对象。
3. Map:  使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

### 用过 **ArrayList** 吗？说一下它有什么特点？

Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。

底层是使用数组实现，添加元素。如果 add(o)，添加到的是数组的尾部，如果要增加的数据量很大，应该使用 ensureCapacity()方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。如果使用 add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。

ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList 里面的 clone() 复制其实是浅复制。



### HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？

这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下ConcurrentHashMap 数据结构以及底层原理等。

### HashMap中的 **key** 我们可以使用任何类作为 **key** 吗？

平时可能大家使用的最多的就是使用 String 作为 HashMap 的 key，但是现在我们想使用某个自定义类作为 HashMap 的 key，那就需要注意以下几点：

1. 如果类重写了 equals 方法，它也应该重写 hashCode 方法。类的所有实例需要遵循与 equals 和 hashCode 相关的规则。
2. 如果一个类没有使用 equals，你不应该在 hashCode 中使用它。
3. 咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。



### **HashMap** 的长度为什么是 **2** **的** **N** 次方呢？

为了能让 HashMap 存数据和取数据的效率更高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。

我们首先可能会想到 % 取模的操作来实现。

下面是回答的重点哟：

```plain
取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。
```

这就是为什么 HashMap 的长度需要 2 的 N 次方了。



### **HashMap** **与** **ConcurrentHashMap(看卡了HashMap)** 的异同:

1. 都是 key-value 形式的存储数据；
2. HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；
3. HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry，Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。



### set集合特点：

1. ①不包含重复元素的集合
2. ②没有带索引的方法，所以不能使用普通for循环遍历
3. 注意： HashSet 对集合的迭代循环不做任何保证（如果要保证元素唯一性，需要重写hasCede()和equals()）



### 反射：

Java反射机制:是指在运行时去获取一个类的变量和方法信息。然后通过获取 到的信息来创建对象，调用方法的 一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成 确定，在运行期依然可以扩展

## 线程：

线程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。
①是系统进行资源分配和调用的独立单位。
②每一个进程都有它自己的内存空间和系统资源。

### [2、在 Java 程序中怎么保证多线程的运行安全？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#2在-java-程序中怎么保证多线程的运行安全)  


出现线程安全问题的原因一般都是三个原因：

1.  线程切换带来的原子性问题。   解决办法：使用多线程之间同步synchronized或使用锁(lock)。
2.  缓存导致的可见性问题。    解决办法：synchronized、volatile、LOCK，可以解决可见性问题

3. 编译优化带来的有序性问题。   解决办法：Happens-Before 规则可以解决有序性问题



### 3.高并发中集合有那些问题:

#### 第一代线程安全集合类

Vector、HashTable
是线程安全的：使用synchronized修饰方法。
缺点：加上同步锁之后保证线程安全了但是同时也导致了效率低下

后来，jdk的作者发现其实大多数情况下这种集合类是用不到线程安全的，所以就诞生了线程非安全集合类

#### 第二代线程非安全集合类

ArrayList、HashMap
线程不安全，但是性能好，用来替代Vector、HashTable
使用ArrayList，HashMap，需要线程安全时怎么办呢？
使用Collections.synchronizedList(list); Collections.synchronizedMap(map);
这样，底层使用synchronized代码块锁，虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外面性能可以理解为稍有提高吧，毕竟进方法本身就是要分配资源的。

#### 第三代线程安全集合类

在大量并发情况下如何提高集合的效率和安全呢？
java.util.concurrent.*
ConcurrentHashMap
CopyOnWriteArrayList;
CopyOnWriteArraySet;
底层大多数采用Lock锁（jdk1.8的ConcurrentHashMap不使用Lock锁），保证线程安全的同时，性能也很高。





### 12、简述线程、程序、进程的基本概念。以及他们之间关系是什么?

进程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。
①是系统进行资源分配和调用的独立单位。
②每一个进程都有它自己的内存空间和系统资源。

   线程分为：并发、串行和并行。

1.  并发：同一时刻多个线程在访问同一个资源，多个线程对一个点。
         例子：春运抢票、微信抢红包、电商秒杀... 
2.  串行
   ①串行-同步串行：代表多任务按先后顺序执行，并且都是**同一个线程**来执行。
      ②串行-异步串行：代表多任务按先后顺序执行，并由**不同的线程**来执行 
3.  并行：多项任务一起执行，之后再汇总
   例子：泡方便面，电水壶一边烧水，一边撕调料倒入桶中。 
4.  任务合并：一个任务的执行依赖于前面多个任务执行的返回值，并且这些任务可以由同一个线程执行，也可以由不同的线程执行； 



### 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

1. **线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
2. **程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
3. **进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。



### 1、说说Java中实现多线程有几种方法:

创建线程的常用三种方式：

1.  继承Thread(死辣的)类 。 
2.  实现Runnable(泸的薄)接口。 
3.  实现Callable(扣里薄)接口（ JDK1.5>= ） 
4.  线程池方式创建。 

通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。



### 2、  采用实现**Runnable**、**Callable**接口的方式创建线程的优缺点

   **优点**：线类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。

**缺点**：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法

### [1、什么是ThreadPoolExecutor(线程池)？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#1什么是threadpoolexecutor)

ThreadPoolExecutor**(线程池)**其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）

构造参数参数介绍：

```
corePoolSize 核心线程数量
maximumPoolSize 最大线程数量
keepAliveTime 线程保持时间，N个时间单位
unit 时间单位（比如秒，分）
workQueue 阻塞队列
threadFactory 线程工厂
handler 线程池拒绝策略
```





### 3、 采用继承**Thread**类的方式创建线程的优缺点：

   优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程

缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。



### 2、如何停止一个正在运行的线程

1.  使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 
2.  使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。 
3.  使用interrupt方法中断线程。 

```java
class MyThread extends Thread {
    volatile boolean stop = false;
    public void run() {
        while (!stop) {
            System.out.println(getName() + " is running");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("week up from blcok...");
                stop = true; // 在异常处理代码中修改共享变量的状态
            }
        }
        System.out.println(getName() + " is exiting...");
    }
}
class InterruptThreadDemo3 {
    public static void main(String[] args) throws InterruptedException {
        MyThread m1 = new MyThread();
        System.out.println("Starting thread...");
        m1.start();
        Thread.sleep(3000);
        System.out.println("Interrupt thread...: " + m1.getName());
        m1.stop = true; // 设置共享变量为true
        m1.interrupt(); // 阻塞时退出阻塞状态
        Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
        System.out.println("Stopping application...");
    }
}
```

 



### 3、**notify()**和**notifyAll()**有什么区别？

说明：  **notify（no铁快）可能会导致死锁，而notifyAll则不会。**

### 4、**sleep()**和**wait()** 有什么区别？

   sleep()方法属于Thread(死辣的)类中的。而wait()方法，则是属于Object类中的。

  虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。



### 5、**volatile** **是什么?**可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。
2. 禁止进行指令重排序。

volatile 不是原子性操作



### 6、什么叫保证部分有序性?

   当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

### 6、Thread类中的**start()** 和 **run()** 方法有什么区别？

   start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。



7、为什么**wait, notify** **和** **notifyAll**这些方法不在**thread**类里面？

   JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。



8、为什么**wait**和**notify**方法要在同步块中调用？

1. 只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。
2. 如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。
3. 还有一个原因是为了避免wait和notify之间产生竞态条件。



wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。



在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:"特殊状态已经被设置"。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。

9、Java中**interrupted** 和 **isInterruptedd**方法的区别？

interrupted() 和 isInterrupted()的主要区别是前者会中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。



10、Java中**synchronized**和 **ReentrantLock**有什么不同？

相似点：它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.



区别：这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/ﬁnally语句块来完成。



### 11 、有三个线程T1,T2,T3,如何保证顺序执行？

在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一
个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调
用T2，T2调用T1)，这样T1就会先完成而T3最后完成。实际上先启动三个线程中哪一个都行， 因为在每个线程的run方法中用join方法限定了三个线程的
执行顺序。



### 12、**SynchronizedMap**和**ConcurrentHashMap**有什么区别？



SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModiﬁcationException。



### 13 、什么是线程安全

线程安全就是说多线程访问同一段代码，不会产生不确定的结果。
如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

### 6、线程的 sleep()方法和 yield()方法有什么区别？

1.  sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
2.  线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
3. sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
4. sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

### 7、Java 中能创建 volatile 数组吗？


能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。



### 线程安全的几个级别：

（ 1 ）不可变

   像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用



（ 2 ）绝对线程安全

不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要 付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，例如CopyOnWriteArrayList、CopyOnWriteArraySet。



（ 3 ）相对线程安全

相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

（ 4 ）线程非安全：ArrayList、LinkedList、HashMap等都是线程非安全的类



### 14 、Thread类中的yield方法有什么作用？

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可
能在进入到暂停状态后马上又被执行。



### 15 、Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些
方法。



16 、说一说自己对于 synchronized 关键字的了解

   synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。

Java 6 后 Java 官方从 JVM 层面对synchronized 进行了优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优
化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。



### 17 、说说自己是怎么使用 synchronized 关键字？

1. 修饰实例方法:  作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
2. 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
3. 修饰代码块:  指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
4. 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！



### 18 、什么是线程安全？Vector是一个线程安全类吗？

1. 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。
2. Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。



### 19 、 volatile关键字的作用？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语

```plain
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对
其他线程来说是立即可见的。
禁止进行指令重排序。
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读
取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改
可见性和原子性。
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
```

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



### 20 、常用的线程池有哪些？

1. newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2. newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
3. newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
4. newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行
   任务的需求。
5. newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任
   务的需求。



### 21 、简述一下你对线程池的理解

（可以展开说一下线程池如何用、线程池的好处、线程池的启动策略）

合理利用线程池能够带来三个好处。

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



### 24 、说说进程和线程的区别？

1. 进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。
2. 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以 通信和同步等操作线程比进程更加容易）
3. 线程上下文的切换比进程上下文切换要快很多。 

   - 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。
   - 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。



### 29 ，线程安全需要保证几个基本特征？

1. 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
2. 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
3. 有序性，是保证线程内串行语义，避免指令重排等。



### 38 、多线程有什么用？

1. 发挥多核CPU的优势
2. 防止阻塞
3. 便于建模

# JVM:
## 技术点汇总：

  JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高.
  其中内存模型,类加载机制,GC是重点方面.性能调优部分更偏向应用,重点突出实践能力.编译器优化和执行模式部分偏向于理论基础,重点掌握知识点.
   需了解 **内存模型**各部分作用,保存哪些数据.
    **类加载**  双亲委派加载机制,常用加载器分别加载哪种类型的类.
   **GC**分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景.
 性能调优常有JVM优化参数作用,参数调优的依据,常用的JVM分析工具能分析哪些问题以及使用方法.
   **执行模式**解释/编译/混合模式的优缺点,Java7提供的分层编译技术,JIT即时编译  技术,OSR栈上替换,C1/C2编译器针对的场景,C2针对的是server模式,优化更激进.新技术方面Java10的graal编译器编译器优化javac的编译过程,ast抽象语法树,编译器优化和运行器优化.

## 2 、知识点详解：

![](https://camo.githubusercontent.com/ef5d566ab06b1a3f3f3f260c6634ee02c5f7bca5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303135373431362e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31342c636f6c6f725f4646464646462c745f3730)

1 、JVM内存模型：

 线程独占:栈,本地方法栈,程序计数器 线程共享:堆,方法区

2 、栈：

又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.

3 、本地方法栈

与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.

4 、程序计数器

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行
Native方法时,程序计数器为空.

5 、堆

JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,
当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回
收器进行垃圾的回收管理

6 、方法区：

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7
的永久代和1.8的元空间都是方法区的一种实现

7 、JVM 内存可见性

![](https://camo.githubusercontent.com/80c8d38c672d0fcb4cf152566ab4bea517817d76/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303535393437332e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31322c636f6c6f725f4646464646462c745f3730)

 JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.

![](https://camo.githubusercontent.com/edb24be4f9db4e7d824f697bc563ff7834f37cf4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303631363230362e706e67)

## 3 、说说类加载与卸载

加载过程

![](https://camo.githubusercontent.com/1d9e4e8270674714974213a8bc2eba3f95249f44/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303634313232302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31322c636f6c6f725f4646464646462c745f3730)

 其中**验证,准备,解析**合称链接

**加载**通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.

**验证**确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.

**准备**进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变
量,因为final变量在编译时分配.

**解析**将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量
等.

**初始化**主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用
时才会初始化.

触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时
候,或者某个子类初始化的时候.

Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的
类才可以被卸.

1 、加载机制-双亲委派模式

![](https://camo.githubusercontent.com/a9ee2161e8a4e335c990a92dc5ac24c409a23b86/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323031393035323931303037353335322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31302c636f6c6f725f4646464646462c745f3730)

 双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.

父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.*

 优点:

1. 避免类的重复加载

```
2. 避免Java的核心API被篡改
```

2 、分代回收

分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时
间.

![](https://camo.githubusercontent.com/aee644137a8a1493dbfdd43348e918754b7b1969/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303832343531322e706e67)

年轻代->标记-复制 老年代->标记-清除

 3 、回收算法

a、G1算法

1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全
部的增量式清理,以保证停顿时间不会过长

其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一
部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.

同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间.

年轻代回收: 并行复制采用复制算法,并行收集,会StopTheWorld.

老年代回收: 会对年轻代一并回收

初始标记完成堆root对象的标记,会StopTheWorld. 并发标记 GC线程和应用线程并发执行. 最终标记
完成三色标记周期,会StopTheWorld. 复制/清楚会优先对可回收空间加大的区域进行回收

b、ZGC算法

前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停
顿时间.

![](https://camo.githubusercontent.com/f227b50f5d6c1bd950f3bfc6677da172df00815b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130313232323634382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31302c636f6c6f725f4646464646462c745f3730)

-  着色指针
-  读屏障
- 并发处理

```
基于region
内存压缩(整理)
```

roots标记：标记root对象,会StopTheWorld. 并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld. 清除会清理标记为不可用的对象. roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的比例. 并发重定位与并发标记类似.

​	





# Spring:



## 1 、什么是spring?

1. Spring 是个java企业级应用的开源开发框架。
2. Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。
3. Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。



## 2 、你们项目中为什么使用Spring框架？

直接说Spring框架的好处就可以了。比如说Spring有以下特点：

```plain
轻量：Spring 是轻量的，基本的版本大约2MB。
控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
容器：Spring 包含并管理应用中对象的生命周期和配置。
MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。
```



## 3 、 Autowired和Resource关键字的区别？

@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。

1. [@Autowired ]() 根据类型注入。 
2. [@Resource ]() 默认根据名字注入，其次按照类型搜索。 
3. `@Autowired` `@Qualifie("userService")`两个结合起来可以根据名字和类型注入

注意：@Resource为Java自带的，@Autowired为Spring框架的。 

1.  为什么重写 equals 还要重写 hashcode？ 
3.  为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？ 
4.  介绍 Java 的集合类 
5.  什么是死锁？死锁产生的条件？ 
7.  有哪些进程调度算法？ 
8.  什么是缓冲区溢出？ 



## MyBatis:

## #{}和${}的区别是什么？

1. \#{}是预编译处理，${}是字符串替换。
2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理替换成变量的值。
3. 使用#{}可以有效的防止SQL注入，提高系统安全性。



## 4 、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

1. 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。
2. 通过来映射字段名和实体类属性名的一一对应的关系。



# [MQ: ](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-11)

死信：无法被消费的消息。

应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。

消息成为死信的三种情况:

- 消息 TTL(Time To Live/存活时间) 过期
- 队列达到最大长度(队列满了，无法再添加数据到 MQ 中)
- 消息被拒绝消费消息，(basic.reject 或 basic.nack) 并且不把消息重新放入原模板队列， requeue = false。

## 1 、为什么要使用MQ

核心：解耦,异步,削峰

1 ）解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。

 （ 2 ）异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 +450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一
个请求到返回响应给用户，总时长是 3 + 5 = 8ms。

（ 3 ）削峰：减少高峰时期对服务器压力。

## 2 、MQ有什么优缺点

- 优点：应用解耦 、异步提速 、削峰填谷。

- 缺点：系统可用性降低 、系统复杂度提高、 一致性问题


系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩溃，你不就完了？系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？问题一大堆。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。



## 6 、如何保证消息的顺序性

   顺序错乱的场景：RabbitMQ：一个 queue，多个 consumer，这不明显乱了；

![](https://camo.githubusercontent.com/a493c12e475f8fcd99fdbc898d9c498261bd2b8c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303138313232343135333633363538342e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c32786c6448523561584e745a513d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730)

 解决：

![](https://camo.githubusercontent.com/396b608e74beda4adf7d5f9c5701aa74c7832511/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303138313232343135333731373339362e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c32786c6448523561584e745a513d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730)

## 7 、 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

消息积压处理办法：临时紧急扩容：

先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。

mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。



## 8 、让你来设计一个消息队列，你会怎么设计

比如说这个消息队列系统，我们从以下几个角度来考虑一下：

首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？

其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。

其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -> leader & follower -> broker 挂了重新选举 leader 即可对外服务。能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。





## 延迟队列：

​    延迟队列(死信队列+TTL)：设置TTL在延迟多久之后消息成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。

注意：延迟队列基于死信队列。
队列内部是有序的。
延时队列就是用来存放需要在指定时间被处理的 元素的队列；需要在某个事件发生之后或者之前的指定时间点完成某一项任务。

使用场景：

1.  订单在十分钟之内未支付则自动取消。 
2.  新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 
3.  用户注册成功后，如果三天内没有登陆则进行短信提醒。 
4.  用户发起退款，如果三天内没有得到处理则通知相关运营人员。 
5.  预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。 



1.  使用消息队列有哪些优缺点？ 
2.  如何保证消息消费的幂等性？ 
3.  消息队列有哪些路由模型？ 
4.  你是否用过消息队列，解决过什么问题？ 

是，

# Redis:

注意：主要减少mysql数据库的操作，及IO操作。

## NoSQL特点：

1. **易扩展**：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，易扩展。在架构的层面上带来了可扩展的能力。
2. **大数据量高性能**：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。 这得益于它的无关系性，数据库的结构简单。
       一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。
    而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。

3. **多样灵活的数据模型**：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。



## 怎么解决Redis和mysql数据不一致问题：

注意：只有是分布式中，数据的同步都是有延迟的，短暂的延迟一般也是可以接收的。但最终都是要数据一致的。

1.  先更新数据库，再更新缓存。 
2.  先删除缓存，再更新数据库。    注意：1和2数据库还是不一致。 
3.  先删除缓存，再更新数据库，再删除缓存（缓存延时双删  （缺点：会造成服务器的阻塞，不适合高并发。） 
4.  CANAL+MQ实现最终一致性。 



## 字符串(String):

-  string是redis最基本的类型，一个key对应一个value。 
-  string类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象 。 
-  string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。 
-  特点：单值单Value。   例：  UserLoginVo   `<user:login:, 1>`
-  `redisTemplate.opsForValue().set("order:repeat:" + 1 ，1)`

使用场景：

1. 比如抖音无限点赞某个视频或者商品，点一下加一次
2. 是否喜欢的文章



## 列表(List):

   Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）它的底层实际是个双端链表，最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。
   它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的结点性能会较差。

- 特点:单键多值, 值可重复。   ===>  

- 使用场景：微信公众号订阅消息。




## 哈希(Hash):

   Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）

使用场景：JD早期购物车(目前不再采用)，当前小中厂可用

1. 新增商品 → hset shopcar:uid1024 334488 1
2. 新增商品 → hset shopcar:uid1024 334477 1
3. 增加商品数量 → hincrby shopcar:uid1024 334477 1
4. 商品总数 → hlen shopcar:uid1024
5. 全部选择 → hgetall shopcar:uid1024



## 集合(Set):

- Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。
- Redis 中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 

- 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)

- 特点：单值多value，且无重复，可快速查找、添加、删除
- 例： set  k1  v1 v2 v3    ===>
   使用场景： 

1. 微信抽奖小程序。

| 1 用户ID，立即参与按钮                    | sadd key 用户ID                                              |
| ----------------------------------------- | ------------------------------------------------------------ |
| 2 显示已经有多少人参与了，上图23208人参加 | SCARD key                                                    |
| 3 抽奖(从set中任意选取N个中奖人)          | SRANDMEMBER key 2    随机抽奖2个人，元素不删除SPOP key 3             随机抽奖3个人，元素会删除 |

## 有序集合(ZSet):

-  set(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 
-  不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。 
-  zset的成员是唯一的,但分数(score)却可以重复。 
-  zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1 
-  例：  zset  k1  score1  v1  score2  v2  ===> Map<String,<String,User>>
-  使用场景：根据商品销售对商品进行排序显示。
      思路：定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。 



## 地理空间(GEO) 3.2+:

-  Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括
   添加地理位置的坐标。获取地理位置的坐标。计算两个位置之间的距离。根据用户给定的经纬度坐标来获取指定范围内的地理位置集合 

   地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。

问题：

1.  查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的 
2.  这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。 
3.  精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差
   注意： 核心思想就是将球体转换为平面，区块转换为一点。 



## 基数统计(HyperLogLog) 2.8.9+:

- HyperLogLog 是用来去重复统计功能的基数估计算法。

- 优点：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。

- 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

- 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

   基数： 是一种数据集，去重复后的真实个数。

使用场景：

1. 美团地图附近位置的酒店推送
2. 高德地图附近位置的核酸检查点



## redis位图(bitmap):

原理：由0和1状态表现的二进制位的bit数组。 说明：用String类型作为底层数据结构实现的一种统计二值状态的数据类型 位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们称之为一个索引)。 Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2^32 = 4294967296)

![img](https://qsl.ztpan.tk/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/SQL/NoSQL/Redis/%E4%BD%8D%E5%9B%BE-BitMap.png)

使用场景：

1.   统计某个网站的UV、统计某个文章的UV(Unique Visitor，独立访客，一般理解为客户端IP,==需要去重考虑==)
2.   用户搜索网站关键词的数量
3.   统计用户每天搜索不同词条个数
4.   天猫网站首页亿级UV的Redis统计方案



# [Nginx](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-12)

1.  ## Nginx 有哪些作用？
   
   *Nginx* (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。
   ①Nginx服务器的最佳用法是在网络上部署动态HTTP内容（部署网站）
   ②通过Tomcat部署网站搭集群（负载均衡器）。
   
    
   
2.  Nginx 有哪些负载均衡策略？ 

## 7 、请解释代理中的正向代理和反向代理

首先，代理服务器一般指局域网内部的机器通过代理服务器发送请求到互联网上的服务器，代理服务器一般作用在客户端。例如：GoAgent翻墙软件。我们的客户端在进行翻墙操作的时候，我们使用的正是正向代理，通过正向代理的方式，在我们的客户端运行一个软件，将我们的HTTP请求转发到其他不同的服务器端，实现请求的分发。

反向代理服务器作用在服务器端，它在服务器端接收客户端的请求，然后将请求分发给具体的服务器进行处理，然后再将服务器的相应结果反馈给客户端。Nginx就是一个反向代理服务器软件。

注意：

  客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 

  反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。

# [Spring Cloud](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-14)

1. 什么是微服务，有哪些优缺点？ 

      ①微服务是一种框架模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。
      ②每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常基于HTTP协议的RESTful API）。

2. 什么是注册中心，能解决什么问题？

   

3. 22、如何提高系统的并发能力？

   使用分布式系统。
   部署多台服务器，并做负载均衡。
   使用缓存（Redis）集群。
   数据库分库分表 + 读写分离。
   引入消息中间件集群。 

Nacos、OpenFeign、Gateway、Sentinel、Steata

# [SQL](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-5)

1. MySQL 索引的最左原则 

2. InnoDB 和 MyIsam 引擎的区别？ 

3. 有哪些优化数据库性能的方法？ 

4. 如何定位慢查询？ 

   

5. MySQL 支持行锁还是表锁？分别有哪些优缺点？ 



# Git:

## Git如何解决冲突问题：

1.  两个分支中修改了同一个文件
   解决方法：当前分支上，直接修改代码，再添加(add) 到 缓冲区、commit(存储库) 
2.  两个分支中修改了同一个文件的名字
   解决方法：在本地当前分支上，修改冲突代码，再添加(add) 到 缓冲区,  commit(存储库)、  push(推送) 

​     冲突产生的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容。





## 什么是Git：

1. Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本。
2. 与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。
3. 每个开发人员都可以“克隆”服务器存储库中的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要所有的恢复数据都在你队友的本地 Git 存储库中。
4. 还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享。



## **Git** **是用什么语言编写的？**

你需要说明使用它的原因，而不仅仅是说出语言的名称。
Git使用 C 语言编写(但不是 C# 或 C++)。 GIT 运算很快的原因，就是因为C 语言通过减少运行时的开销来做到这一点。



## 6、在Git中，你如何还原已经 push 并公开的提交？

```plain
There can be two answers to this question and make sure that you include both because any
of the below options can be used depending on the situation:
```

这个问题可以有两个答案，你回答时也要保包含这两个答案，因为根据具体情况可以使用以下选项：

1. 删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我使用的远程存储库

```plain
git commit -m "commit message"
```

1. 创建一个新的提交，可以使用↓版本回退命令，撤消在错误提交中所做的所有更改。

```plain
git revert <name of bad commit>
```



# 项目：

   大学生没实习哪来的项目经验： 项目是学校老师接单，给我们这些人练手的。
   项目通用流程：用户登录、注册，忘记密码、修改密码。

## 其他：

### 项目中遇到过什么重要的bug。

​    当时项目连接Redis的时候,正确的Redis密码写在`yml`文件写对了项目中却怎么也连接不上。然后我当时就去Redis查看密码，密码正确，Linux系统使用这个密码的时候也可以连接的上，Java项目中怎么也连接不上，然后，我就去Linux改了下Redis的密码，然后发送项目中居然能用Redis连接了，然后

## 项目中怎么返回数据给前端：

  我在项目中定义了一个泛型类-统一返回结果，把状态码、返回状态信息、数据返回给前端。 如果觉得每次都写状态码、状态信息的话、就把状态码、状态信息都写进一个枚举类里面，返回数据的时候就把枚举类调用一下就行了。



注册：

用户注册传递

   介绍完项目项目流程一般从：项目流程或技术(项目中ES和MQ了，那些场景使用的)亮点入手。



## 食界通外卖（B2B2C）：

### 常识：

#### 1．请介绍一下你最近做的这个项目吧？

  食界通外卖是基于XX公司原有的校园派送服务进行业务升级，定制化开发的一套面向大学生的团购优选平台。项目依托于公司在全省高校经营的快递驿站或合作的校园驿站、便利超市、水果等为基础，面向校园大学生群体精细化运营，打造垂直化的电商、社交平台。

​    目前项目一期已上线，覆盖高校30余所，注册大学生用户超5W＋，日均订单3000＋。

项目平台：

- 公司运营平台：仓储、配送调度、供应链、结算、订单管理、营销中心
- 团长终端：团购发起、物资清单分拣、收益结算、售后处理
- 用户小程序终端：搜索、购物车、订单、用户中心、活动

技术架构：
   项目基于微服务技术架构，主要以Alibaba 系列微服务组件进行构建，围绕业务拆分需求，每一块业务对应一个微服务，例如：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务。
   项目中用到的其他技术栈也挺多的，比如：SpringBoot、MybatisPlus、Redis、 RabbitMQ、Elasticsearch、OSS、MySQL、Nginx等等。

岗位职责：
   我在这个主要承担Java后端开发，算是一个核心人员吧，因为我刚入职的时候，这个项目才刚开始，所以我也算老员工了。有的时候也会帮助新同事快速适应这个项目的技术栈。到项目后期，我也会指导一下实习生，帮忙写一写接口文档和使用手册。
    这个项目怎么说呢，我们对于工作划分没有那么细致，每一个业务模块我都有所参与。我比较熟悉的模块比如：权限管理模块、商品模块、订单模块、购物车模块、搜索模块是我主要负责完成的。

这就是我最近这个项目的大致情况。



#### 2．说一下你们项目的数据库表是怎么设计的吧，分了几个库和表，你负责设计过哪些数据表？

  数据库设计是在项目初期阶段完成的。当时我们先确立了基本需求以及采用微服务技术架构后，围绕业务设计数据库表结构。

  我们一共分了设计了6个数据库，分别是：权限管理、活动、订单、商品、系统管理、用户管理这6个数据库。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E6%95%B0%E6%8D%AE%E5%BA%93.png)

  我当时主要负责权限管理、商品管理、订单管理相关的数据模型设计，当然不全是我一个人说了算，这些数据表设计完成后，是需要开会评审的，经过项目经理审核通过才能使用。

  我设计数据模型的思路就是，围绕业务进行设计。

  首先我们是拆分出来有哪些业务模块，优先梳理出核心业务，围绕核心业务进行设计数据表，这部分工作主要是产品经理完成的，他会给出初版的需求文档。然后我围绕我负责的几个模块，分析相关的业务流程，每一个流程的业务涉及到哪些实体，整个业务流程围绕这几个实体是怎么运转的，当我把这些想明白后，我直接使用 **PowerDesigner**(破我滴晒呢)绘制物理数据模型，就是ER图。评审的时候，就是围绕ER图进行讨论，审核通过，就导出数据库的建表语句进行开发。
  我设计的权限相关的数据表有：管理员表、角色表、权限表、管理员角色中间表、角色权限中间表、后台用户登录日志表。

   订单数据库相关的表：购物车表、订单配送表、订单表、订单项信息表、订单操作日志记录表、订单退货申请表、退货原因表表、订单设置表、支付信息表、退款信息表

  商品管理数据库相关的表：商品属性表、属性分组表、三级分类表、商品评价表、商品评价回复表、sku表、sku属性表、sku详情表、sku图片表、sku海报表、sku的库存历史记录。

   备注：回答一半就行了。

  这些数据表其实也是随着业务需求不断改变的，我们项目是以月度为单位下发需求的，有的时候需求变动了，多少会改一些数据库字段、新增一两张数据库。

#### 3.项目整体技术架构给我介绍一下？

​      注意：别直接回复我们项目中用的了SpringCloud Alibaba、Nacos、OpenFeign等技术。 没多大的意义,最后结合项目业务来讲。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%842.png)

  我们项目基于微服务技术架构，围绕业务拆分了十个核心的业务微服务，分别是：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务
    项目前后端分离开发和部署。前端分了平台运营管理、会员小程序端、团长端三个终端当前端请求后端时，首先经过网关层。网关这边我们设置了两层网关
    首先是使用Nginx搭建入口网关，我们采用主备的方式搭建的，保障Nginx的高可用我们把前端项目和前端的静态资源部署在Nginx，当请求过来后，直接从Nginx服务器返回。
    如果是动态请求，Nginx服务器会转发给Gateway网关微服务，网关这边我们设计了灰度发布、登录状态校验等全局过器
    Gateway网关微服务会从Nacos中拉取服务列表，按照配置的路由规则转发给后面的业务微服务，默认规则是轮询。
    微服务相关的组件我们用到了：Nacos、OpenFeign、Sentinel、SkyWalking、Seata等微服务组件。
    另外在业务设计的时候，也会用到一些中间件或者第三方服务，比如：阿里云的OSS对象存储、基于Redisson实现的分布式锁、使用Redis作为缓存组件、RabbitMQ消息队列满足一些非强一致性和服务解耦的场景、使用ElasticSearch设计搜索服务，并且基于ELK技术栈搭建日志收集平台等等
    而像业务微服务中的开发，还是以SpringBoot、MybatisPlus、MySQL、Redis这些基本的开发技术作为主要实现
    日常工作中也用到了PostMan、Knife4、JMeter等开发工具
    别的话也没什么了，还有就是交付的时候，我们使用Jenkins做了整合，实现自动构建Docker镜像、自动部署
    我们是提前编写好Jenkins脚本，需要的时候只需要在JenkinsWeb页面中操作，一键部署项目。

#### 4.大概介绍一下这个项目的工程结构吧，说一说为什么这么设计？

 此方法不常问。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png)

我们项目采用前后端分设计开发，我们后端工程只编写后端代码。使用Maven管理整个项目。
    首先，在父工程pom文件中统一管理依赖，锁定依赖的版本号，避免版本号冲突的问题，并且聚合所有的子工程
     然后创建service工程，工程类型为pom格式，也是用来聚合所有的业务微服务，并统一管理了所有业务微服务的通用依赖，例如：web场景启动器、MybatisPlus场景启动器、MySQL、Nacos、Sentinel、OpenFeign等等。这样每一个业务微服务只需要继承父工程后就自动拥有了这些依赖，不用重复导入了。
    在实际开发过程中，总有一些工具类需要在多个工程中重复使用，所以我们又创建了common工程，用来存放一些封装的工具类，比如：字符串处理相关、RabbitMQ、Redis等相关的工具类
    还有就是为了方便微服务之间的调用，我们单独创建了一个service-client工程，用来保存每一个业务微服务对外提供服务的Feign接口，一个业务微服务相关的Feign接口，在一个service-client的子工程中。
    因为微服务调用的时候，一些实体类需要在双方微服务之间传递，所以创建了model工程，统一管理了所有的V0、实体类、枚举类等。
      最后还有一个网关微服务，请求到后端后，先由网关微服务处理，网关微服务根据预先配置的路由规则，路由到业务微服务中对请求进行处理

### 业务篇：

#### 5.介绍一下你们项目中的权限管理模块吧

题外话：课程中讲的这块权限管理太简单，就是：用户、角色、权限的CRUD以及一个菜单列表的递归查询，如果就这样给面试官说的话，说不出来什么花样来。思路如下：
   后台管理系统是面向公司运营人员的，前台是面向普通用户的，我们这里做的是后台管理系统的权限控制，和前台项目面向普通用户的客户端没有任何关系这一点一定要分清楚啊！
   单独设计权限微服务负责后台系统的权限模块
   权限管理采用SpringSecurity进行控制
   前端要体现不同权限的用户，展示的菜单项是不一样的
正式回答
    我们项目的平台运营管理端是面向于平台运营人员、管理人员、审核、物资配送、客服等不同岗位的人员进行使用。所以这是一个权限比较复杂的管理系统，我们设计了一个独立的权限微服务实现权限控制
    不同岗位的账户登录到系统后，看到的菜单项是不一样的，这是因为他们具备的权限不一
样。
    我们关于平台运营管理平台的权限微服务，是采用SpringSecurity权限框架+RBAC模型普通用户没有这个权限，平台管理员权限最高。

​    不同岗位的账户登录到系统后，看到的菜单项是不一样的，这是因为他们具备的权限不一样。
​     我们关于平台运营管理平台的权限微服务，是采用SpringSecurity权限框架+RBAC模型实现的。不同岗位的用户，具备的角色是不一样的，能够在管理系统中看到的菜单项自然也是不一样的。
​          角色和菜单的关联关系，是由管理员进行维护的
​       这个权限管理相关的模块有：**角色管理、用户管理、菜单管理**几个模块
​       后台管理系统我们是不对外提供注册的，如果有新的团长、司机、平台运营等新人加入是由直属领导也就是对应的部门经理为其分配新的账号。
​      用户在管理平台首次登录是需要重置密码的，用户登录成功后，会把用户信息、权限信息是存储在Session中，当然，这个Session我们使用SpringSession进行整合，将用户登录信息存储在Redis当中，实现了分布式会话。
​       另外还会返回前端一个UUID的Token，作为用户的唯一标识，前端会保存在本地Cookie后续访问时，在请求头中携带该Cookie，后端根据这个Cookie校验用户的登录状态以及权限信息。
​     后续用户在访问项目资源时，由SpringSecurity完成授权操作，它会校验用户所具备的权限是否满当前正在访问的资源需要的权限
​     另外就是用户每次登录成功后，前端都会自动请求后端，查询当前用户能够访问的菜单列表，并缓存到前端本地Cookie。当用户退出登录或者关闭浏览器，Cookie数据自动失效。用户下次登录重新查询。
​    而前端会根据查询到的用户菜单列表，在页面的左侧菜单列表中进行展示。
​    还有一点和权限相关的，就是前端每次请求时，会在请求头中携带用户Token，请求到达网关微服务，网关微服务校验如果请求头中没有携带用户Token，且当前请求不是和登录相关的请求，就会直接拒绝访问，前端重定向到登录页面进行登录。



#### 6.区域管理模块：

题外话：
     区域管理在课程中只是基本的CRUD功能，所以在讲解类似这种特别单的CRUD案例时，大家不结合实际业务场景，给面试官去吹。
     另外就是课程中讲解的区域覆盖全国，但是我不想把公司经营规模说这么大，毕竟我们是包装简历，不要吹的太大。可以改一下，比如把全国改为全省，把区域改为校园
    例如：
         上家公司主营XX省内的业务，在省内招了很多代理（团长），精细化的去营销上家公司主营高校业务，在省内各大高校招了很多代理（团长），针对大学生打造垂直领域的精准营销。
说实话，这个流程真的太简单，主要是课程中讲过，所以博哥这里才都列出来。如果面试的时候，面试官不问，你就不用主动讲这个特别简单的CRUD模块了。

正式回答，可以把区域改为校园
    我们公司目前在全省30多所大学校园中都发展了代理，每一个校级代理针对他所在校园进行运营。
    首先我们会录入全省的所有高校的校园信息。
    每当运营发展了-新的校园代理后，会为这个校园开通运营权限。
    开通校园运营权限流包含：录入代理商的各项信息（基本信息、银行账号等）、绑定校园与仓库的关联关系我们公司在每一个开通运营的城市中，都搭建了一个仓库，校园需要和仓库进行绑定后续每天商品的配送，都是由校园绑定的仓库发出的
    而用户在小程序端登录以后，必须先选择他所在校园，如果他所选的城市或校园没有开通运营，则无法使用，会提示用户尚未开通。
    在我设计这块业务的时候，我设计了4张表，分别是：校园代理商信息表（我临时编的）、校园表、仓库表、校园仓库关联表来保存代理商、校园和仓库的关联关系
    编写过的相关业务流程有：校园信息的管理流程、仓库信息的管理流程，以及校园区域开通流程和取消流程
    其中，校园信息和仓库信息管理都是基本的增删改查。比较复杂的是，在校园区域开通流程中，就是判断当前校园是否已经有代理商、当前城市是否开通了该业务。如果当前城市开通了该业务，并且该校园之前没有入住过代理商，那么就保存校园和仓库的关联关系，代表该校园业务开通成功。

```sh
3、Redis
  ①用户登录微信小程序后，使用String类型存放当前用户信息
  ②首页数据的爆款商品，使用zset类型存储商品信息
  ③当前用户的购物车信息，使用hash类型存储
  ④生产订单，商品锁定库存和其他信息
4、Redisson(分布式锁)
   ①生成订单，使用分布式锁，锁定商品库存
5、RabbitMQ
  ①上下架商品
  ②生成订单后，使用RabbitMQ删除当前用户的购物车信息
  ③支付完成后，根据订单号更新订单的状态(改为待发货)和库存（减库存）
6、ElasticsEarch(ES)
  ①使用SpringData简化ES索引库的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。
  ②ES存储商品上下架信息 和10件热销产品,来提高用户查询的速度。
  ③点击查看商品信息，使用Redis的Zset类型存储当前商品的Id,判断除以10等于零后添加到索引库中；可以减少索引库中的数据量，提高索引库的查询效率。
```





#### 7.商品信息管理模块

​    关于商品管理，我们是拆分了一个单独的商品微服务实现的，主要围绕商品相关的业务设计包含：商品分类、平台属性、平台属性分组、商品SKU信息、商品评价与回复这些相关的业务流程。
  关于这些业务流程都是我做的，需要我个给您介绍一下嘛
备注：一般到这个时候，面试官就两个选择：1、可以，你挑重点的说一下；2、不用，你把XX流程说一下。

##### 7.1商品分类管理流程：

   商性分组商品分类这块我们大概分了十几个一级商品类目，因为我们经营的商品类目大多以快消品为主，相对来说比较垂直 所以商品品类不会太多，只设计了一级分类就足够用了。比如说水果、海鲜、冻品、乳品烘焙、面包蛋糕、休闲流式、鲜花宠物之类的。

   分类管理相关流程比较简单，必须是具备管理员权限的账户登录进来，可以针对商品分类进行管理，商品分类字段就是主键id、商品分类名称、分类图片、分类状态以及排序顺序这么几个字段。          

   类似拼多多的首页分类那样：                                                                                                                   ![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86.png)

#####  7.2商品属性和属性分组流程：

​     每一个商品都有很多属性，为了便于管理商品属性，我们针对属性进行了分组
​     每一个属性分组对应某一类型的商品，例如：生鲜水果、速冻食品。
​     然后就是商品和属性分组的绑定关系为一对一，可以在商品SKU管理中进行设置
​      而属性和属性分组的关系是多对一，业务流程是这样的，首先创建属性分组，在属性分组列表中，可以点击添加属性，为当前属性分组添加多个属性。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%88%86%E7%BB%84%E6%B5%81%E7%A8%8B.png)


保存的时候使用两张表进行保存，分别是属性分组表和属性表
保存商品属性的时候,通过外检列，关联属性分组表的数据记录。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%88%86%E7%BB%84%E6%B5%81%E7%A8%8B2.png)



##### 7.3商品SKU管理流程:

题外话： 商品SKU管理流程中,这里最多加一个防重提交的验证。
     在我们项目中，没有SPU的概念，直接就是SKU。因为我们的商品其实都是提前打包或者分类好的，也不存在一个商品要区分不同的购买选择，包括详情页介绍也是非常简单的，因为我们卖的大多都是快消品，而且顾客在我们这里购买，也不会有太多的分类要求
    例如：我们把西瓜按照8-10斤，10-12斤这种方式分类，然后按个卖。或者苹果、香蕉按照斤来卖，提前分好斤数并塑封包装好。包括像酸奶、面包、零食等等，也都是按照个或盒的形式进行售卖，买家如果想要购买多个，只需要填写不同的数量就可以了。
    所以在后台运营上架商品的时候，直接填写单个SKU的信息就可以了。
    在上传商品SKU的时候，使用SKU基本信息表、详情表、图片表、海报图片表、SKU属性值表5张表进行保存。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81SKu%E8%A1%A8.png)

在填写商品详情时，前端使用富文本编辑器进行编辑,将编辑完毕的商品详情，在前端转为HTML代码，保存在商品详情表中。
     当选择了商品关联属性分组时，会异步的形式向后端查询商品分组的所有属性，并展示在页面中，由管理员手动录入商品的各项属性值，使用SKU属性值表进行保存
     关于商品图片部分，我们是购买了阿里云的OSS对象存储资源，将图片保存到了阿里云服务中，在数据表中保存的是图片的URL路径。
     当商品SKU新增完成后，并不代表就可以立刻购买，还需要通过审核和上架流程，才能正式被购买。
    审核流程是需要经过运营的领导，一般是城市经理进行审核。审核通过后，运营人员才可以决定是否上架。
     而在上下架的过程中，我们是使用**Elasticsearch+RabbitMQ**进行实现的
    其他流程就是修改和删除，是最基本的功能，代码实现也非常简单
    只不过需要注意的是，在针对商品SKU进行增删改的时候，为了防止重复提交，我们会在前端进入到页面之前，后端会下发一个临时的验证Token，这个Token一份存在Redis，一分返回到前端。当前端正式提交增删改操作时，这个防重Token也会随着请求一起发送到后端。
    后端在处理的时候，先从Redis中检查该防重Token是否存在。如果不存在，则表明该表单已经提交过了，应该拒绝处理，如果存在，则先删掉这个Token，  返回值为1， 代表删除。

只不过需要注意的是，在针对商品SKU进行增删改的时候，为了防止重复提交，我们会在前端进入到页面之前，后端会下发一个临时的验证Token，这个Token 一份存在Redis，份返回到前端。当前端正式提交增删改操作时，这个防重Token也会随着请求一起发送到后端。
    后端在处理的时候，先从Redis中检查该防重Token是否存在。如果不存在，则表明该表单已经提交过了，应该拒绝处理。如果存在，则先删掉这个Token，且返回值为1，代表删除成功，允许继续执行提交请求。反之，如果返回0则代表删除失败，拒绝处理提交请求。
    还有一个细节就是，如果商品处于上架状态，是不允许被删除的，必须先下架，才能被删除。因为商品信息如果上架后，会在ES中保存一份，所以必须要先执行下架。在下架流程中，会清理掉ES中的商品数据，下架后才可以删除该商品。    

##### 7.4商品评价流程:

​    题外话：商品评价在课程中没有讲的。
正式回答：
​     商品评价功能是商品微服务中实现的，使用商品评论表和商品回复表进行保存。

   当订单确认交易成功后，买家是可以针对商品进行评价的。当买家评价完毕后，商家可以进行回复。分别使用评价表保存首次评价，使用评价回复表保存评价回复评价和评价回复不同之处在于，评价数据可以包含文字、图片、视频，并且其他买家可以给评价进行点赞。
   而评价回复只能是文字的形式另外就是在评价的时候，我们设计了敏感词过滤，防止一些不文明的词汇出现我设计了单独的一张敏感词汇表，保存敏感词汇。并且利用**DFA算法**封装了一个工具类简化敏感词匹配的过程。如果买家评论的内容有敏感词汇，则不允许发布评论额外扩展。
   DFA算法是一种确定有穷自动机的方式。以前我们是使用的传统的字符串比较方式，就是遍历所有的敏感词，然后在每次循环中，将整片文章字符串传入，然后调用contains方法进行判断，这种方式效率非常差。所以我们改成基于DFA算法的实现方式。
   在实际使用的时候，我是封装了一个工具类，一次性的把有的敏感词存储到了多个map中，然后和文章内容进行比对，map中的某一个词项能够和文章中的词项比对上，就结束这种算法的原理，我大概理解就是将预先输入的词项，构建成一个类似索引的数据结构，匹配的时候也是按照顺序进行匹配，如果输入的内容能够匹配到某一个索引的终点，就代表某一个词项在文章中出现过。







## 大学课堂项目：

![img](D:/StudyViden/Java/%25E9%25A1%25B9%25E7%259B%25AE/%25E7%25A1%2585%25E8%25B0%25B7%25E8%25AF%25BE%25E5%25A0%2582/%25E7%25AC%2594%25E8%25AE%25B0/images/%25E5%258A%259F%25E8%2583%25BD%25E6%259E%25B6%25E6%259E%2584%25E5%259B%25BE.png)

1.  
2. 项目中使用了很多Api接口，像微信公众号导航栏啊、微信登录、微信支付、欢拓云直播接口，学习到了怎么对接



微信，首次使用微信公众会判断是否是新人，





## 权限盒子项目：

1、每个系统权限管理，他们的核心流程都是差不多的，如果每个后台单独开发一套权限管理系统，不仅很浪费时间和人力，所以权限盒子就是为了解决这个客户问题的，为他们提供了一套通用的权限解决方案。

​      大学的时候写了几个项目，发送每个项目都有权限管理模块，为了解决。

路径：http://139.198.152.148:8810/

   AOP是**在不惊动(改动)原有设计(代码)**的前提下对其功能进行增强。

1. 用户管理
2. 角色管理
3. 菜单管理
4. 权限管理
5. 岗位管理
6. 日志管理   ①操作日志  ②登录日志



## 树形结构：



# 企业做项目流程：

需求分析 => 设计(概要设计、详细设计) ==》技术选型 ==》初始化/引入需要的技术 ==》写Demo ==>写代码（实现业务逻辑） =》测试（单元测试等）`==》`代码评审 ==》部署 ==》发布。



