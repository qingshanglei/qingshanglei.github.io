# [Java SE：](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-1)

### 设计模式的六大原则是什么？分别有什么含义？

软件设计模式（Design pattern，设计模式），使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。 设计模式存在的根本原因是为了更好地复用代码，增加代码可维护性。

1. 单一职责原则：**一个类负责一个功能。**这样，当一个职责需要变化时，只需修改一个类，减少了类之间的耦合度，降低了系统复杂度，便于维护和升级。
2. 里氏替换原则：**一个类能够实现的，其子类也能实现。** 即子类是对父类的完全复制，父类可以被子类完全替代，子类可以增加新的内容，而且不影响父类。
3. 依赖倒转原则： **引用一个对象，如果这个对象有底层类型，直接引用底层类型。** 引用的时候禁止套娃，直接引用最底层的类型。
4. 合并/聚合复 用原则：**尽量用合并关系，避免代码****耦合****。** 使用已经有的东西合成新的东西，使原来的东西成为新东西的一部分。
5. 开闭原则原则：**对扩展开放，对修改关闭。**这个原则是设计模式的重要原则之一，它指导我们在设计软件时要尽量减少对原有代码的修改，提高系统的扩展性和可维护性。即已经发生的已经不可以改变 ，我们只能改变那些事情对现在的影响。
6. 接口隔离原则：**使用多个隔离接口，降低类之间的****耦合度****。** 这个原则可以避免一个类拥有过多的依赖关系，使得软件结构更松散，降低了系统的耦合度，易于维护和升级。

## 其他：

### Java语言有哪些特点:

1. 简单易学、有丰富的类库
2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）
3. 与平台无关性（JVM是Java跨平台使用的根本）
4. 可靠安全
5. 支持多线程

**面向对象和面向过程的区别:**

**面向过程**：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发。**面向对象**：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有**封装****、****继承****、多态**的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。

### 八种基本数据类型的大小，以及他们的封装类：

| **基本类型**     | **大小（字节）** | **默认值**   | **封装****类**  |
| ---------------- | ---------------- | ------------ | --------------- |
| byte(拜踢)       | 1                | (byte)0      | Byte            |
| short(蛇特)      | 2                | (short)0     | Short           |
| int (英特)       | 4                | 0            | Integer(英特具) |
| long (浪)        | 8                | 0L           | Long            |
| ﬂoat (货楼铁)    | 4                | 0.0f         | Float           |
| double (打布)    | 8                | 0.0d         | Double          |
| boolean (布灵儿) | -                | false        | Boolean         |
| char (可)        | 2                | \u0000(null) | Character       |

注：

1.int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个象，否则会报错。 2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。

虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。

### **标识符****的命名规则。**

**标识符****的含义：** 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。**命名规则：（硬性要求）** 标识符可以包含英文字母，0-9的数字，$以及_ 标识符不能以数字开头 标识符不是关键字**命名规范：（非硬性要求）** 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。

### instanceof (阴生是特奥符) 关键字的作用：

instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。

### JDK&JRE&JVM的区别：

JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具（编译、开发工具）和Java核心类库。Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含 JVM标准实现及Java核心类库。 JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。

JDK包含JRE和Java编译、开发工具； JRE包含JVM和Java核心类库； 运行Java仅需要JRE； 而开发Java需要JDK。

### 跨平台：

字节码是在虚拟机上运行的，而不是编译器。换而言之，是因为JVM能跨平台安装，所以相应JAVA字节码便可以跟着在任何平台上运行。只要JVM自身的代码能在相应平台上运行，即JVM可行，则JAVA的程序员就可以不用考虑所写的程序要在哪里运行，反正都是在虚拟机上运行，然后变成相应平台的机器语言，而这个转变并不是程序员应该关心的。

### java 面向对象编程三大特性是什么？

- 面向对象的三个特性：封装；继承；多态
- 封装：将数据与操作数据的方法绑定起来，隐藏实现细节，对外提供接口。
- 继承：代码重用；可扩展性
- 多态：允许不同子类对象对同一消息做出不同响应
- 多态的三个必要条件：继承、方法的重写、父类引用指向子类对象

### ﬁnal(快呢)有哪些用法?

或final 关键字的作用...

1. 被ﬁnal修饰的类不可以被继承。
2. 被ﬁnal修饰的方法不可以被重写，但是可以重载。
3. 被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变。
4. 被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率。
5. 被ﬁnal修饰的常量,在编译阶段会存入常量池中。

### synchronized(星克奶是)的优缺点:

1. 优点：解决了多线程的数据安全问题。
2. 缺点：当线程多的时候，每个线程都会上锁，会耗费很多资源，降低程序的运行效率。

### Volatile(窝了太)和synchronized(星克奶是)有什么区别？

1. synchronized关键字，用来加锁。
2. Volatile只是保持变量的线程可见性。通常适用于一个线程写，多个线程读的场景。

### Volatile能不能保证线程安全？

不能，Volatile关键字只能保证线程可见性，不能保证原子性。

### DCL(Double Check Lock)单例为什么要加Volatile？

Volatile可以防止指令重排。

### **static**(是打体可)都有哪些用法?

静态变量和静态方法，静态内部类，静态块，和静态导包。

1. static关键字这两个基本的用法:静态变量和静态方法，也就是被static所修饰的变量方法都属于类的静态资源,类实例所共享。
2. 除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作。

### ==和equals(忆口是)有什么区别？

**==:** ==运算符在Java中是用于比较基本类型和引用类型的值是否相等。如果用于比较基本类型，它会直接比较变量的值是否相等。如果用于比较引用类型，它会比较变量所指向的对象地址是否相等。

1. 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。
2. 比较的是操作符两端的操作数是否是同一个对象。
3. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。
4. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。

**equals:** equals方法是一个Java对象的方法，用于比较当前对象是否与另一个对象相等。这个方法在Object类中定义，因此所有的Java对象都会继承这个方法。通常，类会重写这个方法以实现它们自己的比较逻辑。重写equals方法时，通常也需要重写hashCode方法以保持一致性。

equals比较的是两个对象的内容是否相等，由于所有的类都是继承自Object类的，因此所有的Java对象都会继承这个方法，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。

因此，和equals的主要区别在于，是一个运算符，用于比较基本类型和引用类型的值是否相等，而equals是一个方法，用于比较两个对象的内容是否相等。

通俗点讲：是看看左右是不是一个东西。

- ==（等于）。
- equals（相同）：equals是看看左右是不是长得一样。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。

1. 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？

### 如果只重写equals(忆口是)不重写hashCode会怎样

或为什么重写了 equals 还要重写 hashcode？

equals() 方法用于判断两个对象是否相等，而 hashCode() 方法返回对象的哈希码值。哈希码是一个整数，通常用于在哈希表中进行快速查找和比较对象。

1. 对象比较不准确：equals方法用于比较两个对象是否相等，但如果两个对象的hashCode不同，那么它们将被视为不相等，即使它们的内容相同。
2. 影响使用集合类的性能：Java中的一些集合类（如HashMap、HashSet）使用hashCode方法来存储和检索对象。如果对象的hashCode没有被正确地重写，会导致集合类将它们视为不同的对象，从而影响集合类的性能。
3. 引起不可预测的行为：如果只重写equals而不重写hashCode，可能会违反Java的Object合同。在Java中，如果两个对象相等（即equals(Object)返回true），那么它们的hashCode必须相同。否则，将可能引起不可预测的行为。

因此，当你重写equals方法时，通常也需要重写hashCode方法，以确保它们的行为一致。如果两个对象相等，那么它们的hashCode必须相同。如果两个对象的hashCode不同，那么它们必须不相等。这样可以确保对象的比较和集合类的性能得到正确的结果。

### Java自动装箱与拆箱

**装箱就是自动将基本数据类型转换为包装器类型**（int-->Integer）；调用方法：Integer的valueOf(int) 方法。

**拆箱就是自动将包装器类型转换为基本数据类型**（Integer-->int）。调用方法：Integer的 intValue方法。

### 重写与重载的区别：

**重写 ：**

1. 发生在父类与子类之间
2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

**重载（Overload）：** 在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。 注意：重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。

### 7、Java 中能创建 volatile 数组吗？

能，Java 中可以创建 volatile 类型数组，但是只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

### 6、列出一些你常见的运行时异常？

1. ArithmeticException（算术异常）
2. ClassCastException （类转换异常）
3. IllegalArgumentException （非法参数异常）
4. IndexOutOfBoundsException （下标越界异常）
5. NullPointerException （空指针异常）
6. SecurityException （安全异常）

### 说说你平时是怎么处理Java 异常的：

try-catch-fifinally

- try 块负责监控可能出现异常的代码
- catch 块负责捕获可能出现的异常，并进行处理
- fifinally 块负责清理各种资源，不管是否出现异常都会执行
- 其中 try 块是必须的，catch 和 finally 至少存在一个标准异常处理流程

### 3*0.1== 0.3返回值是什么：

false,因为有些浮点数不能完全精确的表示出来。

### a=a+b与a+=b有什么区别吗?

+= 操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会进行自动类型转换。

### try catch ﬁnally （材而，区，快呢利），try里有return(利听)，ﬁnally还执行么？

执行，并且ﬁnally的执行早于try里面的return。

结论：

1. 不管有没有出现异常，ﬁnally块中代码都会执行；
2. 当try和catch中有return时，ﬁnally仍然会执行；
3. ﬁnally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管ﬁnally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在ﬁnally执行前确定的；
4. ﬁnally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。

### **OOM**你遇到过哪些情况，**SOF**你遇到过哪些情况？

**OOM**：

OutOfMemoryError(OOM)异常: 除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。

1. Java Heap 溢出：
   1. 一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。
   2. 出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(MemoryLeak)还是内存溢出(Memory Overﬂow)。如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。
2. 虚拟机栈和本地方法栈溢出:

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverﬂowError异常。
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
- 这里需要注意当栈的大小越大可分配的线程数就越少。

1. 运行时常量池溢出:

- 异常信息：java.lang.OutOfMemoryError:PermGenspace
- 如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

1. 方法区溢出:

- 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。
- 异常信息：java.lang.OutOfMemoryError:PermGenspace
- 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。

SOF（堆栈溢出 StackOverﬂow）：

- StackOverﬂowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。
- 因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。
- 栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。

### Java 7 和 Java 8 的区别：

1. lambda 表达式，Java 8 版本引入的一个新特性。lambda 表达式允许你将功能当作方法参数或将代码当作数据。lambda 表达式还能让你以更简洁的方式表示只有一个方法的接口 (称为函数式接口) 的实例。
2. 方法引用，为已命名方法提供了易于阅读的 lambda 表达式。
3. 默认方法，支持将新功能添加到类库中的接口，并确保与基于这些接口的旧版本的代码的二进制兼容性。
4. 重复注解，支持在同一声明或类型上多次应用同一注解类型。
5. 类型注解，支持在任何使用类型的地方应用注解，而不仅限于声明。此特性与可插入型系统一起使用时，可增强对代码的类型检查。

### 深拷贝和浅拷贝区别？

1. 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址。
2. 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

最好是结合克隆原型模式联系在一起哈，把这几个联系起来的。

## 集合：

### Java有哪些集合类型?

或你了解哪些集合类型? 或介绍 Java 的集合类

- ArrayList 底层实现是数组
- LinkedList 底层实现是双向链表
- HashMap 的底层实现使用了众多数据结构，包含了数组、链表、散列表、红黑树等
- ConcurrentHashMap

### 如何实现数组和List之间的转换？

难易程度：☆☆☆

出现频率：☆☆

- 数组转List ，使用JDK中java.util.Arrays工具类的asList方法
- List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组
- 面试官再问：
- 1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗？
-  数组转List受影响， Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址
- 2，List用toArray转数组后，如果修改了List内容，数组受影响吗？
-  List转数组不受影响，list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响

### 3、 String、StringBuﬀer和StringBuilder 的区别是什么?

String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个ﬁnal类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。 StringBuﬀer和StringBuilder他们两都继承了AbstractStringBuilder (鸭死拽可特) 抽象类，他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuﬀer或StringBuilder来进行操作。 另外StringBuﬀer 对方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

### 算法复杂度：

算法复杂度分析：一个是时间复杂度，一个是空间复杂度，通常情况下说复杂度，都是指时间复杂度。

速记口诀：**常对****幂****指阶**

越在上面的性能就越高，越往下性能就越低

**复杂度分析就是要弄清楚代码的执行次数和数据规模n之间的关系。**

常见的时间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到。

#### 时间复杂度：

大O表示法：

 **大O表示法**：不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**。

 公式：T(n) =O(3n + 3)-----大O表示法简化后-----> T(n) = O(n)

 **T(n)与代码的执行次数成正比(代码行数越多，执行时间越长)**

时间复杂度O(1)： **只要代码的执行时间不随着n的增大而增大，这样的代码复杂度都是O(1)。**

时间复杂度O(n)：

时间复杂度O(logn)：

时间复杂度O(n * log n):

##### 空间复杂度：

空间复杂度全称是渐进空间复杂度，表示算法占用的额外**存储空间**与**数据规模**之间的增长关系。

### 4、ArrayList 和 LinkedList 的区别是什么？

1. 底层数据结构
2. ① ArrayListd的底层数据结构是由动态数组。
3. ② LinkList的底层数据结构是一个双链表。
4. 操作数据效率
5. ① ArrayList底层是数组（内存是连续的），查询快，增删慢
6. ② LinkList底层数据结构是链表，查询慢，增删快

- ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询
- 查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)
- 新增和删除
   - ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)
   - LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)

1. 空间：
2. ① ArrayList底层数组，内存连续，节省内存
3. ② LinkList底层数据结构是链表，存储数据的时候，要多存两个指针，更占内存。
4. 线程是否安全： ArrayList 和 LinkList都是线程不安全的。
5. 初始容量 ①ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10
6. 扩容逻辑
7. ①ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组

```Plaintext
添加逻辑
```

- 确保数组已使用长度（size）加1之后足够存下下一个数据
- 计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）
- 确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。
- 返回添加成功布尔值。

**适用场景分析:**

- 当需要对数据进行对随机访问的时候，选用 ArrayList。
- 当需要对数据进行多次增删修时，采用 LinkedList。
- 如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免 ArrayList 的扩容，以及非顺序的插入。

### 如何保证ArrayList 和 LinkList 的线程安全：

1. 在方法内使用，局部遍历则是线程安全。
2. 使用 synchronized关键字,就可以保证多线程的安全性问题。

```Plaintext
List<Object> syncArrayList=Collections.synchroizedList(new ArrayList<>());
   List<Object> syncLinkedList=Collections.synchroizedList(new LinkedList<>());
```

### 5、**HashMap和HashTable的区别：**

1. **发布的版本不同：**Hashtable 是JDK 1.0发布，HashMap 是JDK 1.2发布。
2. **两者****父类****不同**

HashMap是继承自AbstractMap(鸭死拽可特Map)类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制, 扣了保）、Serializable（可序列化,JDK1.8+）这三个接口。

1. **对外提供的接口不同**Hashtable比HashMap多提供了elments() 和contains() 两个方法。 elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。
2. **对null的支持不同** Hashtable：key和value都不能为null，在遇到null键和null值时会抛出空指针异常。 HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。
3. **安全性不同**HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap(看卡了HashMap)。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。
4. **初始容量大小和每次扩充容量大小不同** Hashtable 的初始长度是 11，之后每次扩充容量变为之前的2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。
5. **计算hash值的方法不同**Hashtable 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。 总结：HashMap更适合用于需要高效率的场景，而HashTable则更适合用于需要数据一致性的场景。

注意：Hashtable 是线程安全，推荐使用 HashMap 代替 Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。

### 6、Collection(可辣肾)包结构，与Collections的区别

1. Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack。
2. Collections是集合类的一个帮助类， 它包含各种有关集合操作的静态多态方法，常用于对集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

### 7、Java的四种引用，强弱软虚：

1. 强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收。使用方式：

```Plaintext
String str = new String("str");
 System.out.println(str);
```

1. 软引用：软引用在程序内存不足时，会被回收。
2. 弱引用：弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。
3. 虚引用：虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue 。

### 8、Java创建对象有几种方式？

java中提供了以下四种创建对象的方式:

1. new创建新对象。
2. 通过反射机制。
3. 采用clone机制。
4. 通过序列化机制。

### 11、说说List,Set,Map三者的区别？

1. List(有序集合，序列集合)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象
2. Set: 不允许重复的集合。不会有多个元素引用相同的对象。
3. Map: 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

### 用过 **ArrayList** 吗？说一下它有什么特点？

Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。

底层是使用数组实现，添加元素。如果 add(o)，添加到的是数组的尾部，如果要增加的数据量很大，应该使用 ensureCapacity()方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。如果使用 add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。

ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList 里面的 clone() 复制其实是浅复制。

### set集合特点：

1. ①不包含重复元素的集合
2. ②没有带索引的方法，所以不能使用普通for循环遍历
3. 注意： HashSet 对集合的迭代循环不做任何保证（如果要保证元素唯一性，需要重写hasCede()和equals()）

### HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？

这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下ConcurrentHashMap 数据结构以及底层原理等。

### HashMap：

#### 二叉数：

二叉树，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。注意：二叉树并不要求每个节点都有两个子节点，有的节点只有左/右子节点。 二叉树每个节点的左子树和右子树也分别满足二叉树的定义。 Java中有两个方式实现二叉树：数组存储，链式存储。

在二叉树中，比较常见的二叉树有：

- 满二叉树
- 完全二叉树
- **二叉搜索树**
- **红黑树**
- **二叉搜索树**(Binary Search Tree,BST,二叉查找树,有序二叉树或者排序二叉树)： 是二叉树中比较常用的一种类型。 二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

##### 红黑树：

**红黑树（Red Black Tree）**：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）

红黑树的特质：

1. 节点要么是**红色**,要么是**黑色。**
2. 根节点是**黑色。**
3. 叶子节点都是黑色的空节点。
4. 红黑树中红色节点的子节点都是黑色。
5. 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点。

**在添加或删除****节点****的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡**

红黑树的复杂度

1. 查找：

- 红黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)

1. 添加：

- 添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)
- 添加完成后涉及到复杂度为O(1)的旋转调整操作
- 故整体复杂度为：O(log n)

1. 删除：

- 首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)
- 删除完成后涉及到复杂度为O(1)的旋转调整操作
- 故整体复杂度为：O(log n)

#### 散列表：

在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表。 散列表(Hash Table,哈希表/Hash表)：是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性 例如：假设有100个人参加马拉松，数组的索引不采用1-100的自然数对选手进行编号，而采用 2023ZHBJ001的规则编号，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，必须使用散列函数才可以进行转换。

##### 散列函数和散列冲突

将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue = hash(key)

散列函数的基本要求：

- 散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。
- 如果key1==key2，那么经过hash后得到的哈希值也必相同即：hash(key1) == hash(key2）
- **如果key1 != key2，那么经过hash后得到的****哈希值****也必不相同即：hash(key1) != hash(key2)**。
- 实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突(或者哈希冲突，哈希碰撞，**就是指多个key映射到同一个数组下标位置**)

#### 散列冲突-链表法（拉链）

- 在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。
- 简单的说就是：如果有多个key最终的hash值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据

#### 时间复杂度-散列表

- 1，插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)

#### HashMap中的 **key** 我们可以使用任何类作为 **key** 吗？

- 平时可能大家使用的最多的就是使用 String 作为 HashMap 的 key，但是现在我们想使用某个自定义类作为 HashMap 的 key，那就需要注意以下几点：
   - 如果类重写了 equals 方法，它也应该重写 hashCode 方法。类的所有实例需要遵循与 equals 和 hashCode 相关的规则。
   - 如果一个类没有使用 equals，你不应该在 hashCode 中使用它。
   - 咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。

#### 说一下HashMap的实现原理？

HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树

1. 当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
2. 存储时，如果出现hash值相同的key，此时有两种情况。

- 如果key相同，则覆盖原始值；
- 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中

1. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。

#### HashMap 在 jdk 1.7 和 1.8 的区别？

1. 底层不同：

- 1.7 的底层是数组+ 链表；
- 1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询的效率。

1. 链表插入地方不同：

- 1.7中链表插入使用的是头插入法；
- 1.8中链表插入使用的是尾插入，因为1.8中插入key和value时需要判断链表元素格式，所以需要遍历链表统计表示元素个数，所以正好就直接使用尾插法。

1. 算法不同：

- 1.7中哈希算法比较复杂，存在各种右移与异或运算；
- 1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。
- JDK1.8之前采用的是拉链法。 拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
- jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。

#### **HashMap** 的长度为什么是 2的**N** 次方呢？

为了能让 HashMap 存数据和取数据的效率更高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。

我们首先可能会想到 % 取模的操作来实现。

下面是回答的重点哟：

取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。

这就是为什么 HashMap 的长度需要 2 的 N 次方了。

#### **HashMap**与**ConcurrentHashMap(看卡了HashMap)** 的异同:

1. 都是 key-value 形式的存储数据；
2. HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；
3. HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry，Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。

#### HashMap的put方法的具体流程：

1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）。
2. 根据键值key计算hash值得到数组索引。
3. 判断table[i]==null，条件成立，直接新建节点添加。
4. 如果table[i]==null ,不成立。
5. 4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value。
6. 4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对。
7. 4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value。
8. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。

#### 讲一讲HashMap的扩容机制：

- 在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）
- 每次扩容的时候，都是扩容之前容量的2倍；
- 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中
   - 没有hash冲突的节点，则直接使用 e.hash & (newCap - 1) 计算新数组的索引位置
   - 如果是红黑树，走红黑树的添加
   - 如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash & oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上

#### hashMap的寻址算法：

在putVal方法中，有一个hash(key)方法，这个方法就是来去计算key的hash值的

首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突

有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，看下面的代码：

(n-1)&hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂

#### 为何HashMap的数组长度一定是2的次幂？

1. 计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模
2. 扩容时重新计算索引效率更高： hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap

####  hashmap在1.7情况下的**多线程**循环问题：

在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环。

比如说，现在有两个线程

线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入

线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。

线程一：继续执行的时候就会出现死循环的问题。

线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，

所以B->A->B,形成循环。

当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），**尾插法**，就避免了jdk7中死循环的问题。



# 在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环

### 反射：

Java反射机制:是指在运行时去获取一个类的变量和方法信息。然后通过获取 到的信息来创建对象，调用方法的 一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成 确定，在运行期依然可以扩展

## 线程：

线程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。①是系统进行资源分配和调用的独立单位。②每一个进程都有它自己的内存空间和系统资源。

### 线程的几种可用状态分别是什么？

线程 有5 种状态 ：**新建（new** **Thread****）、就绪（****runnable****），运行（running）、阻塞（blocked）、结束（dead）**。

1. 就绪（Runnable）：线程准备运行，但不一定立即就能开始执行。此时，线程在等待CPU分配时间片。
2. 运行中（Running）：线程正在执行其代码。此时，它已经获取了CPU的时间片，并正在执行相关的操作。
3. 阻塞（Blocked）：这种状态表示线程因为某些原因放弃了CPU的使用权，也即让出了CPU时间片，暂时停止运行。例如，线程可能正在等待某些资源或等待其他线程完成某些操作。
4. 等待中（Waiting）：线程处于阻塞状态，等待外部的处理结束。
5. 睡眠中（Sleeping）：线程被强制睡眠，通常是为了让线程暂时停止执行。
6. I/O阻塞（BlockedonI/O）：线程在等待I/O操作完成时进入此状态。例如，当线程正在等待读取文件或网络数据时，它可能处于I/O阻塞状态。
7. 同步阻塞（BlockedonSynchronization）：线程在等待获取锁时进入此状态。例如，如果一个线程试图进入一个已被其他线程锁定的代码段，那么该线程将进入同步阻塞状态，直到锁被释放。
8. 死亡（Dead）：线程完成了执行，或者因某种原因终止，这时它处于死亡状态。

### 在 Java 程序中怎么保证多线程的运行安全？

出现线程安全问题的原因一般都是三个原因：

1. 线程切换带来的原子性问题。 解决办法：使用多线程之间同步synchronized（星克奶是）或使用锁(lock)。
2. 缓存导致的可见性问题。 解决办法：synchronized（星克奶是）、volatile（窝了太）、LOCK，可以解决可见性问题
3. 编译优化带来的有序性问题。 解决办法：Happens-Before 规则可以解决有序性问题。

### 3.高并发中集合有那些问题:

#### 第一代线程安全集合类

Vector、HashTable是线程安全的：使用synchronized修饰方法。 缺点：加上同步锁之后保证线程安全了但是同时也导致了效率低下。

此方法大多数情况下这种集合类是用不到线程安全的，所以就诞生了线程非安全集合类。

#### 第二代线程非安全集合类

ArrayList、HashMap线程不安全，但是性能好，用来替代Vector、HashTable使用ArrayList，HashMap，需要线程安全时怎么办呢？使用Collections.synchronizedList(list); Collections.synchronizedMap(map);这样，底层使用synchronized代码块锁，虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外面性能可以理解为稍有提高吧，毕竟进方法本身就是要分配资源的。

#### 第三代线程安全集合类

在大量并发情况下如何提高集合的效率和安全呢？java.util.concurrent.*ConcurrentHashMapCopyOnWriteArrayList;CopyOnWriteArraySet;底层大多数采用Lock锁（jdk1.8的ConcurrentHashMap不使用Lock锁），保证线程安全的同时，性能也很高。

### 12、简述线程、程序、进程的基本概念。以及他们之间关系是什么?

进程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。①是系统进行资源分配和调用的独立单位。②每一个进程都有它自己的内存空间和系统资源。

线程分为：并发、串行和并行。

1. 并发：同一时刻多个线程在访问同一个资源，多个线程对一个点。 例子：春运抢票、微信抢红包、电商秒杀...
2. 串行①串行-同步串行：代表多任务按先后顺序执行，并且都是**同一个****线程**来执行。 ②串行-异步串行：代表多任务按先后顺序执行，并由**不同的线程**来执行
3. 并行：多项任务一起执行，之后再汇总例子：泡方便面，电水壶一边烧水，一边撕调料倒入桶中。
4. 任务合并：一个任务的执行依赖于前面多个任务执行的返回值，并且这些任务可以由同一个线程执行，也可以由不同的线程执行；

### 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

1. **线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
2. **程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
3. **进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

### 1、说说Java中实现多线程有几种方法:

创建线程的常用三种方式：

1. 继承Thread(死辣的)类 。
2. 实现Runnable(泸的薄)接口。
3. 实现Callable(扣里薄)接口（ JDK1.5>= ）
4. 线程池方式创建。

通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。

### 2、 采用实现**Runnable**、**Callable**接口的方式创建线程的优缺点

**优点**：线类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。

**缺点**：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法

### [1、什么是ThreadPoolExecutor(线程池)？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#1什么是threadpoolexecutor)

ThreadPoolExecutor**(线程池)**其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）

构造参数参数介绍：

1. corePoolSize 核心线程数量
2. maximumPoolSize 最大线程数量
3. keepAliveTime 线程保持时间，N个时间单位
4. unit 时间单位（比如秒，分）
5. workQueue 阻塞队列
6. threadFactory 线程工厂
7. handler 线程池拒绝策略

### 3、 采用继承**Thread**类的方式创建线程的优缺点：

优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程。

缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。

### 2、如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当run(论的)方法完成后线程终止。
2. 使用stop(死得扑)方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程。

```Plaintext
class MyThread extends Thread {
     volatile boolean stop = false;
     public void run() {
         while (!stop) {
             System.out.println(getName() + " is running");
             try {
                 sleep(1000);
             } catch (InterruptedException e) {
                 System.out.println("week up from blcok...");
                 stop = true; // 在异常处理代码中修改共享变量的状态
             }
         }
         System.out.println(getName() + " is exiting...");
     }
 }
 class InterruptThreadDemo3 {
     public static void main(String[] args) throws InterruptedException {
         MyThread m1 = new MyThread();
         System.out.println("Starting thread...");
         m1.start();
         Thread.sleep(3000);
         System.out.println("Interrupt thread...: " + m1.getName());
         m1.stop = true; // 设置共享变量为true
         m1.interrupt(); // 阻塞时退出阻塞状态
         Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
         System.out.println("Stopping application...");
     }
 }
```

### 3、**notify(no铁快)**和**notifyAll()**有什么区别？

说明： **notify（no铁快）可能会导致****死锁****，而notifyAll则不会。**

### 4、**sleep(死利扑)和wait(为铁)** 有什么区别？

sleep()方法属于Thread(死辣的)类中的。而wait()方法，则是属于Object类中的。

虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。

### 5、**volatile(我了太)****是什么?**可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。
2. 禁止进行指令重排序。

注意： volatile 不是原子性操作。

### 6、什么叫保证部分有序性?

当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

### 6、Thread类中的**start(死大特)** 和 **run()** 方法有什么区别？

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

7、为什么**wait, notify和notifyAll**这些方法不在**thread**类里面？

JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。

8、为什么**wait**和**notify**方法要在同步块中调用？

1. 只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。
2. 如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。
3. 还有一个原因是为了避免wait和notify之间产生竞态条件。

wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。

在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:"特殊状态已经被设置"。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。

9、Java中**interrupted** 和 **isInterruptedd**方法的区别？

interrupted() 和 isInterrupted()的主要区别是前者会中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。

10、Java中**synchronized**和 **ReentrantLock**有什么不同？

相似点：它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.

区别：这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/ﬁnally语句块来完成。

### 11 、有三个线程T1,T2,T3,如何保证顺序执行？

在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。实际上先启动三个线程中哪一个都行， 因为在每个线程的run方法中用join方法限定了三个线程的执行顺序。

### 12、**SynchronizedMap**和**ConcurrentHashMap**有什么区别？

SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModiﬁcationException。

### 13 、什么是线程安全

线程安全就是说多线程访问同一段代码，不会产生不确定的结果。如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

### 6、线程的 sleep()方法和 yield()方法有什么区别？

1. sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
2. 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
3. sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
4. sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

### 7、Java 中能创建 volatile 数组吗？

能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

### 线程安全的几个级别：

（ 1 ）不可变

像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用

（ 2 ）绝对线程安全

不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要 付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，例如CopyOnWriteArrayList、CopyOnWriteArraySet。

（ 3 ）相对线程安全

相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

（ 4 ）线程非安全：ArrayList、LinkedList、HashMap等都是线程非安全的类

### 14 、Thread类中的yield方法有什么作用？

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

### 15 、Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

16 、说一说自己对于 synchronized 关键字的了解

synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。

Java 6 后 Java 官方从 JVM 层面对synchronized 进行了优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

### 17 、说说自己是怎么使用 synchronized 关键字？

1. 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
2. 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
3. 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
4. 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

### 18 、什么是线程安全？Vector是一个线程安全类吗？

1. 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。
2. Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。

### 19 、 volatile关键字的作用？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语

```Plaintext
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对
 其他线程来说是立即可见的。
 禁止进行指令重排序。
 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读
 取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
 volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改
 可见性和原子性。
 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
```

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

### 20 、常用的线程池有哪些？

1. newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2. newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
3. newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
4. newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。
5. newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。

### 21 、简述一下你对线程池的理解

（可以展开说一下线程池如何用、线程池的好处、线程池的启动策略）

合理利用线程池能够带来三个好处。

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 24 、说说进程和线程的区别？

1. 进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。
2. 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以 通信和同步等操作线程比进程更加容易）
3. 线程上下文的切换比进程上下文切换要快很多。
   1. 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。
   2. 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。

### 29 ，线程安全需要保证几个基本特征？

1. 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
2. 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
3. 有序性，是保证线程内串行语义，避免指令重排等。

### 38 、多线程有什么用？

1. 发挥多核CPU的优势
2. 防止阻塞
3. 便于建模

# JVM:

## 技术点汇总：

JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高. 其中内存模型,类加载机制,GC是重点方面.性能调优部分更偏向应用,重点突出实践能力.编译器优化和执行模式部分偏向于理论基础,重点掌握知识点. 需了解 **内存模型**各部分作用,保存哪些数据.**类加载** 双亲委派加载机制,常用加载器分别加载哪种类型的类.**GC**分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景. 性能调优常有JVM优化参数作用,参数调优的依据,常用的JVM分析工具能分析哪些问题以及使用方法.**执行模式**解释/编译/混合模式的优缺点,Java7提供的分层编译技术,JIT即时编译 技术,OSR栈上替换,C1/C2编译器针对的场景,C2针对的是server模式,优化更激进.新技术方面Java10的graal编译器编译器优化javac的编译过程,ast抽象语法树,编译器优化和运行器优化.

## 2 、知识点详解：

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWUyNGRjNmJlYmNmMDJlYjcxZGFiMzA1Y2VkMjRjNjJfczA0Yzk0QmJlTE9yZjNBNGpvamVZWWkwQmFUSUJpaUVfVG9rZW46SGJzbGJ1Y3o3b1NCZ2N4R0xkaWM2UGJKbmxoXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

1 、JVM内存模型：

线程独占:栈,本地方法栈,程序计数器 线程共享:堆,方法区

2 、栈：

又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.

3 、本地方法栈

与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.

4 、程序计数器

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.

5 、堆

JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理

6 、方法区：

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现

7 、JVM 内存可见性

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFlNjUyZDc0Mzc0NGZjYTUxZDA2NjliZjdjOTkxOWZfRDBsYjljcjM2ekVNV1p6WlA4OGNpNXJwdVhCdDQ0S2tfVG9rZW46WXVmQWI5c0k4b2pwaTJ4TzIwN2NBSlZmbkFiXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ0ZGY1YTQ2NzU1ZWExZWJlMjY4OGVmNTA1YTVmNjJfbmN2NlZQUTRnZDY0enZOdWdVY3ZrZXhYS0xqUVhHVlZfVG9rZW46WWl6cWJYQ2pIb3Y5eEd4Y2ZDdGNZQVE3bjBjXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

## 3 、说说类加载与卸载

加载过程

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ5MWIxZGI0Y2I4NWY3MzBiYzY5ZmZjZTZiOTM4MjFfdnFvNUVhemxnZlJFQmhzYlpFWE40THVRUnZIdjFLM0ZfVG9rZW46UnV3cWJqYXNMbzRNdmZ4WFd0MWNTWGxnblViXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

其中**验证,准备,解析**合称链接

**加载**通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.

**验证**确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.

**准备**进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变量,因为final变量在编译时分配.

**解析**将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.

**初始化**主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用时才会初始化.

触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时候,或者某个子类初始化的时候.

Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.

1 、加载机制-双亲委派模式

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=MTMwMDZkYjk3NjA2MTllYTVkM2ZiYmQ3Mjk3NjkyMjlfRzk4YzhDaU5lRGk4NWF5MHN6TkJuSldqVm1rNGZ6SkJfVG9rZW46RXZQWmJvZk9hb05WSzh4TnQ2amNGc3dHbkxjXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.

父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.*

优点:

1. 避免类的重复加载

\2. 避免Java的核心API被篡改

2 、分代回收

分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间.

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=M2EyMTBiMmQxNjNlOTZiNDA1NTUwNDEyZGUwNmZmZjRfUDRLbDJXMXZWekxxWmlNUU1SMDZ3YVNlM3BKWXdPNjJfVG9rZW46TElQSWJtcWRqb1Y4NWN4NW9jR2M2WHpHbndnXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

年轻代->标记-复制 老年代->标记-清除

3 、回收算法

a、G1算法

1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的增量式清理,以保证停顿时间不会过长

其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.

同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间.

年轻代回收: 并行复制采用复制算法,并行收集,会StopTheWorld.

老年代回收: 会对年轻代一并回收

初始标记完成堆root对象的标记,会StopTheWorld. 并发标记 GC线程和应用线程并发执行. 最终标记完成三色标记周期,会StopTheWorld. 复制/清楚会优先对可回收空间加大的区域进行回收

b、ZGC算法

前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间.

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY4ZDk4NDA1OTYyZmEyNDMzMDcyMzdjODIxNGU5NWRfOTREVW1UYTlXYnFwcUJyMDFQQ3JFRDNhMlowZFhVY2pfVG9rZW46SzVsVWJXN0dwb2hBdUx4aVRMeGNzMXRmbjNnXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

- 着色指针
- 读屏障
- 并发处理

```Plaintext
基于region
 内存压缩(整理)
```

roots标记：标记root对象,会StopTheWorld. 并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld. 清除会清理标记为不可用的对象. roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的比例. 并发重定位与并发标记类似.

# Spring:

## 1 、什么是spring?

1. Spring 是个java企业级应用的开源开发框架。
2. Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。
3. Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。

## 2 、你们项目中为什么使用Spring框架？

直接说Spring框架的优点就可以了。

```Plaintext
轻量：Spring 是轻量的，基本的版本大约2MB。
 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
 容器：Spring 包含并管理应用中对象的生命周期和配置。
 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。
```

## 3 、 Autowired和Resource关键字的区别？

@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。

1. @Autowired 根据类型注入。
2. @Resource 默认根据名字注入，其次按照类型搜索。
3. @Autowired@Qualifie("userService")两个结合起来可以根据名字和类型注入

注意：@Resource为Java自带的，@Autowired为Spring框架的。

1. 什么是死锁？死锁产生的条件？
2. 有哪些进程调度算法？
3. 什么是缓冲区溢出？

## MyBatis:

## #{}和${}的区别是什么？

1. \#{}是预编译处理，${}是字符串替换。
2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理替换成变量的值。
3. 使用#{}可以有效的防止SQL注入，提高系统安全性。

## 4 、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

1. 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。
2. 通过来映射字段名和实体类属性名的一一对应的关系。

# [MQ:](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-11)

死信：无法被消费的消息。

应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。

消息成为死信的三种情况:

- 消息 TTL(Time To Live/存活时间) 过期
- 队列达到最大长度(队列满了，无法再添加数据到 MQ 中)
- 消息被拒绝消费消息，(basic.reject 或 basic.nack) 并且不把消息重新放入原模板队列， requeue = false。

## 1 、为什么要使用MQ

核心：解耦,异步,削峰

1 ）解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。

（ 2 ）异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 +450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。

（ 3 ）削峰：减少高峰时期对服务器压力。

## 2 、MQ有什么优缺点

- 优点：应用解耦 、异步提速 、削峰填谷。
- 缺点：系统可用性降低 、系统复杂度提高、 一致性问题

系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩溃，你不就完了？系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？问题一大堆。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。

## 6 、如何保证消息的顺序性

顺序错乱的场景：RabbitMQ：一个 queue，多个 consumer，这不明显乱了；

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ0YzliYmYzOTY0MTI0Nzg3N2I1MWQ5YzI2YzAxODNfelA5QXNZekJIUVR0a2Z6bXZWRG9WamZKOFBSeU1paHFfVG9rZW46TG5Gc2J1QW9rb3JCQlZ4cDk1T2NvNE4wbnZoXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

解决：

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=ODc5N2IzMDQwZDA5MmVkYTEzMmU1YjE4NDEzMGFjYzZfSjdjSWFtRE1EeHYxSmRHSzRycmFIQkZaUjk5cjZvS3JfVG9rZW46RUh2UWJXcWRMb2FkN2p4RmFONGNhUUVBbnVlXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

## 7 、 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

消息积压处理办法：临时紧急扩容：

先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。

mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。

## 8 、让你来设计一个消息队列，你会怎么设计

比如说这个消息队列系统，我们从以下几个角度来考虑一下：

首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？

其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。

其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -> leader & follower -> broker 挂了重新选举 leader 即可对外服务。能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。

## 延迟队列：

延迟队列(死信队列+TTL)：设置TTL在延迟多久之后消息成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。

注意：延迟队列基于死信队列。队列内部是有序的。延时队列就是用来存放需要在指定时间被处理的 元素的队列；需要在某个事件发生之后或者之前的指定时间点完成某一项任务。

使用场景：

1. 订单在十分钟之内未支付则自动取消。
2. 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。
3. 用户注册成功后，如果三天内没有登陆则进行短信提醒。
4. 用户发起退款，如果三天内没有得到处理则通知相关运营人员。
5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。
6. 使用消息队列有哪些优缺点？
7. 如何保证消息消费的幂等性？
8. 消息队列有哪些路由模型？
9. 你是否用过消息队列，解决过什么问题？

是，

# Redis:

注意：主要减少mysql数据库的操作，及IO操作。

## NoSQL特点：

1. **易扩展**：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，易扩展。在架构的层面上带来了可扩展的能力。
2. **大数据量高性能**：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。 这得益于它的无关系性，数据库的结构简单。 一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。 而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。
3. **多样灵活的数据模型**：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。

## 怎么解决Redis和mysql数据不一致问题：

注意：只有是分布式中，数据的同步都是有延迟的，短暂的延迟一般也是可以接收的。但最终都是要数据一致的。

1. 先更新数据库，再更新缓存。
2. 先删除缓存，再更新数据库。 注意：1和2数据库还是不一致。
3. 先删除缓存，再更新数据库，再删除缓存（缓存延时双删 （缺点：会造成服务器的阻塞，不适合高并发。）
4. CANAL+MQ实现最终一致性。

## 字符串(String):

- string是redis最基本的类型，一个key对应一个value。
- string类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象 。
- string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。
- 特点：单值单Value。 例： UserLoginVo <user:login:, 1>
- redisTemplate.opsForValue().set("order:repeat:" + 1 ，1)

使用场景：

1. 比如抖音无限点赞某个视频或者商品，点一下加一次
2. 是否喜欢的文章

## 列表(List):

Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）它的底层实际是个双端链表，最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的结点性能会较差。

- 特点:单键多值, 值可重复。 ===>
- 使用场景：微信公众号订阅消息。

## 哈希(Hash):

Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）

使用场景：JD早期购物车(目前不再采用)，当前小中厂可用

1. 新增商品 → hset shopcar:uid1024 334488 1
2. 新增商品 → hset shopcar:uid1024 334477 1
3. 增加商品数量 → hincrby shopcar:uid1024 334477 1
4. 商品总数 → hlen shopcar:uid1024
5. 全部选择 → hgetall shopcar:uid1024

## 集合(Set):

- Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。
- Redis 中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。
- 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)
- 特点：单值多value，且无重复，可快速查找、添加、删除
- 例： set k1 v1 v2 v3 ===>使用场景：

1. 微信抽奖小程序。

| **1 用户ID，立即参与按钮**                | **sadd key 用户ID**                                          |
| ----------------------------------------- | ------------------------------------------------------------ |
| 2 显示已经有多少人参与了，上图23208人参加 | SCARD key                                                    |
| 3 抽奖(从set中任意选取N个中奖人)          | SRANDMEMBER key 2 随机抽奖2个人，元素不删除SPOP key 3 随机抽奖3个人，元素会删除 |

## 有序集合(ZSet):

- set(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
- 不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。
- zset的成员是唯一的,但分数(score)却可以重复。
- zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1
- 例： zset k1 score1 v1 score2 v2 ===> Map<String,<String,User>>
- 使用场景：根据商品销售对商品进行排序显示。思路：定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。

## 地理空间(GEO) 3.2+:

- Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括添加地理位置的坐标。获取地理位置的坐标。计算两个位置之间的距离。根据用户给定的经纬度坐标来获取指定范围内的地理位置集合 地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。

问题：

1. 查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的
2. 这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。
3. 精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差注意： 核心思想就是将球体转换为平面，区块转换为一点。

## 基数统计(HyperLogLog) 2.8.9+:

- HyperLogLog 是用来去重复统计功能的基数估计算法。
- 优点：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。
- 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。
- 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。基数： 是一种数据集，去重复后的真实个数。

使用场景：

1. 美团地图附近位置的酒店推送
2. 高德地图附近位置的核酸检查点

## redis位图(bitmap):

原理：由0和1状态表现的二进制位的bit数组。 说明：用String类型作为底层数据结构实现的一种统计二值状态的数据类型 位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们称之为一个索引)。 Bitmap支持的最大位数是232位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(232 = 4294967296)

![img](https://nv40mww2spa.feishu.cn/space/api/box/stream/download/asynccode/?code=ODJjZWI4YWIwNGJhOTI2MzI2ZjhkOGFkZWFlNmJhZGFfSWhzYXVsMGtTaklSdjBjRGdqb1NJOXl6YjlpME1UTVlfVG9rZW46WDNYb2JOT0FCb2RYZXR4dTlTV2NZUjNhbm5JXzE3MDYxMTIwNjk6MTcwNjExNTY2OV9WNA)

使用场景：

1. 统计某个网站的UV、统计某个文章的UV(Unique Visitor，独立访客，一般理解为客户端IP,需要去重考虑)
2. 用户搜索网站关键词的数量
3. 统计用户每天搜索不同词条个数
4. 天猫网站首页亿级UV的Redis统计方案

# [Nginx](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-12)

## Nginx 有哪些作用？

*Nginx* (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 ①Nginx服务器的最佳用法是在网络上部署动态HTTP内容（部署网站） ②通过Tomcat部署网站搭集群（负载均衡器）。

## Nginx 有哪些负载均衡策略？

1. 轮询（Round Robin,默认）：每个请求会按时间的顺序逐一分配到不同的后端服务器。在轮询中，如果某一个后端服务器down掉了，nginx会自动剔除该服务器。此策略适合每个后端服务器的配置相当的情况，无状态且短平快的服务使用。
2. 权重（Weight）：在轮询策略的基础上指定轮询的几率。此策略可以与least_conn和ip_hash结合使用。此策略比较适合服务器的硬件配置差别比较大的情况。通过直接配置weight来设置访问机率，weight的大小和访问比率成正比。
3. IP哈希（IP Hash）：指定负载均衡器按照基于客户端IP的分配方式。此策略适合有状态服务，比如session。
4. 最少连接数（Least Connections）：把请求转发给连接数最少的后端服务器。此负载均衡策略适合请求处理的时间长短不一，而造成服务器过载的情况。

## 请解释代理中的正向代理和反向代理

正向代理和反向代理都是代理服务器的一种，它们在客户端和真实服务器之间运作，帮助客户端与服务器之间的通信。正向代理帮助客户端访问其无法直接访问的服务器资源，而反向代理帮助服务器处理负载均衡和安全防护等问题。 正向代理，位于客户端和目标服务器之间，帮助客户端访问其无法直接访问的服务器资源。正向代理通常需要客户端进行一些特殊的设置，比如指定代理服务器IP或域名。一旦设置完毕，客户端就可以通过正向代理访问目标服务器。这种机制最常见的应用场景是为防火墙内的局域网客户端提供访问服务器的途径。另外，正向代理也可以被用来提高网络访问速度，通过代理服务器缓存常用内容，减少网络利用率。

反向代理，同样位于客户端和真实服务器之间，但它是服务器的代理，帮助服务器处理负载均衡和安全防护等问题。反向代理通常由服务器端架设，比如在服务器集群中部署一个反向代理服务器。它接收到客户端的请求后，会将请求转发给目标服务器，然后将从目标服务器获得的响应返回给客户端。因此，从客户端角度来看，它是在与一个代理服务器进行交互，但实际上是在访问目标服务器。这种机制最常见的应用场景是提供负载均衡和安全防护。

# [Spring Cloud](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-14)

1. 什么是微服务，有哪些优缺点？ ①微服务是一种框架模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。②每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常基于HTTP协议的RESTful API）。
2. 什么是注册中心，能解决什么问题？注册中心是微服务架构中的关键组件，能够实现服务的动态发现、负载均衡、故障转移等功能，帮助构建高可用、可伸缩的分布式系统。
3. 22、如何提高系统的并发能力？使用分布式系统。部署多台服务器，并做负载均衡。使用缓存（Redis）集群。数据库分库分表 + 读写分离。引入消息中间件集群。

Nacos、OpenFeign、Gateway、Sentinel、Steata

# [SQL](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-5)

1. MySQL 索引的最左原则
2. InnoDB 和 MyIsam 引擎的区别？
3. 有哪些优化数据库性能的方法？
4. 如何定位慢查询？
5. MySQL 支持行锁还是表锁？分别有哪些优缺点？

## JDBC访问数据库的步骤是哪些？

1. 加载一个Driver驱动（通常由数据库提供商提供，例如MySQL的驱动是com.mysql.jdbc.Driver）。
2. 创建数据库连接（Connection）通过调用DriverManager的getConnection方法，并传递数据库的连接串，用户名，密码来创建数据库连接。
3. 创建SQL命令发送器（Statement），可以通过Connection对象的createStatement方法来创建。
4. 通过Statement对象发送SQL命令并得到结果，可以通过Statement对象的executeQuery或executeUpdate方法发送SQL命令，并通过ResultSet对象得到查询结果或更新结果。
5. 处理结果（select语句），对于查询语句，通过ResultSet对象获取查询结果并进行处理。
6. 关闭数据库资源，包括关闭ResultSet、Statement、Connection对象，释放数据库资源。

# 项目：

大学生没实习哪来的项目经验： 项目是学校老师接单，给我们这些人练手的。 项目通用流程：用户登录、注册，忘记密码、修改密码。

## 其他：

### 项目中遇到过什么重要的bug。

当时项目连接Redis的时候,正确的Redis密码0123456 写在yml文件写对了项目中却怎么也连接不上。然后我当时就去Redis查看密码，密码正确，Linux系统使用这个密码的时候也可以连接的上，Java项目中怎么也连接不上，最后，我就去Linux改了下Redis的密码，然后发送项目中居然能用Redis连接了。然后，我就试着查看产出这个bug的么原因了，去把Redis把密码改会0123456，发现Springboot还是整合报错，而Redis还是可以正常登录使用，最后去官网查看文档才发现 yml文件 零开头的 int 类型会自动装换位8进制。

### 项目中怎么返回数据给前端：

或Mvvc框架

我在项目中定义了一个统一返回结果类(泛型类)，把状态码、返回状态信息、数据返回给前端。 如果觉得每次都写状态码、状态信息的话、就把状态码、状态信息都写进一个枚举类里面，返回数据的时候就把枚举类调用一下就行了。

注册：

用户注册传递

## 树形结构：

首先，我们需要明确树形结构数据的定义，它是一种非线性的数据结构，其中每个节点可以具有多个子节点。 在Java中，我们可以使用类和对象的概念来模拟树形结构。 一种常见的方法是创建一个树节点的类，该类具有节点的属性和子节点的列表。 我们可以使用递归算法来构建树形结构。例如: 有一个包含所有节点的列表，并且每个节点都有一个父节点的ID。

1. 创建一个包含所有节点的列表。
2. 迭代列表中的每个节点，将其添加到其父节点的子节点列表中。如果该节点没有父节点（即它是根节点），则将其添加到一个新的列表中。
3. 对于每个节点的子节点列表，递归执行步骤2，直到没有更多的子节点。
4. 返回根节点列表。