# 备战。。。

写在面试开头。。。。
前三次面试，当走过场，过了最好，记住此时的心态；投了100多份简历还没人理,心态有点崩溃的说。

2023-9-13： 心态没摆正，面试八股文都没准备，之前的白跑了。
工作二则： ①说，②做。
  说：1、简历。  2、面试 ①八股文30% ②项目经验70%。
  做： 工作。

    找工作前：背八股文。     入职后：通宵实战写代码。

面试分类：

1. 校招：相对简单。
2. 社招：跟全国人竞技。。。

简历好坏区别：

1. 好：你遛狗。
2. 坏：狗遛你。



面试：

1. Java集成一定要扎实，
2. JUC一定要学通透，
3. 其他内容，就围摇简历上的技术，学60%,剩下全靠背面试题
4.  Redis 5大基本类型练明白了，其他的一背面试题。
5.   MQ基本交换机模型、生成、消费、死信队列、敲明白，其他的背面试题
6. JVM纯纯背面试题（内存模式、垃圾回收算法、堆区内存调整策略、垃圾回收器、各种分代算法区别、垃圾回收器其他特征）
7. 其他东西，就围腰面试题背
8. 项目

换个方法：直接在boos上问公司地址，直接去面试。

实习期不给工资，不签合同都是违法的：可直接去劳动局仲裁公司。

  笔试或机试在以下网站刷题等：在牛客网、GitHub、力扣网

我在学校学生只于还

面试：零经验从1~3到吹，`1~3`工作经验的冲着5年吹，5年冲者10年吹。



## 手上是否有offer:

   手里有offer吗，必须有两个，一个在天河建中路(1个半小时)，一个海珠区，目前一个工资5000，一个7500。一个考虑，那



## 进工厂：

​     20或25块一个小时，每天上10小时，一天就200块了，一个月最迟吗有6,000块，还包吃、保住。去工厂不香吗，就因为这个工作前景更好？



## 为什么没有参加学校的校招：





## 是否参加了实习，为什么从那个公司

   那个参加实习公司，工作时间，项目干了什么。







# [Java SE：](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-1)



## 其他：



### JDK&JRE&JVM的区别：

​    JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具（编译、开发工具）和Java核心类库。
Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含      JVM标准实现及Java核心类库。
​    JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。

   JDK包含JRE和Java编译、开发工具；
   JRE包含JVM和Java核心类库；
   运行Java仅需要JRE； 而开发Java需要JDK。

### 跨平台：

   字节码是在虚拟机上运行的，而不是编译器。换而言之，是因为JVM能跨平台安装，所以相应JAVA字节码便可以跟着在任何平台上运行。只要JVM自身的代码能在相应平台上运行，即JVM可行，则JAVA的程序员就可以不用考虑所写的程序要在哪里运行，反正都是在虚拟机上运行，然后变成相应平台的机器语言，而这个转变并不是程序员应该关心的。



### java 面向对象编程三大特性是什么？

- 面向对象的三个特性：封装；继承；多态
- 封装：将数据与操作数据的方法绑定起来，隐藏实现细节，对外提供接口。
- 继承：代码重用；可扩展性
- 多态：允许不同子类对象对同一消息做出不同响应

- 多态的三个必要条件：继承、方法的重写、父类引用指向子类对象



### 1、ﬁnal(快呢)有哪些用法?

或final 关键字的作用...

1. 被ﬁnal修饰的类不可以被继承。

2. 被ﬁnal修饰的方法不可以被重写，但是可以重载。

3. 被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变。

4. 被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率。

5. 被ﬁnal修饰的常量,在编译阶段会存入常量池中。

   

### 2、 synchronized(星克奶是)的优缺点:

1. 优点：解决了多线程的数据安全问题。
2. 缺点：当线程多的时候，每个线程都会上锁，会耗费很多资源，降低程序的运行效率。



### Volatile(窝了)和synchronized有什么区别？

1. synchronized关键字，用来加锁。
2. Volatile只是保持变量的线程可见性。通常适用于一个线程写，多个线程读的场景。



### Volatile能不能保证线程安全？

   不能，Volatile关键字只能保证线程可见性，不能保证原子性。



### DCL(Double Check Lock)单例为什么要加Volatile？

   Volatile可以防止指令重排。



### 3、**static**(是打体可)都有哪些用法?

   静态变量和静态方法，静态内部类，静态块，和静态导包。

1. static关键字这两个基本的用法:静态变量和静态方法，也就是被static所修饰的变量方法都属于类的静态资源,类实例所共享。
2. 除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作。



### ==和equals(忆口是)有什么区别？

   **==**： 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。

1.   比较的是操作符两端的操作数是否是同一个对象。
2.   两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。
3.   比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。

**equals**：

   equals比较的是两个对象的内容是否相等，由于所有的类都是继承自Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。



通俗点讲：是看看左右是不是一个东西。

-   ==（等于）。
- equals（相同）：equals是看看左右是不是长得一样。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。

## 如果重写equals不重写hashCode会怎样

- 两个值不同的对象的hashCode一定不一样，那么执行equals，结果为true，HashSet或HashMap的键会放入值相同的对象。



### Java自动装箱与拆箱

**装箱就是自动将基本数据类型转换为包装器类型**（int-->Integer）；调用方法：Integer的valueOf(int) 方法。

**拆箱就是自动将包装器类型转换为基本数据类型**（Integer-->int）。调用方法：Integer的 intValue方法。



### 重写与重载的区别：

**重写 ：** 

1. 发生在父类与子类之间
2.  方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private) 
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

**重载（Overload）：**
   在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。
     注意：重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。

### 7、Java 中能创建 volatile 数组吗？

   能，Java 中可以创建 volatile 类型数组，但是只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。



### 6、列出一些你常见的运行时异常？

1.  ArithmeticException（算术异常）
2.  ClassCastException （类转换异常）
3.  IllegalArgumentException （非法参数异常）
4.  IndexOutOfBoundsException （下标越界异常）
5.  NullPointerException （空指针异常）
6.  SecurityException （安全异常）



## 集合：



![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/Java%20SE/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png)



### 2、 HashMap 在 jdk 1.7 和 1.8 的区别？

1.    1.7 的底层是数组+ 链表；      1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询的效率。
2.  1.7中链表插入使用的是头插入法；      1.8中链表插入使用的是尾插入，因为1.8中插入key和value时需要判断链表元素格式，所以需要遍历链表统计表示元素个数，所以正好就直接使用尾插法。
3.  1.7中哈希算法比较复杂，存在各种右移与异或运算；     1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。



### 3、 String、StringBuﬀer和StringBuilder 的区别是什么?

​    String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个ﬁnal类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。
   StringBuﬀer和StringBuilder他们两都继承了AbstractStringBuilder (鸭死拽可特) 抽象类，从AbstractStringBuilder抽象类中我们可以看到,他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuﬀer和StringBuilder来进行操作。 另外StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

### 4、ArrayList 和 LinkedList 的区别是什么？

1.  底层数据结构
   ① ArrayList是动态数组的数据结构
   ② LinkList是一个双链表的数据结构 
2.  操作数据效率
   ① ArrayList底层是数组，查询快，增删慢
   ② LinkList底层数据结构是链表，查询慢，增删快 
3.  空间
   ① ArrayList底层数组，内存连续，节省内存
   ② LinkList底层数据结构是链表，存储数据的时候，要多存两个指针，更占内存。 
4.  线程是否安全： ArrayList 和 LinkList都是线程不安全的。

**适用场景分析:**

- 当需要对数据进行对随机访问的时候，选用 ArrayList。
- 当需要对数据进行多次增删修时，采用 LinkedList。
- 如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免 ArrayList 的扩容，以及非顺序的插入。



### 如何保证ArrayList和 LinkList的线程安全：

1. 在方法内使用，局部遍历则是线程安全。
2. 使用 synchronized关键字。

```java
  List<Object> syncArrayList=Collections.synchroizedList(new ArrayList<>());
  List<Object> syncLinkedList=Collections.synchroizedList(new LinkedList<>());
```



### 5、**HashMap和HashTable的区别：**

   1. **发布的版本不同：** 

       Hashtable 是JDK 1.0发布，HashMap 是JDK 1.2发布。 

2. **两者父类不同**

​    HashMap是继承自AbstractMap(鸭死拽可特Map)类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制, 扣了保）、Serializable（可序列化,JDK1.8+）这三个接口。 

3. **对外提供的接口不同**
   Hashtable比HashMap多提供了elments() 和contains() 两个方法。 elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。
   contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。 
 4.  **对null的支持不同**
      Hashtable：key和value都不能为null。
      HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。 
  5.  **安全性不同**
      HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。
      Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。
      虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap(看卡了HashMap)。
      ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。 
   4.  **初始容量大小和每次扩充容量大小不同**
          Hashtable 的初始长度是 11，之后每次扩充容量变为之前的2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。 
   5.  **计算hash值的方法不同**
      Hashtable 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。 

   注意：Hashtable 是线程安全，推荐使用 HashMap 代替 Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。



### 6、Collection(可辣肾)包结构，与Collections的区别

1. Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack。
2. Collections是集合类的一个帮助类， 它包含各种有关集合操作的静态多态方法，常用于对集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

### 7、Java的四种引用，强弱软虚：

1.  强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收。使用方式： 

```java
String str = new String("str");
System.out.println(str);
```

1.  软引用：软引用在程序内存不足时，会被回收。 
2.  弱引用：弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。 
3.  虚引用：虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue 。 

### 8、Java创建对象有几种方式？

java中提供了以下四种创建对象的方式:

1. new创建新对象。
2. 通过反射机制。
3. 采用clone机制。
4. 通过序列化机制。

### 11、说说List,Set,Map三者的区别？

1. List(有序集合，序列集合)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象
2. Set:  不允许重复的集合。不会有多个元素引用相同的对象。
3. Map:  使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

### 用过 **ArrayList** 吗？说一下它有什么特点？

Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。

底层是使用数组实现，添加元素。如果 add(o)，添加到的是数组的尾部，如果要增加的数据量很大，应该使用 ensureCapacity()方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。如果使用 add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。

ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList 里面的 clone() 复制其实是浅复制。



### HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？

这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下ConcurrentHashMap 数据结构以及底层原理等。

### HashMap中的 **key** 我们可以使用任何类作为 **key** 吗？

平时可能大家使用的最多的就是使用 String 作为 HashMap 的 key，但是现在我们想使用某个自定义类作为 HashMap 的 key，那就需要注意以下几点：

1. 如果类重写了 equals 方法，它也应该重写 hashCode 方法。类的所有实例需要遵循与 equals 和 hashCode 相关的规则。
2. 如果一个类没有使用 equals，你不应该在 hashCode 中使用它。
3. 咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。



### **HashMap** 的长度为什么是 **2** **的** **N** 次方呢？

为了能让 HashMap 存数据和取数据的效率更高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。

我们首先可能会想到 % 取模的操作来实现。

下面是回答的重点哟：

```plain
取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。
```

这就是为什么 HashMap 的长度需要 2 的 N 次方了。



### **HashMap** **与** **ConcurrentHashMap(看卡了HashMap)** 的异同:

1. 都是 key-value 形式的存储数据；
2. HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；
3. HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry，Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。



### set集合特点：

1. ①不包含重复元素的集合
2. ②没有带索引的方法，所以不能使用普通for循环遍历
3. 注意： HashSet 对集合的迭代循环不做任何保证（如果要保证元素唯一性，需要重写hasCede()和equals()）



### 反射：

Java反射机制:是指在运行时去获取一个类的变量和方法信息。然后通过获取 到的信息来创建对象，调用方法的 一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成 确定，在运行期依然可以扩展

## 线程：

线程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。
①是系统进行资源分配和调用的独立单位。
②每一个进程都有它自己的内存空间和系统资源。

### [2、在 Java 程序中怎么保证多线程的运行安全？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#2在-java-程序中怎么保证多线程的运行安全)  


出现线程安全问题的原因一般都是三个原因：

1.  线程切换带来的原子性问题。   解决办法：使用多线程之间同步synchronized或使用锁(lock)。
2.  缓存导致的可见性问题。    解决办法：synchronized、volatile、LOCK，可以解决可见性问题

3. 编译优化带来的有序性问题。   解决办法：Happens-Before 规则可以解决有序性问题



### 3.高并发中集合有那些问题:

#### 第一代线程安全集合类

Vector、HashTable
是线程安全的：使用synchronized修饰方法。
缺点：加上同步锁之后保证线程安全了但是同时也导致了效率低下

后来，jdk的作者发现其实大多数情况下这种集合类是用不到线程安全的，所以就诞生了线程非安全集合类

#### 第二代线程非安全集合类

ArrayList、HashMap
线程不安全，但是性能好，用来替代Vector、HashTable
使用ArrayList，HashMap，需要线程安全时怎么办呢？
使用Collections.synchronizedList(list); Collections.synchronizedMap(map);
这样，底层使用synchronized代码块锁，虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外面性能可以理解为稍有提高吧，毕竟进方法本身就是要分配资源的。

#### 第三代线程安全集合类

在大量并发情况下如何提高集合的效率和安全呢？
java.util.concurrent.*
ConcurrentHashMap
CopyOnWriteArrayList;
CopyOnWriteArraySet;
底层大多数采用Lock锁（jdk1.8的ConcurrentHashMap不使用Lock锁），保证线程安全的同时，性能也很高。





### 12、简述线程、程序、进程的基本概念。以及他们之间关系是什么?

进程：是正在运行的程序；进程既是基本的分配单元，也是基本的执行单元。
①是系统进行资源分配和调用的独立单位。
②每一个进程都有它自己的内存空间和系统资源。

   线程分为：并发、串行和并行。

1.  并发：同一时刻多个线程在访问同一个资源，多个线程对一个点。
         例子：春运抢票、微信抢红包、电商秒杀... 
2.  串行
   ①串行-同步串行：代表多任务按先后顺序执行，并且都是**同一个线程**来执行。
      ②串行-异步串行：代表多任务按先后顺序执行，并由**不同的线程**来执行 
3.  并行：多项任务一起执行，之后再汇总
   例子：泡方便面，电水壶一边烧水，一边撕调料倒入桶中。 
4.  任务合并：一个任务的执行依赖于前面多个任务执行的返回值，并且这些任务可以由同一个线程执行，也可以由不同的线程执行； 



### 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

1. **线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
2. **程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
3. **进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。



### 1、说说Java中实现多线程有几种方法:

创建线程的常用三种方式：

1.  继承Thread(死辣的)类 。 
2.  实现Runnable(泸的薄)接口。 
3.  实现Callable(扣里薄)接口（ JDK1.5>= ） 
4.  线程池方式创建。 

通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。



### 2、  采用实现**Runnable**、**Callable**接口的方式创建线程的优缺点

   **优点**：线类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。

**缺点**：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法

### [1、什么是ThreadPoolExecutor(线程池)？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#1什么是threadpoolexecutor)

ThreadPoolExecutor**(线程池)**其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）

构造参数参数介绍：

```
corePoolSize 核心线程数量
maximumPoolSize 最大线程数量
keepAliveTime 线程保持时间，N个时间单位
unit 时间单位（比如秒，分）
workQueue 阻塞队列
threadFactory 线程工厂
handler 线程池拒绝策略
```





### 3、 采用继承**Thread**类的方式创建线程的优缺点：

   优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程

缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。



### 2、如何停止一个正在运行的线程

1.  使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 
2.  使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。 
3.  使用interrupt方法中断线程。 

```java
class MyThread extends Thread {
    volatile boolean stop = false;
    public void run() {
        while (!stop) {
            System.out.println(getName() + " is running");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("week up from blcok...");
                stop = true; // 在异常处理代码中修改共享变量的状态
            }
        }
        System.out.println(getName() + " is exiting...");
    }
}
class InterruptThreadDemo3 {
    public static void main(String[] args) throws InterruptedException {
        MyThread m1 = new MyThread();
        System.out.println("Starting thread...");
        m1.start();
        Thread.sleep(3000);
        System.out.println("Interrupt thread...: " + m1.getName());
        m1.stop = true; // 设置共享变量为true
        m1.interrupt(); // 阻塞时退出阻塞状态
        Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
        System.out.println("Stopping application...");
    }
}
```

 



### 3、**notify()**和**notifyAll()**有什么区别？

说明：  **notify（no铁快）可能会导致死锁，而notifyAll则不会。**

### 4、**sleep()**和**wait()** 有什么区别？

   sleep()方法属于Thread(死辣的)类中的。而wait()方法，则是属于Object类中的。

  虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。



### 5、**volatile** **是什么?**可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。
2. 禁止进行指令重排序。

volatile 不是原子性操作



### 6、什么叫保证部分有序性?

   当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

### 6、Thread类中的**start()** 和 **run()** 方法有什么区别？

   start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。



7、为什么**wait, notify** **和** **notifyAll**这些方法不在**thread**类里面？

   JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。



8、为什么**wait**和**notify**方法要在同步块中调用？

1. 只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。
2. 如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。
3. 还有一个原因是为了避免wait和notify之间产生竞态条件。



wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。



在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:"特殊状态已经被设置"。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。

9、Java中**interrupted** 和 **isInterruptedd**方法的区别？

interrupted() 和 isInterrupted()的主要区别是前者会中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。



10、Java中**synchronized**和 **ReentrantLock**有什么不同？

相似点：它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.



区别：这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/ﬁnally语句块来完成。



### 11 、有三个线程T1,T2,T3,如何保证顺序执行？

在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一
个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调
用T2，T2调用T1)，这样T1就会先完成而T3最后完成。实际上先启动三个线程中哪一个都行， 因为在每个线程的run方法中用join方法限定了三个线程的
执行顺序。



### 12、**SynchronizedMap**和**ConcurrentHashMap**有什么区别？



SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModiﬁcationException。



### 13 、什么是线程安全

线程安全就是说多线程访问同一段代码，不会产生不确定的结果。
如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

### 6、线程的 sleep()方法和 yield()方法有什么区别？

1.  sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
2.  线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
3. sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
4. sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

### 7、Java 中能创建 volatile 数组吗？


能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。



### 线程安全的几个级别：

（ 1 ）不可变

   像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用



（ 2 ）绝对线程安全

不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要 付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，例如CopyOnWriteArrayList、CopyOnWriteArraySet。



（ 3 ）相对线程安全

相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

（ 4 ）线程非安全：ArrayList、LinkedList、HashMap等都是线程非安全的类



### 14 、Thread类中的yield方法有什么作用？

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可
能在进入到暂停状态后马上又被执行。



### 15 、Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些
方法。



16 、说一说自己对于 synchronized 关键字的了解

   synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。

Java 6 后 Java 官方从 JVM 层面对synchronized 进行了优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优
化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。



### 17 、说说自己是怎么使用 synchronized 关键字？

1. 修饰实例方法:  作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
2. 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
3. 修饰代码块:  指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
4. 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！



### 18 、什么是线程安全？Vector是一个线程安全类吗？

1. 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。
2. Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。



### 19 、 volatile关键字的作用？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语

```plain
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对
其他线程来说是立即可见的。
禁止进行指令重排序。
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读
取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改
可见性和原子性。
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
```

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



### 20 、常用的线程池有哪些？

1. newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2. newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
3. newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
4. newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行
   任务的需求。
5. newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任
   务的需求。



### 21 、简述一下你对线程池的理解

（可以展开说一下线程池如何用、线程池的好处、线程池的启动策略）

合理利用线程池能够带来三个好处。

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



### 24 、说说进程和线程的区别？

1. 进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。
2. 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以 通信和同步等操作线程比进程更加容易）
3. 线程上下文的切换比进程上下文切换要快很多。 

   - 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。
   - 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。



### 29 ，线程安全需要保证几个基本特征？

1. 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
2. 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
3. 有序性，是保证线程内串行语义，避免指令重排等。



### 38 、多线程有什么用？

1. 发挥多核CPU的优势
2. 防止阻塞
3. 便于建模

# JVM:
## 技术点汇总：

  JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高.
  其中内存模型,类加载机制,GC是重点方面.性能调优部分更偏向应用,重点突出实践能力.编译器优化和执行模式部分偏向于理论基础,重点掌握知识点.
   需了解 **内存模型**各部分作用,保存哪些数据.
    **类加载**  双亲委派加载机制,常用加载器分别加载哪种类型的类.
   **GC**分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景.
 性能调优常有JVM优化参数作用,参数调优的依据,常用的JVM分析工具能分析哪些问题以及使用方法.
   **执行模式**解释/编译/混合模式的优缺点,Java7提供的分层编译技术,JIT即时编译  技术,OSR栈上替换,C1/C2编译器针对的场景,C2针对的是server模式,优化更激进.新技术方面Java10的graal编译器编译器优化javac的编译过程,ast抽象语法树,编译器优化和运行器优化.

## 2 、知识点详解：

![](https://camo.githubusercontent.com/ef5d566ab06b1a3f3f3f260c6634ee02c5f7bca5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303135373431362e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31342c636f6c6f725f4646464646462c745f3730)

1 、JVM内存模型：

 线程独占:栈,本地方法栈,程序计数器 线程共享:堆,方法区

2 、栈：

又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.

3 、本地方法栈

与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.

4 、程序计数器

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行
Native方法时,程序计数器为空.

5 、堆

JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,
当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回
收器进行垃圾的回收管理

6 、方法区：

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7
的永久代和1.8的元空间都是方法区的一种实现

7 、JVM 内存可见性

![](https://camo.githubusercontent.com/80c8d38c672d0fcb4cf152566ab4bea517817d76/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303535393437332e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31322c636f6c6f725f4646464646462c745f3730)

 JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.

![](https://camo.githubusercontent.com/edb24be4f9db4e7d824f697bc563ff7834f37cf4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303631363230362e706e67)

## 3 、说说类加载与卸载

加载过程

![](https://camo.githubusercontent.com/1d9e4e8270674714974213a8bc2eba3f95249f44/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303634313232302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31322c636f6c6f725f4646464646462c745f3730)

 其中**验证,准备,解析**合称链接

**加载**通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.

**验证**确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.

**准备**进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变
量,因为final变量在编译时分配.

**解析**将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量
等.

**初始化**主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用
时才会初始化.

触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时
候,或者某个子类初始化的时候.

Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的
类才可以被卸.

1 、加载机制-双亲委派模式

![](https://camo.githubusercontent.com/a9ee2161e8a4e335c990a92dc5ac24c409a23b86/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323031393035323931303037353335322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31302c636f6c6f725f4646464646462c745f3730)

 双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.

父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.*

 优点:

1. 避免类的重复加载

```
2. 避免Java的核心API被篡改
```

2 、分代回收

分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时
间.

![](https://camo.githubusercontent.com/aee644137a8a1493dbfdd43348e918754b7b1969/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130303832343531322e706e67)

年轻代->标记-复制 老年代->标记-清除

 3 、回收算法

a、G1算法

1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全
部的增量式清理,以保证停顿时间不会过长

其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一
部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.

同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间.

年轻代回收: 并行复制采用复制算法,并行收集,会StopTheWorld.

老年代回收: 会对年轻代一并回收

初始标记完成堆root对象的标记,会StopTheWorld. 并发标记 GC线程和应用线程并发执行. 最终标记
完成三色标记周期,会StopTheWorld. 复制/清楚会优先对可回收空间加大的区域进行回收

b、ZGC算法

前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停
顿时间.

![](https://camo.githubusercontent.com/f227b50f5d6c1bd950f3bfc6677da172df00815b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303532393130313232323634382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c326876626d6436614756754f54453d2c73697a655f31302c636f6c6f725f4646464646462c745f3730)

-  着色指针
-  读屏障
- 并发处理

```
基于region
内存压缩(整理)
```

roots标记：标记root对象,会StopTheWorld. 并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld. 清除会清理标记为不可用的对象. roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的比例. 并发重定位与并发标记类似.

​	





# Spring:



## 1 、什么是spring?

1. Spring 是个java企业级应用的开源开发框架。
2. Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。
3. Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。



## 2 、你们项目中为什么使用Spring框架？

直接说Spring框架的好处就可以了。比如说Spring有以下特点：

```plain
轻量：Spring 是轻量的，基本的版本大约2MB。
控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
容器：Spring 包含并管理应用中对象的生命周期和配置。
MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。
```



## 3 、 Autowired和Resource关键字的区别？

@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。

1. [@Autowired ]() 根据类型注入。 
2. [@Resource ]() 默认根据名字注入，其次按照类型搜索。 
3. `@Autowired` `@Qualifie("userService")`两个结合起来可以根据名字和类型注入

注意：@Resource为Java自带的，@Autowired为Spring框架的。 

1.  为什么重写 equals 还要重写 hashcode？ 
3.  为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？ 
4.  介绍 Java 的集合类 
5.  什么是死锁？死锁产生的条件？ 
7.  有哪些进程调度算法？ 
8.  什么是缓冲区溢出？ 



## MyBatis:

## #{}和${}的区别是什么？

1. \#{}是预编译处理，${}是字符串替换。
2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理替换成变量的值。
3. 使用#{}可以有效的防止SQL注入，提高系统安全性。



## 4 、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

1. 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。
2. 通过来映射字段名和实体类属性名的一一对应的关系。



# [MQ: ](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-11)

死信：无法被消费的消息。

应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。

消息成为死信的三种情况:

- 消息 TTL(Time To Live/存活时间) 过期
- 队列达到最大长度(队列满了，无法再添加数据到 MQ 中)
- 消息被拒绝消费消息，(basic.reject 或 basic.nack) 并且不把消息重新放入原模板队列， requeue = false。

## 1 、为什么要使用MQ

核心：解耦,异步,削峰

1 ）解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。

 （ 2 ）异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 +450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一
个请求到返回响应给用户，总时长是 3 + 5 = 8ms。

（ 3 ）削峰：减少高峰时期对服务器压力。

## 2 、MQ有什么优缺点

- 优点：应用解耦 、异步提速 、削峰填谷。

- 缺点：系统可用性降低 、系统复杂度提高、 一致性问题


系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩溃，你不就完了？系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？问题一大堆。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。



## 6 、如何保证消息的顺序性

   顺序错乱的场景：RabbitMQ：一个 queue，多个 consumer，这不明显乱了；

![](https://camo.githubusercontent.com/a493c12e475f8fcd99fdbc898d9c498261bd2b8c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303138313232343135333633363538342e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c32786c6448523561584e745a513d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730)

 解决：

![](https://camo.githubusercontent.com/396b608e74beda4adf7d5f9c5701aa74c7832511/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303138313232343135333731373339362e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c32786c6448523561584e745a513d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730)

## 7 、 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

消息积压处理办法：临时紧急扩容：

先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。

mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。



## 8 、让你来设计一个消息队列，你会怎么设计

比如说这个消息队列系统，我们从以下几个角度来考虑一下：

首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？

其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。

其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -> leader & follower -> broker 挂了重新选举 leader 即可对外服务。能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。





## 延迟队列：

​    延迟队列(死信队列+TTL)：设置TTL在延迟多久之后消息成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。

注意：延迟队列基于死信队列。
队列内部是有序的。
延时队列就是用来存放需要在指定时间被处理的 元素的队列；需要在某个事件发生之后或者之前的指定时间点完成某一项任务。

使用场景：

1.  订单在十分钟之内未支付则自动取消。 
2.  新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 
3.  用户注册成功后，如果三天内没有登陆则进行短信提醒。 
4.  用户发起退款，如果三天内没有得到处理则通知相关运营人员。 
5.  预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。 



1.  使用消息队列有哪些优缺点？ 
2.  如何保证消息消费的幂等性？ 
3.  消息队列有哪些路由模型？ 
4.  你是否用过消息队列，解决过什么问题？ 

是，

# Redis:

注意：主要减少mysql数据库的操作，及IO操作。

## NoSQL特点：

1. **易扩展**：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，易扩展。在架构的层面上带来了可扩展的能力。
2. **大数据量高性能**：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。 这得益于它的无关系性，数据库的结构简单。
       一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。
    而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。

3. **多样灵活的数据模型**：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。



## 怎么解决Redis和mysql数据不一致问题：

注意：只有是分布式中，数据的同步都是有延迟的，短暂的延迟一般也是可以接收的。但最终都是要数据一致的。

1.  先更新数据库，再更新缓存。 
2.  先删除缓存，再更新数据库。    注意：1和2数据库还是不一致。 
3.  先删除缓存，再更新数据库，再删除缓存（缓存延时双删  （缺点：会造成服务器的阻塞，不适合高并发。） 
4.  CANAL+MQ实现最终一致性。 



## 字符串(String):

-  string是redis最基本的类型，一个key对应一个value。 
-  string类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象 。 
-  string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。 
-  特点：单值单Value。   例：  UserLoginVo   `<user:login:, 1>`
-  `redisTemplate.opsForValue().set("order:repeat:" + 1 ，1)`

使用场景：

1. 比如抖音无限点赞某个视频或者商品，点一下加一次
2. 是否喜欢的文章



## 列表(List):

   Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）它的底层实际是个双端链表，最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。
   它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的结点性能会较差。

- 特点:单键多值, 值可重复。   ===>  

- 使用场景：微信公众号订阅消息。




## 哈希(Hash):

   Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）

使用场景：JD早期购物车(目前不再采用)，当前小中厂可用

1. 新增商品 → hset shopcar:uid1024 334488 1
2. 新增商品 → hset shopcar:uid1024 334477 1
3. 增加商品数量 → hincrby shopcar:uid1024 334477 1
4. 商品总数 → hlen shopcar:uid1024
5. 全部选择 → hgetall shopcar:uid1024



## 集合(Set):

- Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。
- Redis 中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 

- 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)

- 特点：单值多value，且无重复，可快速查找、添加、删除
- 例： set  k1  v1 v2 v3    ===>
   使用场景： 

1. 微信抽奖小程序。

| 1 用户ID，立即参与按钮                    | sadd key 用户ID                                              |
| ----------------------------------------- | ------------------------------------------------------------ |
| 2 显示已经有多少人参与了，上图23208人参加 | SCARD key                                                    |
| 3 抽奖(从set中任意选取N个中奖人)          | SRANDMEMBER key 2    随机抽奖2个人，元素不删除SPOP key 3             随机抽奖3个人，元素会删除 |

## 有序集合(ZSet):

-  set(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 
-  不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。 
-  zset的成员是唯一的,但分数(score)却可以重复。 
-  zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1 
-  例：  zset  k1  score1  v1  score2  v2  ===> Map<String,<String,User>>
-  使用场景：根据商品销售对商品进行排序显示。
      思路：定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。 



## 地理空间(GEO) 3.2+:

-  Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括
   添加地理位置的坐标。获取地理位置的坐标。计算两个位置之间的距离。根据用户给定的经纬度坐标来获取指定范围内的地理位置集合 

   地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。

问题：

1.  查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的 
2.  这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。 
3.  精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差
   注意： 核心思想就是将球体转换为平面，区块转换为一点。 



## 基数统计(HyperLogLog) 2.8.9+:

- HyperLogLog 是用来去重复统计功能的基数估计算法。

- 优点：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。

- 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

- 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

   基数： 是一种数据集，去重复后的真实个数。

使用场景：

1. 美团地图附近位置的酒店推送
2. 高德地图附近位置的核酸检查点



## redis位图(bitmap):

原理：由0和1状态表现的二进制位的bit数组。 说明：用String类型作为底层数据结构实现的一种统计二值状态的数据类型 位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们称之为一个索引)。 Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2^32 = 4294967296)

![img](https://qsl.ztpan.tk/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/SQL/NoSQL/Redis/%E4%BD%8D%E5%9B%BE-BitMap.png)

使用场景：

1.   统计某个网站的UV、统计某个文章的UV(Unique Visitor，独立访客，一般理解为客户端IP,==需要去重考虑==)
2.   用户搜索网站关键词的数量
3.   统计用户每天搜索不同词条个数
4.   天猫网站首页亿级UV的Redis统计方案



# [Nginx](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-12)

1.  ## Nginx 有哪些作用？
   
   *Nginx* (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。
   ①Nginx服务器的最佳用法是在网络上部署动态HTTP内容（部署网站）
   ②通过Tomcat部署网站搭集群（负载均衡器）。
   
    
   
2.  Nginx 有哪些负载均衡策略？ 

## 7 、请解释代理中的正向代理和反向代理

首先，代理服务器一般指局域网内部的机器通过代理服务器发送请求到互联网上的服务器，代理服务器一般作用在客户端。例如：GoAgent翻墙软件。我们的客户端在进行翻墙操作的时候，我们使用的正是正向代理，通过正向代理的方式，在我们的客户端运行一个软件，将我们的HTTP请求转发到其他不同的服务器端，实现请求的分发。

反向代理服务器作用在服务器端，它在服务器端接收客户端的请求，然后将请求分发给具体的服务器进行处理，然后再将服务器的相应结果反馈给客户端。Nginx就是一个反向代理服务器软件。

注意：

  客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 

  反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。

# [Spring Cloud](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-14)

1. 什么是微服务，有哪些优缺点？ 

      ①微服务是一种框架模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。
      ②每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常基于HTTP协议的RESTful API）。

2. 什么是注册中心，能解决什么问题？

   

3. 22、如何提高系统的并发能力？

   使用分布式系统。
   部署多台服务器，并做负载均衡。
   使用缓存（Redis）集群。
   数据库分库分表 + 读写分离。
   引入消息中间件集群。 

Nacos、OpenFeign、Gateway、Sentinel、Steata

# [SQL](https://luxian.yupi.icu/#/roadmap/Java学习路线?id=经典面试题-5)

1. MySQL 索引的最左原则 

2. InnoDB 和 MyIsam 引擎的区别？ 

3. 有哪些优化数据库性能的方法？ 

4. 如何定位慢查询？ 

   

5. MySQL 支持行锁还是表锁？分别有哪些优缺点？ 



# Git:

## Git如何解决冲突问题：

1.  两个分支中修改了同一个文件
   解决方法：当前分支上，直接修改代码，再添加(add) 到 缓冲区、commit(存储库) 
2.  两个分支中修改了同一个文件的名字
   解决方法：在本地当前分支上，修改冲突代码，再添加(add) 到 缓冲区,  commit(存储库)、  push(推送) 

​     冲突产生的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容。





## 什么是Git：

1. Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本。
2. 与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。
3. 每个开发人员都可以“克隆”服务器存储库中的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要所有的恢复数据都在你队友的本地 Git 存储库中。
4. 还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享。



## **Git** **是用什么语言编写的？**

你需要说明使用它的原因，而不仅仅是说出语言的名称。
Git使用 C 语言编写(但不是 C# 或 C++)。 GIT 运算很快的原因，就是因为C 语言通过减少运行时的开销来做到这一点。



## 6、在Git中，你如何还原已经 push 并公开的提交？

```plain
There can be two answers to this question and make sure that you include both because any
of the below options can be used depending on the situation:
```

这个问题可以有两个答案，你回答时也要保包含这两个答案，因为根据具体情况可以使用以下选项：

1. 删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我使用的远程存储库

```plain
git commit -m "commit message"
```

1. 创建一个新的提交，可以使用↓版本回退命令，撤消在错误提交中所做的所有更改。

```plain
git revert <name of bad commit>
```



# 项目：

   大学生没实习哪来的项目经验： 项目是学校老师接单，给我们这些人练手的。
   项目通用流程：用户登录、注册，忘记密码、修改密码。

## 其他：

### 项目中遇到过什么重要的bug。

​    当时项目连接Redis的时候,正确的Redis密码`0123456` 写在`yml`文件写对了项目中却怎么也连接不上。然后我当时就去Redis查看密码，密码正确，Linux系统使用这个密码的时候也可以连接的上，Java项目中怎么也连接不上，最后，我就去Linux改了下Redis的密码，然后发送项目中居然能用Redis连接了。然后，我就试着查看产出这个bug的么原因了，去把Redis把密码改会`0123456`，发现Springboot还是整合报错，而Redis还是可以正常登录使用，最后去官网查看文档才发现 `yml`文件 零开头的 int 类型会自动装换位8进制。

### 项目中怎么返回数据给前端：

  我在项目中定义了一个统一返回结果类(泛型类)，把状态码、返回状态信息、数据返回给前端。 如果觉得每次都写状态码、状态信息的话、就把状态码、状态信息都写进一个枚举类里面，返回数据的时候就把枚举类调用一下就行了。



注册：

用户注册传递

   介绍完项目项目流程一般从：项目流程或技术(项目中ES和MQ了，那些场景使用的)亮点入手。



## 食界通外卖（B2B2C）：

### 常识：

#### 1．请介绍一下你最近做的这个项目吧？

  食界通外卖是基于XX公司原有的校园派送服务进行业务升级，定制化开发的一套面向大学生的团购优选平台。项目依托于公司在全省高校经营的快递驿站或合作的校园驿站、便利超市、水果等为基础，面向校园大学生群体精细化运营，打造垂直化的电商、社交平台。

​    目前项目一期已上线，覆盖高校30余所，注册大学生用户超5W＋，日均订单3000＋。

项目平台：

- 公司运营平台：仓储、配送调度、供应链、结算、订单管理、营销中心。
- 团长终端：团购发起、物资清单分拣、收益结算、售后处理。
- 用户小程序终端：搜索、购物车、订单、用户中心、活动。

技术架构：
   项目基于微服务技术架构，主要以Alibaba 系列微服务组件进行构建，围绕业务拆分需求，每一块业务对应一个微服务，例如：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务。
   项目中用到的其他技术栈也挺多的，比如：SpringBoot、MybatisPlus、Redis、 RabbitMQ、Elasticsearch、OSS、MySQL、Nginx等等。

岗位职责：
   我在这个主要承担Java后端开发，算是一个核心人员吧，因为我刚入职的时候，这个项目才刚开始，所以我也算老员工了。有的时候也会帮助新同事快速适应这个项目的技术栈。到项目后期，我也会指导一下实习生，帮忙写一写接口文档和使用手册。
    这个项目怎么说呢，我们对于工作划分没有那么细致，每一个业务模块我都有所参与。我比较熟悉的模块比如：权限管理模块、商品模块、订单模块、购物车模块、搜索模块是我主要负责完成的。

这就是我最近这个项目的大致情况。



#### 2．说一下你们项目的数据库表是怎么设计的吧，分了几个库和表，你负责设计过哪些数据表？

  数据库设计是在项目初期阶段完成的。当时我们先确立了基本需求以及采用微服务技术架构后，围绕业务设计数据库表结构。

  我们一共分了设计了6个数据库，分别是：权限管理、活动、订单、商品、系统管理、用户管理这6个数据库。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E6%95%B0%E6%8D%AE%E5%BA%93.png)

  我当时主要负责权限管理、商品管理、订单管理相关的数据模型设计，当然不全是我一个人说了算，这些数据表设计完成后，是需要开会评审的，经过项目经理审核通过才能使用。

  我设计数据模型的思路就是，围绕业务进行设计。

  首先我们是拆分出来有哪些业务模块，优先梳理出核心业务，围绕核心业务进行设计数据表，这部分工作主要是产品经理完成的，他会给出初版的需求文档。然后我围绕我负责的几个模块，分析相关的业务流程，每一个流程的业务涉及到哪些实体，整个业务流程围绕这几个实体是怎么运转的，当我把这些想明白后，我直接使用 **PowerDesigner**(破我滴晒呢)绘制物理数据模型，就是ER图。评审的时候，就是围绕ER图进行讨论，审核通过，就导出数据库的建表语句进行开发。
  我设计的权限相关的数据表有：管理员表、角色表、权限表、管理员角色中间表、角色权限中间表、后台用户登录日志表。

   订单数据库相关的表：购物车表、订单配送表、订单表、订单项信息表、订单操作日志记录表、订单退货申请表、退货原因表表、订单设置表、支付信息表、退款信息表

  商品管理数据库相关的表：商品属性表、属性分组表、三级分类表、商品评价表、商品评价回复表、sku表、sku属性表、sku详情表、sku图片表、sku海报表、sku的库存历史记录。

   备注：回答一半就行了。

  这些数据表其实也是随着业务需求不断改变的，我们项目是以月度为单位下发需求的，有的时候需求变动了，多少会改一些数据库字段、新增一两张数据库。

#### 3.项目整体技术架构给我介绍一下？

​      注意：别直接回复我们项目中用的了SpringCloud Alibaba、Nacos、OpenFeign等技术。 没多大的意义,最后结合项目业务来讲。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%842.png)

  我们项目基于微服务技术架构，围绕业务拆分了十个核心的业务微服务，分别是：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务
    项目前后端分离开发和部署。前端分了平台运营管理、会员小程序端、团长端三个终端当前端请求后端时，首先经过网关层。网关这边我们设置了两层网关
    首先是使用Nginx搭建入口网关，我们采用主备的方式搭建的，保障Nginx的高可用我们把前端项目和前端的静态资源部署在Nginx，当请求过来后，直接从Nginx服务器返回。
    如果是动态请求，Nginx服务器会转发给Gateway网关微服务，网关这边我们设计了灰度发布、登录状态校验等全局过器
    Gateway网关微服务会从Nacos中拉取服务列表，按照配置的路由规则转发给后面的业务微服务，默认规则是轮询。
    微服务相关的组件我们用到了：Nacos、OpenFeign、Sentinel、SkyWalking、Seata等微服务组件。
    另外在业务设计的时候，也会用到一些中间件或者第三方服务，比如：阿里云的OSS对象存储、基于Redisson实现的分布式锁、使用Redis作为缓存组件、RabbitMQ消息队列满足一些非强一致性和服务解耦的场景、使用ElasticSearch设计搜索服务，并且基于ELK技术栈搭建日志收集平台等等
    而像业务微服务中的开发，还是以SpringBoot、MybatisPlus、MySQL、Redis这些基本的开发技术作为主要实现
    日常工作中也用到了PostMan、Knife4、JMeter等开发工具
    别的话也没什么了，还有就是交付的时候，我们使用Jenkins做了整合，实现自动构建Docker镜像、自动部署
    我们是提前编写好Jenkins脚本，需要的时候只需要在JenkinsWeb页面中操作，一键部署项目。

#### 4.大概介绍一下这个项目的工程结构吧，说一说为什么这么设计？

 此方法不常问。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png)

我们项目采用前后端分设计开发，我们后端工程只编写后端代码。使用Maven管理整个项目。
    首先，在父工程pom文件中统一管理依赖，锁定依赖的版本号，避免版本号冲突的问题，并且聚合所有的子工程
     然后创建service工程，工程类型为pom格式，也是用来聚合所有的业务微服务，并统一管理了所有业务微服务的通用依赖，例如：web场景启动器、MybatisPlus场景启动器、MySQL、Nacos、Sentinel、OpenFeign等等。这样每一个业务微服务只需要继承父工程后就自动拥有了这些依赖，不用重复导入了。
    在实际开发过程中，总有一些工具类需要在多个工程中重复使用，所以我们又创建了common工程，用来存放一些封装的工具类，比如：字符串处理相关、RabbitMQ、Redis等相关的工具类
    还有就是为了方便微服务之间的调用，我们单独创建了一个service-client工程，用来保存每一个业务微服务对外提供服务的Feign接口，一个业务微服务相关的Feign接口，在一个service-client的子工程中。
    因为微服务调用的时候，一些实体类需要在双方微服务之间传递，所以创建了model工程，统一管理了所有的V0、实体类、枚举类等。
      最后还有一个网关微服务，请求到后端后，先由网关微服务处理，网关微服务根据预先配置的路由规则，路由到业务微服务中对请求进行处理

### 业务篇：

#### 5.介绍一下你们项目中的权限管理模块吧

题外话：课程中讲的这块权限管理太简单，就是：用户、角色、权限的CRUD以及一个菜单列表的递归查询，如果就这样给面试官说的话，说不出来什么花样来。思路如下：
   后台管理系统是面向公司运营人员的，前台是面向普通用户的，我们这里做的是后台管理系统的权限控制，和前台项目面向普通用户的客户端没有任何关系这一点一定要分清楚啊！
   单独设计权限微服务负责后台系统的权限模块
   权限管理采用SpringSecurity进行控制
   前端要体现不同权限的用户，展示的菜单项是不一样的
正式回答
    我们项目的平台运营管理端是面向于平台运营人员、管理人员、审核、物资配送、客服等不同岗位的人员进行使用。所以这是一个权限比较复杂的管理系统，我们设计了一个独立的权限微服务实现权限控制
    不同岗位的账户登录到系统后，看到的菜单项是不一样的，这是因为他们具备的权限不一
样。
    我们关于平台运营管理平台的权限微服务，是采用SpringSecurity权限框架+RBAC模型普通用户没有这个权限，平台管理员权限最高。

​    不同岗位的账户登录到系统后，看到的菜单项是不一样的，这是因为他们具备的权限不一样。
​     我们关于平台运营管理平台的权限微服务，是采用SpringSecurity权限框架+RBAC模型实现的。不同岗位的用户，具备的角色是不一样的，能够在管理系统中看到的菜单项自然也是不一样的。
​          角色和菜单的关联关系，是由管理员进行维护的
​       这个权限管理相关的模块有：**角色管理、用户管理、菜单管理**几个模块
​       后台管理系统我们是不对外提供注册的，如果有新的团长、司机、平台运营等新人加入是由直属领导也就是对应的部门经理为其分配新的账号。
​      用户在管理平台首次登录是需要重置密码的，用户登录成功后，会把用户信息、权限信息是存储在Session中，当然，这个Session我们使用SpringSession进行整合，将用户登录信息存储在Redis当中，实现了分布式会话。
​       另外还会返回前端一个UUID的Token，作为用户的唯一标识，前端会保存在本地Cookie后续访问时，在请求头中携带该Cookie，后端根据这个Cookie校验用户的登录状态以及权限信息。
​     后续用户在访问项目资源时，由SpringSecurity完成授权操作，它会校验用户所具备的权限是否满当前正在访问的资源需要的权限
​     另外就是用户每次登录成功后，前端都会自动请求后端，查询当前用户能够访问的菜单列表，并缓存到前端本地Cookie。当用户退出登录或者关闭浏览器，Cookie数据自动失效。用户下次登录重新查询。
​    而前端会根据查询到的用户菜单列表，在页面的左侧菜单列表中进行展示。
​    还有一点和权限相关的，就是前端每次请求时，会在请求头中携带用户Token，请求到达网关微服务，网关微服务校验如果请求头中没有携带用户Token，且当前请求不是和登录相关的请求，就会直接拒绝访问，前端重定向到登录页面进行登录。



#### 6.区域管理模块：

题外话：
     区域管理在课程中只是基本的CRUD功能，所以在讲解类似这种特别单的CRUD案例时，大家不结合实际业务场景，给面试官去吹。
     另外就是课程中讲解的区域覆盖全国，但是我不想把公司经营规模说这么大，毕竟我们是包装简历，不要吹的太大。可以改一下，比如把全国改为全省，把区域改为校园
    例如：
         上家公司主营XX省内的业务，在省内招了很多代理（团长），精细化的去营销上家公司主营高校业务，在省内各大高校招了很多代理（团长），针对大学生打造垂直领域的精准营销。
说实话，这个流程真的太简单，主要是课程中讲过，所以博哥这里才都列出来。如果面试的时候，面试官不问，你就不用主动讲这个特别简单的CRUD模块了。

正式回答，可以把区域改为校园
    我们公司目前在全省30多所大学校园中都发展了代理，每一个校级代理针对他所在校园进行运营。
    首先我们会录入全省的所有高校的校园信息。
    每当运营发展了-新的校园代理后，会为这个校园开通运营权限。
    开通校园运营权限流包含：录入代理商的各项信息（基本信息、银行账号等）、绑定校园与仓库的关联关系我们公司在每一个开通运营的城市中，都搭建了一个仓库，校园需要和仓库进行绑定后续每天商品的配送，都是由校园绑定的仓库发出的
    而用户在小程序端登录以后，必须先选择他所在校园，如果他所选的城市或校园没有开通运营，则无法使用，会提示用户尚未开通。
    在我设计这块业务的时候，我设计了4张表，分别是：校园代理商信息表（我临时编的）、校园表、仓库表、校园仓库关联表来保存代理商、校园和仓库的关联关系
    编写过的相关业务流程有：校园信息的管理流程、仓库信息的管理流程，以及校园区域开通流程和取消流程
    其中，校园信息和仓库信息管理都是基本的增删改查。比较复杂的是，在校园区域开通流程中，就是判断当前校园是否已经有代理商、当前城市是否开通了该业务。如果当前城市开通了该业务，并且该校园之前没有入住过代理商，那么就保存校园和仓库的关联关系，代表该校园业务开通成功。

```sh
3、Redis
  ①用户登录微信小程序后，使用String类型存放当前用户信息
  ②首页数据的爆款商品，使用zset类型存储商品信息
  ③当前用户的购物车信息，使用hash类型存储
  ④生产订单，商品锁定库存和其他信息
4、Redisson(分布式锁)
   ①生成订单，使用分布式锁，锁定商品库存
5、RabbitMQ
  ①上下架商品
  ②生成订单后，使用RabbitMQ删除当前用户的购物车信息
  ③支付完成后，根据订单号更新订单的状态(改为待发货)和库存（减库存）
6、ElasticsEarch(ES)
  ①使用SpringData简化ES索引库的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。
  ②ES存储商品上下架信息 和10件热销产品,来提高用户查询的速度。
  ③点击查看商品信息，使用Redis的Zset类型存储当前商品的Id,判断除以10等于零后添加到索引库中；可以减少索引库中的数据量，提高索引库的查询效率。
```





#### 7.商品信息管理模块

​    关于商品管理，我们是拆分了一个单独的商品微服务实现的，主要围绕商品相关的业务设计包含：商品分类、平台属性、平台属性分组、商品SKU信息、商品评价与回复这些相关的业务流程。
  关于这些业务流程都是我做的，需要我个给您介绍一下嘛
备注：一般到这个时候，面试官就两个选择：1、可以，你挑重点的说一下；2、不用，你把XX流程说一下。

##### 7.1商品分类管理流程：

   商性分组商品分类这块我们大概分了十几个一级商品类目，因为我们经营的商品类目大多以快消品为主，相对来说比较垂直 所以商品品类不会太多，只设计了一级分类就足够用了。比如说水果、海鲜、冻品、乳品烘焙、面包蛋糕、休闲流式、鲜花宠物之类的。

   分类管理相关流程比较简单，必须是具备管理员权限的账户登录进来，可以针对商品分类进行管理，商品分类字段就是主键id、商品分类名称、分类图片、分类状态以及排序顺序这么几个字段。          

   类似拼多多的首页分类那样：                                                                                                                   ![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86.png)

#####  7.2商品属性和属性分组流程：

​     每一个商品都有很多属性，为了便于管理商品属性，我们针对属性进行了分组
​     每一个属性分组对应某一类型的商品，例如：生鲜水果、速冻食品。
​     然后就是商品和属性分组的绑定关系为一对一，可以在商品SKU管理中进行设置
​      而属性和属性分组的关系是多对一，业务流程是这样的，首先创建属性分组，在属性分组列表中，可以点击添加属性，为当前属性分组添加多个属性。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%88%86%E7%BB%84%E6%B5%81%E7%A8%8B.png)


保存的时候使用两张表进行保存，分别是属性分组表和属性表
保存商品属性的时候,通过外检列，关联属性分组表的数据记录。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%88%86%E7%BB%84%E6%B5%81%E7%A8%8B2.png)



##### 7.3商品SKU管理流程:

题外话： 商品SKU管理流程中,这里最多加一个防重提交的验证。
     在我们项目中，没有SPU的概念，直接就是SKU。因为我们的商品其实都是提前打包或者分类好的，也不存在一个商品要区分不同的购买选择，包括详情页介绍也是非常简单的，因为我们卖的大多都是快消品，而且顾客在我们这里购买，也不会有太多的分类要求
    例如：我们把西瓜按照8-10斤，10-12斤这种方式分类，然后按个卖。或者苹果、香蕉按照斤来卖，提前分好斤数并塑封包装好。包括像酸奶、面包、零食等等，也都是按照个或盒的形式进行售卖，买家如果想要购买多个，只需要填写不同的数量就可以了。
    所以在后台运营上架商品的时候，直接填写单个SKU的信息就可以了。
    在上传商品SKU的时候，使用SKU基本信息表、详情表、图片表、海报图片表、SKU属性值表5张表进行保存。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81SKu%E8%A1%A8.png)

在填写商品详情时，前端使用富文本编辑器进行编辑,将编辑完毕的商品详情，在前端转为HTML代码，保存在商品详情表中。
     当选择了商品关联属性分组时，会异步的形式向后端查询商品分组的所有属性，并展示在页面中，由管理员手动录入商品的各项属性值，使用SKU属性值表进行保存
     关于商品图片部分，我们是购买了阿里云的OSS对象存储资源，将图片保存到了阿里云服务中，在数据表中保存的是图片的URL路径。
     当商品SKU新增完成后，并不代表就可以立刻购买，还需要通过审核和上架流程，才能正式被购买。
    审核流程是需要经过运营的领导，一般是城市经理进行审核。审核通过后，运营人员才可以决定是否上架。
     而在上下架的过程中，我们是使用**Elasticsearch+RabbitMQ**进行实现的
    其他流程就是修改和删除，是最基本的功能，代码实现也非常简单
    只不过需要注意的是，在针对商品SKU进行增删改的时候，为了防止重复提交，我们会在前端进入到页面之前，后端会下发一个临时的验证Token，这个Token一份存在Redis，一分返回到前端。当前端正式提交增删改操作时，这个防重Token也会随着请求一起发送到后端。
    后端在处理的时候，先从Redis中检查该防重Token是否存在。如果不存在，则表明该表单已经提交过了，应该拒绝处理，如果存在，则先删掉这个Token，  返回值为1， 代表删除。

只不过需要注意的是，在针对商品SKU进行增删改的时候，为了防止重复提交，我们会在前端进入到页面之前，后端会下发一个临时的验证Token，这个Token 一份存在Redis，份返回到前端。当前端正式提交增删改操作时，这个防重Token也会随着请求一起发送到后端。
    后端在处理的时候，先从Redis中检查该防重Token是否存在。如果不存在，则表明该表单已经提交过了，应该拒绝处理。如果存在，则先删掉这个Token，且返回值为1，代表删除成功，允许继续执行提交请求。反之，如果返回0则代表删除失败，拒绝处理提交请求。
    还有一个细节就是，如果商品处于上架状态，是不允许被删除的，必须先下架，才能被删除。因为商品信息如果上架后，会在ES中保存一份，所以必须要先执行下架。在下架流程中，会清理掉ES中的商品数据，下架后才可以删除该商品。    

##### 7.4商品评价流程:

​    题外话：商品评价在课程中没有讲的。
正式回答：
​     商品评价功能是商品微服务中实现的，使用商品评论表和商品回复表进行保存。

   当订单确认交易成功后，买家是可以针对商品进行评价的。当买家评价完毕后，商家可以进行回复。分别使用评价表保存首次评价，使用评价回复表保存评价回复评价和评价回复不同之处在于，评价数据可以包含文字、图片、视频，并且其他买家可以给评价进行点赞。
   而评价回复只能是文字的形式另外就是在评价的时候，我们设计了敏感词过滤，防止一些不文明的词汇出现我设计了单独的一张敏感词汇表，保存敏感词汇。并且利用**DFA算法**封装了一个工具类简化敏感词匹配的过程。如果买家评论的内容有敏感词汇，则不允许发布评论额外扩展。
   DFA算法是一种确定有穷自动机的方式。以前我们是使用的传统的字符串比较方式，就是遍历所有的敏感词，然后在每次循环中，将整片文章字符串传入，然后调用contains方法进行判断，这种方式效率非常差。所以我们改成基于DFA算法的实现方式。
   在实际使用的时候，我是封装了一个工具类，一次性的把有的敏感词存储到了多个map中，然后和文章内容进行比对，map中的某一个词项能够和文章中的词项比对上，就结束这种算法的原理，我大概理解就是将预先输入的词项，构建成一个类似索引的数据结构，匹配的时候也是按照顺序进行匹配，如果输入的内容能够匹配到某一个索引的终点，就代表某一个词项在文章中出现过。

####   8.商品上下架流程 （技术亮点： Elasticsearch RabbitMQ）

​       题外话：这个流程算是第一个复杂流程，但称不上复杂业务，只能说技术上有点亮点，实现过程稍微有点复杂。
​       这种问题只适合面试官问到：Elasticsearch、MQ哪里用到过？可以提一下在商品上下架流程中用到过。
​       如果面试官问：请你介绍一个最复杂的业务流程吧，那就干万别介绍这个业务流程，可以介绍下面的**订单流程**。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E6%95%B4%E5%90%88ES+MQ%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E4%B8%8A%E4%B8%8B%E6%9E%B6%E6%B5%81%E7%A8%8B.png)        

​    商品上下架这块也是我做的。业务需求是这样的，检索商品时，我们设计了单独的检索微服务，底层利用ElasticSearch进行实现，这是因为ElasticSearch支持分词、性能高、支持复杂语法查询。
   所以当商品上架后，需要将商品信息同步到Elasticsearch中，在实现的过程中，因为涉及到多次微服务之的调用，而这个商品上下架业务流程并不需要等待ES同步完毕再响应请求。于是我们就使用RabbitMQ进行解耦，将上下架流程和同步数据到ElasticSearch的流程分离。
​    只要商品上下架的时候，SKU表中状态修改成功，并保证这个上下架商品的id发送到MQ中成功，那么当前请求就可以立即响应了。                             
   而检索微服务这边定义MQ消费者，分别监听商品上架队列和商品下架队列中的消息，一旦监听到有新的消息，就说明有新的商品上下架的情况，那么就进行相应的业务处理。       
​     检索微服务消费者这边的业务处理逻辑是这样的：
​      首先，我们使用SpringData、Elasticsearch进行整合，它提供了类似于JPA的操作方式，通过实现通用接口就可以完成对ElasticSearch中数据的基本增删改查操作。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E5%9C%A8ES%E4%B8%AD.png)

​    然后我们封装了商品数据映射到ES索引库中的POJO实体类，里面包含：商品基本信息、商品分类信息等数据。
   当见听到商品上架队列消息，则从消息队列中取到商品SKUID，然后远程调用商品微服务，根据skuid查询到商品分类信息、商品SKU信息，并封装为POJO实体类调用SpringData、ElasticSearch提供的通用方法保存到ES中即可。
   当监听到商品下架队列消息，直接从消息队列中取到商品SKUID，根据文档ID删除掉ES中的数据就可以了。



#### 9.后台营销活动管理模块：满减规则设置

 题外话：这里在后台管理系统中，针对满减规则进行基础的CRUD，算不上复杂业务流程不过，博哥认为，这里都是为后面的订单业务流程做铺垫，比如：以后前台项目中，用户下订单了，如何判断订单中的订单项是达到活动标准？如何拆分优惠金额到每一个订单项？这个就是一个非常精彩的复杂业务流程了，所以大家不要着急。同样，关于这里的业务讲解，我们乃然是非常清晰的讲清楚每一个步骤即可。
 这个满减规则设置的流程，一共涉及到三张表，三张相关的表如下：
   关于营销活动，我们项目中是单独设计了一个营销微服务进行实现的。营销管理模块相关的业务有：满减、优惠券、秒杀、抽奖等业务流程
而关于满减规则设置的业务流程是这样的
   首先，平台运营经理登录后台运营管理系统后，先创建活动信息，设置活动名称、活动详情、开始和结束时间，还有活动类型，活动类型可以为满减或者折扣，使用**活动信息表**保存活动的信息。
   活动创建成功后，可以为活动添加优惠规则，优惠类型可以是满减或者折扣，例如：满100元减5元，或者满100元打9.5折。使用**活动优惠规则表**保存优惠的信息，一个活动可以设置多个优惠规则，活动优惠规则是,通过外键列关联活动表的主键ID。
   最后就是为活动关联参加活动的商品了。 并不是每一种商品都可以参加活动，有些商品利润比较低，例如：可口可乐、娃哈哈之类的品牌快消品，单品利润率不超过30%，就几乎很少参加活动，即便参加互动也是满减5元之类的小活动。而像应季水果、非品牌的零食饮料、巧克力鲜花利润率普遍50%以上，我们就几乎天天上活动。所以我们需要针对不同的商品，关联不同的优惠力度的活动。于是我设计了**活动参与范围表**，这是一个中间表活动ID关联活动数据库的活动信息表主键ID，商品SKUID关联商品数据库的商品SKU信息表的主键ID。

   前端在展示商品详情页面的时候，会查询当前商品是否参加活动，如果参加活，会在商品标题下面列出来活动规则，例如：全场满100减5元，或者端午节专场满100减10元。并且在最后结算订单的时候，这些活动规则不能相互叠加，我们会列出来当前订单能够参加哪些活动，并且自动选择优惠力度最大的活动规则。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E8%90%A5%E9%94%80%E6%B4%BB%E5%8A%A8.png)

​    

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E4%BC%98%E6%83%A0%E5%8A%9B%E5%BA%A6.png)





#### 10.后台营销活动管理模块：优惠券管理

题外：这里优惠券管理模块，和上面的满减规则差不多

正式回答
    后台优惠券管理这块，我主要是完成了优惠券的增删改查和优惠券规则的增删改查
    我个给您介绍一下这块业务流程吧
     首先是表结构，我一共设计了两张表，用于优惠券的管理，分别是：优惠券信息表和优惠券范围表。
    优惠券信息表保存了优惠券的相关信息，比如：优惠券类型是现金券还是满减券、优惠券名字、优惠券金额、使用门槛、优惠券领取日期与结束日期、优惠券过期时间、优惠券使用范围、发行数量等等。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E4%BC%98%E6%83%A0%E5%8D%B7%E7%AE%A1%E7%90%86%E8%A1%A8.png)

  由于我们业务上要求优惠券需要限定使用范围。有的优惠券可以全场商品使用，有的优惠券只能针对某一个商品进行使用或者针对一个商品类目进行使用
    列如我设计了一个饮料专场优惠卷，那么整个饮品类目都可以使用这张优惠券
    所以我又单独的设计了一张优惠券范围表，描述了优惠券的使用规则。
    主要字段有关联的优惠券ID、范围类型是商品还是分类或者全场通用、以及范围ID。如果范围ID为0，就代表全场通用。
    如果范围类型为商品，那么范围ID就是使用优惠券的商品skuId
    如果范围类型为分类，那么范围ID就是使用优惠券的商品分类ID
    优惠券范围表和优惠券表是多对一关系，也就是说，一张优惠券可以被多个指定的商品使用，或者被多个指定的商品分类使用。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E4%BC%98%E6%83%A0%E5%8D%B7.png)

这就是我设计的两张表，并且围统这两张表完成了基本的增删改查操作，比如ID查询、分页查询、新增流程等
    我给您介绍几个稍微复杂点的流程吧
       首先是优惠券的修改，在页面中修改优惠券信息的时候，会同时列出来优惠券的使用规则，有可能前端同时也把优惠券使用规则也修改了。所以在修改优惠券信息的时候，我先删掉当前优惠券关联的优惠券规则数据，然后再更新优惠券信息到优惠券信息表中，新增优惠券规则信息到优惠券范围表中。
        然后就是优惠券的删除，我会判断优惠券的领取时间是否开始。如果优惠券的领取时未开启，那么才可以进行删除，同时会级联删除掉优惠券关联的优惠券范围表中的无惠券规则数据。如果说优惠券已经开始被领取了，那么就不能被删除，只能是暂停领取，修改优惠券状态为不可用！并设置发行数量为0。
    题外话：优惠券领取这块我们可以设计类似优惠券领取的秒杀业务场景，但是和这块的业务没有关系。这块的业务属于后台管理系统。我们先继续往下走，按照课程中讲解的流程先把课程中的业务流程梳理完毕，最后如果说他后面关于优惠券领取流程没有讲或者讲的不过源，博哥会给大家专门梳理一个优惠券秒杀流程。

#### 11.微信登录 （技术亮点：Redis、 JWT、 微信登录）

   题外话：这里的微信登录，是面向于前台项目的普通用户。需要注意的是，要实现微信登录需要先接入到微信开发，申请微信开发者账号、申请小程序号（测试号），前端使用微信开发者工具开发，不过前端不需要我们在意，我们的重点是关注整个实现流程以及后端要做的事情。
实现流程图如下：



正式回答：
    面向普通买家用户的前端项目，我们是使用微信小程序开发实现的。    使用微信小程序的话，一个是节省前端App的开发成本，其次就是更容易留住买家，买家只需关注扫码就可以长期保存在用户的微信列表中。
    开发的时候，首先我们是在微信开发者中心以公司的资质进行了认证。这样，就可以正式发布微信小程序以及接入微信支付和微信登录
    有了开发者账号，就可以申请小程序应用，得到小程序ID和小程序秘钥
    然后关于用户相关的业务，我们后端单独创建了一个用户微服务进行实现
    微信登录业务流程是这样的，首先用户在小程序端点击登录，前端会调用微信的登录方法wx.login()进行登录，用户在微信端需要点击允许登录。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png)



  当用户允许后，微信Server端就会返回一个临时票据code，前端将这个临时票据code发送给我们后端
     我们后端需要带着自己的AppID和App秘钥以及这个临时票据code，去向微信Server端发起请求，交换回来一个Sessionkey和openld。
        Sessionkey代表一个会话的秘钥，用于校验会话数据的签名和解密，这个是有有效期的。
          而Openld代表用户的唯一标识，这个是不会改变的，所以后面我们也是通过Openl判断用户的唯一性
      因为这是一个HTTP的远程调用，于是我封装了一个Httpclient (Http可辣特)的工具类和微信Service专门用于对接微信的开放API
      得到用户的Sessionkey和Openld以后，根据Openld判断用户是否是首次登录
     如果是首次登录，那么就是插入新的用户信息，因为新版的微信api关闭了getUserlnfo接口，所以我们只能用Openld+随机字符串作为默认用户名，用户将来可以在个人中心进行修改。
     然后就是查询用户关联的团长信息、关联的自提点信息
     查到用户信息以后，我们就根据用户id和用户name，生成一个自定义的Token，这个格式我们采用JWT格式进行实现。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/token/JWT/jwt%E6%B5%81%E7%A8%8B.png)

   最后就是封装返回给客户端的数据，比如Token、用户信息、关联的团长信息返回给前端。另外还要把用户的个人信息缓存到Redis当中,以后前端访问的时候，就需要在请求头中携带这个JWT Token，后端需要校验Token是否过期、签名是否被算改。如果校验未通过，就返回异常情况，让前端重新登录，如果校验通过，再返回业务数据这到此为止，这个微信登录流程结束了，你可以给面试官说：这是我负责实现的微信登录。

  我再给您详细说一下我关于登录以后，用户再次请求的一个认证流程吧(可以不用说这个)，**网关中实现也可以。**
        实现方式是这样的当用户登录成功后，前端每次请求都会把Token放到请求头里面，这个Token就是登录时下发的JWT格式的Token。
      我在后端代码中，设计了一个拦截器，拦截到请求后，从Request请求头中获取Token，然后调用预先封装好的JWT工具类校验Token没有问题，从Token中取到Userld，再拿着Userld去Redis中获取用户信息。如果用户信息没有过期，那么就可以获取到，如果过期了，前端需要重新登录
        当获取到用户信息后，我直接把用户信息封装到 ThreadLocal （特勒老狗）中，这样，在后续的处理业务的过程中，就可以随时取到用户信息进行相应的业务处理了。

#### 12.首页数据显示：

题外话：
     这个接口的话术做了改造，和原本课程中讲的有点出入。
        查询用户信息，原版课程中是分两次查询，远程调用用户微服务查询用户提货信息远程调用用户微服务查询用户是否是新用户
          原版课程这么做的原因可能是出于单一职责的原因考虑吧，一个接口只负责一件事情。但是博哥认为，有的时候，软件设计时，不能太遵守一些规范。如果我将这两次远程调用合二为一，那么就可以在首页流程中优化一次网络IO。
       另一个改动的地方就是分类数据查询，原版课程是远程调用商品微服务查询分类数据。
         但是博哥不这么认为，商品分类数据作为经常查询且极少修改的数据。我就算是把商品分类数据写到一个common工程的常量类中，每次访问时直接本地返回，redis都不带的查询，合理不合理？我认为非常合理！因为就算调用redis，也要付出一份网络IO，对不对？
       所以我这里改了一下，商品分类数据缓存在Redis，common工程中维护了Redis中所有的KEY的常量，商品服务将商品分类数据缓存到Redis，首页服务从Redis获取就可以了。
   还有就是爆款商品查询，这里是调用检索微服务查询的。这个没啥问题，只不过这里在最后补充了一下**爆款商品的计算规则和实现方式**，如果你能理解的话呢，可以把这个在面试的时候给面试官讲一下。



正式回答：
用户登录成功后，首先是直接跳转到首页面的。在首页面中，我们会展示

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE.png)

1. 当前登录用户的提货点信息，例如：某某校园
2. 还有新人专享的商品，我们在user表中，有一个is new字段，代表是否是新用户，如果是新用户，就会查询新人活动数据，展示新人活动专享的商品

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%94%A8%E6%88%B7%E8%A1%A8.png)

3. 还有商品分类、秒杀活动  热销商品等数据;
        实现方式是这样的，我们是单独设计了一个首页微服务进行实现。关于首页数据接口这块，业务是这样的：
    
4. 首先判断用户是否已经选择了提货地址，这是用户登录成功后，前端根据后端返回的数据判断当前用户是否有关联团长信息，也就是提货点信息。如果没有的话，直接在前端弹出对话框，强制要求用户选择提货点信息，因为我们后面商品展示是以当前提货点地址来关联仓库进行查询的，所有用户必须选中一个他所属的提货点。

5. 如果当前用户没有关联的 提货点信息，他应该是个新用户。前端会把用户的经纬度坐标发送给后端用户微服务，后端用户微服务预先在Redis中使用GEO数据类型缓存了所有的代理商提货点的经纬度信息，所以可以借助Redis的GEO Hash的方法，根据当前用户的经纬度坐标求出距离用户最近的提货点信息，并且按照距离进行降序排序返回给前端。用户在前端可以手动选择提货点。

6. 当用户选择提货点以后，就直接发起一个异步提交，向后端保存用户的提货地址信息，其实就是保存会员、团长和仓库的关联关系。

   ![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%94%A8%E6%88%B7%E4%B8%8E%E4%BB%93%E5%BA%93%E5%85%B3%E7%B3%BB%E8%A1%A8.png)

7. **然后根据Userld远程调用用户微服务**，查询用户信息，包含①用户的提货地址信息  ②以及当前用户是否是新用户

8. 如果当前用户是新用户，那么就调用商品微服务，查询新人专享的活动商品列表。默认首页只展示3个活动商品。如果说新用户对新人专享活动感兴趣，那么他可以点击进入到新人活动专区，在新人活动专区中，再重新查询更加详细的活动商品数据。

9. **还有就是查询当前的爆款商品**。爆款商品是根据商品的点击、销量、评价星级等用户行为计算出来的，这是商品微服务的一个业务流程。我们这块首页查询的时候，直接调用检索微服务按照热度分值进行降序排序，返回前10条商品数据作为爆款商品展示在前端页面中就可以了。

10. 最后，从Redis中取出来商品的分类数据，和前面的用户提货点信息、新人专享活动、爆款商品统一进行封装，返回给前端展示就可以了。

11. 另外这个爆款商品计算规则，是商品微服务中的一个业务流程，也是我独立负责的。主要是针对商品不同维度的用户行为进行统计，比如：购买、浏览时长、加购、评价星级，进行计算，得出来的一个分数，这个分数就是商品的热度

    

    

#### 13.爆款商品热度是怎么计算的？

​    题外话：现编的。参考头条项目的文章热度计算流程进行改写。
​    头条的文章热度计算有定时计算和实时计算，但是考虑到这种电商项目，商品的热度业务角度来看，并不是一个非常强一致性的东西，再加上实时计算使用KafkaStream，也会带来很大的学习成本，所以就改成定时计算实现，主要借助Redis+XXL-JOB实现。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%88%86%E6%AC%BE%E5%95%86%E5%93%81%E7%83%AD%E5%BA%A6%E6%B5%81%E7%A8%8B.png)

正式回答：
   爆款商品热度是根据用户对商品发生的各种行为进行计算的，主要有：浏览商品、评价商品、商品上下架  商品支付成功、商品退货、商品加购等行为进行汇总计算。
    每一种用户行为对应的分值不一样，浏览商品加1分，评价商品根据评价星级加分或减分，商品下单加5分，退货减5分。
    因为这些行为涉及到多个微服务的业务流程，而商品热度计算并不是强一致性的，于是我将原有的业务流程和商品热度计算流程解耦。这里我并没有使用MQ进行实现，而是采用Redis实现。
   使用Redis的ZSet集合，保存商品的热度数据，每一条数据的分值就是商品热度
    并且定时每隔10分钟，执行一遍数据同步任务，将Redis中的商品热度同步到
ElasticSearch中的Sku索引中就可以了，
     因为我们的商品数量最多也就一两千种，所以不用担心Redis中的全部商品热度数据同步时，带来的一些性能问题，这些根本不会对性能有任何影响。
    在以后遇到一些检索需求时，除了根据商品的名称、价格、属性等信息进行检索，还可以针对检索结果按照热度分值进行排序，例如首页数据展示中查询爆款商品，就是按照热度分值进行降序排序查询的。

#### 14.商品检索你是怎么实现的：
  需求：根据搜索关键字查询商品或者根据商品分类查询其下的商品列表
这种需求大家一看就懂，太简单了。
当前需求属于首页微服务，所以：
1、首页微服务远程调用商品微服务，查询商品分类列表
2、首页微服务调用检索微服务，查询商品信息以及活动信息                      
3、查询商品的活动信息                               

  在原版课程中，是讲了两个接口，分别是**查询商品分类**和**根据条件查询商品**，这里博哥认为，这是两回事不应该放在一个问题中，并且查询商品分类太简单了，一行查询就搞定。所以这里就只详细聊怎么进行商品检索。
正式回答 

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%88%86%E7%B1%BB.png)

 商品搜索这块也是我做的，业务流程大概是这样的
-  用户点击小程序底部菜单栏，点击【分类】跳转到分类查询页面中，在分类查询页面中支持根据分类类型查询商品以及根据关键字查询商品两种方式。
- 后端会根据请求入参，拼接查询条件，返回查询到的数据， 展示在前端中。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81.png)

- 首先校验用户的登录状态，这是由我提前封装好的通用拦截器实现，他校验通过后，会把用户信息从Redis中取出来放到ThreadLocal中；
- 然后在处理请求的时候，我从ThreadLocal中取出来用户关联的仓库ID，还有从请求参数列表中取取出来分类ID、商品关键字以及分页参数，拼接到一个自定义的查询VO中。
- 远程调用检索微服务，检索微服务会根据传入的查询条件，去ES中查询到符合条件的商品列表信息。这还没完，我还要拿着这些查询到的商品ID,远程调用活动微服务。
- 在活动微服务中，我会按照商品ID、活动的起止时间、活动状进行查询，返回每一个商品ID对应的活动信息，比如说满减、折扣等优惠信息，因为每一个商品可能可以同时参加多个活动，所以每一个商品对应的活动是一个List集合保存多个活动信息。
- 最终，首页微服务返回给前端的格式就是自定义封装的一个Page分页对象，而查询到的数据，使用List集合进行封装。每一个商品使用自定义的VO对象代表，其中包含商品名称、价格、图片、是否是新人专享、满减、折扣等数据。
- 这些数据返回给前端后，前端展示在列表页面中，这就是我负责的商品检素业务流程的实现。



#### 15.商品详情页功能：

   根据商品SKUID查询商品详情

查询的数据有：
   商品基本信息表 product.sku_info
   商品图片表：product.sku_image
   商品海报表：product.sku_poster
   商品活动信息：activity.activity_info、activity.activity_sku、activity.activity_rule
   商品优惠券：activity.coupon.info、activity.coupon.range
另外再做一件事，就是更新一下商品热度，还记得13题讲的商品的热度计算规则吗？商品浏览一次，加1分。
注意：原版课程是调用检索微服务，分值先缓存到Redis，并每次达到10的整数倍就更新Redis数据到ES。这里改造了一下，在第13题中我们统一使用了Redis+XXL-JOB进行实现。

正式回答
商品详情页查询是我做的，当用户在搜索页面点击商品进入到详情页时，后端由首页微服务进行处理。执行步骤是这样的

- ​    首先**调用商品微服务查询SKU信息**，包含SKU基本信息、SKU图片、SKU海报图、SKU属性列表数据；

- 然后调用活动微服务根据skuld和用户id,**查询商品的活动信息和优惠券信息**
            查询商品活动信息:
               首先是直接根据skuld进行查询，查到当前商品关联的活动。
               还要根据skuld查询商品基本信息，得到分类ID，再根据分类ID查询这个分类当前有没有参加活动，将当前商品所属分类关联的活动信息也查询出来，活动类型有满减和折扣两种类型。
        
- 合并商品直接关联的活动信息和分类关联的活动信息为一个活动列表，然后继续查询优惠券信息：

- 无论任何优惠券，首先是当前用户需要领取过才可以查询出来，我们有一张coupon_use表，记录了优惠券领取记录，根据用户ID查询到当前用户领取过的优惠券，同时用内连接查询的方式连接查询优惠券使用范围表（规则表），判断当前用户具备的多张优惠券是否是当前商品可用或者当前商品所属分类可用（因为我们的优惠券类型有商品、分类两种形式）以及是否是在优惠券使用的时间范围内。最终返回当前用户针对该商品可用的优惠券列表，如果没有的话就返回空。

- 需要注意的是，优惠券必须是用户先拥有了优惠券，才能够使用，不会在下单的时候自动领取的(拼多多就是下单自动领取)。而优惠券的获取方式有用户在活动页面获取、也可以是后台运营人员直接赠送的。

- 还有就是根据userld判断当前用户是否是新用户。如果是新用户，则拿着用户ID+skuld去新用户活动表中查询一下当前商品是否正在参加新用户专享活动。如果是，则把这个新人活动信息，和前面的那个满减、折扣活动信息进行合并。

-   活动微服务最终返回的是当前商品正在参与的活动列表以及当前用户针对当前商品可以使用的优惠券列表给到首页微服务。

     

- 接着就是**更新一下当前商品在Redis中的热度数据**，我们使用Redis的一个zset集合保存每一个商品SKU的热度，当用户浏览一次商品，就对他的score分值+1，并且定时同步给ES中的商品Sku索引中。这样就能实现其他一些热度查询、爆款商品查询的需求。
         因为这几个步骤：查询商品信息、活动信息、更新商品热度，他们之间没有顺序要求，所以我这里使用 CompleteFuture （看薄了父车）异步编排，让他们以异步的方式执行，等待3个子线程任务执行完毕后，主线程汇总结果，将商品信息、活动信息封装好返回给前端。这就是我写的商品详情页的流程。

     

####  16.购物车功能：

 购物车是一个电商场景中经典的一个面试题，最经典的几个问题是
     用户未登录，怎么记录用户的购物车？
    用户登录后，登录前的购物车信息如何合并？
     购物车持久化是使用Redis保存还是MySQL保存？

需求说明
         商品首先添加到购物车中，购物车中保存商品的信息以及购买熟练

   商品首先添加到购物车中，购物车中保存商品的信息以及购买熟练。
        在结算的时候，是在购物车中进行结算，可以选中多    品进行结算；结算的同时，要显示可用的优惠信息。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E8%B4%AD%E7%89%A9%E8%BD%A6.png)

​     一个用户的购物车，使用一个类型为hash类型的数据类型保存外层的key（大key）为用户ID，hash内部可以存储多个KV键值对数据，这里的key是每-个商品ID，值为商品信息（封装了一个Cartlnfo对象表示）。

正式回答：
 关于购物车模块相关的业务，是我主要负责的，相关的接口是放在购物车微服务中实现的，比如我写过的相关接口有：

-   商品加入购物车
-   查询购物车列表
-   切换购物车商品的选中状态
-   删除购物车
-   带活动和优惠卷信息的购物车列表查询
   ​      购物车数据，我们是使用Redis的 hash类型进行存储的。每一个用户的购物车数据，都是一个hash类型集合进行存储。用户的id作为key，用户的购物车数据作为值，使用hash类型进行数据保存。在hash集合内部，商品skuld作为key，自定义了一个Cartlnfo对象作为值。
   ​      在存储的时候，会将Cartlnfo对象转为JSON格式存储在hash结构中的value中去。

#####    16.1加入购物车流程：

​    我先说一下商品加入购物车流程吧：
​    首先根据用户ID从Redis中取出来当前用户对应的购物车数据，就是将用户在redis中用于保存用户购物车数据的hash结构类型数据取回到本地。
​     然后根据Skuld判断当前商品在购物车Hash中是否存在，我们封装了一个Cartlnfo对象代表一个商品在用户购物车中的数据。
​    这个Cartlnfo中包含有：用户ID、商品分类ID、商品类型、活动数据、价格、购买个数、关联的仓库ID、限购个数、是否被选中等数据
​    如果存在，我们就先判断一下是否超出当前商品的限购数量，如果超出了限购数量，直接抛出异常，结束方法。
​    如果不限购或者没有达到限购数量，则会将当前购买的数量，加到Cartlnfo原本的购买个数当中去，并且将当前商品在购物车中的选中状态改为1，代表选中。
​    如果存在，那以前肯定添加过该商品，所有我们就先判断一下是否超出当前商品的限购数量，如果超出了限购数量，直接抛出异常，结束方法。
​    如果不限购或者没有达到限购数量，则会将当前购买的数量，加到Cartlnfo原本的购买个数当中去，并且将当前商品在购物车中的选中状态改为1，代表选中
 如果不存在，则新建一个Cartlnfo对象，远程调用商品微服务，根据skuld查询到Sku的详细信息，将Sku详情封装到Cartlnfo中，以及当前要新增的数量，并且把选中状态改为1代表选中状态。
   最后将Cartlnfo数据更新到Redis中就可以了。
   还有就是购物车数据我们业务上是不需要永久保存的，所以针对每一个用户对应的购物车过期时间设置为30天过期。至于说为什么是30天，原因是这样的，基本上每隔1个月，像我们卖的一些时令水果、应季产品就会换代好多，或者更新新的打包售卖方式。所以就是用户长期不使用的话，那么大概率他的购物车数据中很多商品已经下架了，所以我们设置有效期为30天不使用，就删掉用户对应的Redis中的购物车数据。



##### 16.2删除购物车：

​    删除流程很简单，有两种删除方式，一种是清空购物车，一种是删除单个购物项
​    说下清空购物车吧，直接就是将用户对应的购物车hash给删掉了，然后重新新建一个空的购物车key，放到Redis就可以了
​    然后就是删除购物车中的某一个商品，我们的业务流程是这样的。在前端中，假设用户针对红薯商品添加了两次，购买数量为2。那么当用户点击减号的时候，会向后端发送一次修改数量操作，将前端要修改的数量增加或者减少发送给后端进行修改，实现步骤就是将用户的购物车数据取出来，重新更新一下商品数据，将购物车中的购物车项购买数量进行更新，再存回到Redis中去。
​    当前端的剩余数量为1的时候，用户再次点击减号，前端就会提示用户要从购物车中删除当前商品，那么如果用户同意，则向后端发送删除请求，将要删除的商品从用户的购物车中移除。实现步骤就是根据userld找到用户的购物车Hash，然后调用hash的方法根据key删除当前商品就可以了。

#####    16.3查询带优惠券的购物车  *

   题外话：这个流程是整个项目中最复杂的流程之一，另一个是下面的订单相关流程。还有一个比较复杂的流程就是查询带活动和优惠券信息的购物车流程。

   业务流程是这样的，首先用户在购物车中勾选了几个要结账的购物车商品进行结账。
   所以每次勾选一个购物车商品的时候，都会向后端发起一次查询，查询当前用户在购物车中选择的几个商品，判断用户如果购买这几个选中的商品，可以参加哪些促销活动以及可用的优惠券，同时还要根据多个活动规则，计算出来优惠的金额等等一起返回给前端。
​    步骤是这样的，用户请求的是购物车微服务，购物车微服务提供了查询购物车优惠计算的接口，在实现的时候：
​        根据用户的id，从redis中获取到购物车数据，并且进行过滤，过滤出来用户选中的商品数据，作为要计算优惠的购物车商品数据。然后远程调用活动微服务，将购物车数据传给活动微服务的优惠计算接口，查询出来当前购物车中选中的商品能够参加哪些活动以及可以使用的优惠券信息和优惠力度。
​        在活动微服务的优惠计算接口中：
​             首先是先查询当前购物车中的所有商品可以参加哪些活动，哪些商品不参加任何活动，实现步骤是这样的：

​      先根据购物车中的skuid， 查询活动商品关联 activity Sku）  表  得出当前购物车中的哪些商品可以参加哪些活动。
​    因为可能会出现一个活动对应购物车中的一个商品，也可能一个活动对应购物车中的多个商品。而在计算优惠规则的时候，例如满减、折扣，是需要按照活动范围内的商品的总金额或者购买数量来统计是否达标或者优惠力度，所以还需要先针对活动进行分组，才能计算优惠力度。
   活动分组数据计算就是遍历当前购物车中可参加活动的商品与活动关联关系
集合，然后以JDK8的流式编程写法遍历集合，得到了每一个活动和参加该活动的商品集合的Map映射关系。活动ID作为Key，商品ID集合作为值进行保存。
   当然了，光得到活动分组数据还不够，我还需要知道活动的规则，才能去计算满减或者折扣的优惠。所以根据上一步计算出来的可参加的活动ID集合，去查询活动规则表（activity_rule），得到当前购物车中的商品能够参加的所有活动对应的活动规则。

 我们的业务需求是这样的，就是一笔订单中的所有购物车商品，可能同时满足多个活动，但是只能同时参加一个促销活动。因为一个商品可能在多个活动中都能够达到单或者满减的规则，那我们不可能给用户反复的叠加活动的优惠啊，这样会赔钱的
        ==原课程中是直接将所有的达标活动都拿出来进行优惠，在求出所有的活，不太合理。以下为修改版==

​    所以我们会针对当前购物车商品达标的多个活动分组分别进行计算，求出来每一个用户选中的购物车商品可以参加的每一种活动的优惠数据，这个优惠数据包含：总金额、总购买数量、满减、折扣的各项数据。
​    最后算出来每一种活动的数据，保存在一个购物车活动列表List集合中，还有就是有些商品可能不参加任何活动，所以再根据购物车商品总的集合减去参加活动的商品集合，求出来没有参加任何活动的商品集合，并且也保存到购物车活动列表List集合中。
   这样我就得到当前购物车商品可以参加哪些活动，以及不参加任何活动的商品数据了。
   然后我就可以遍历这个活动List集合，根据每一种活动的规则以及位于当前活动然后我就可以遍历这个活动List集合，根据每一种活动的规则以及位于当前活动下中的商品进行计算，计算出来每一种活动优惠后的金额计算规则很简单，因为我在上一个步骤中已经知道了每一个活动的规则和参加该活动的商品，所以遍历活动List集合，求出来优惠金额最大的活动信息。
  计算完了促销活动，还有一个购物车可以使用的优惠券的计算流程，实现步骤是
这样的。首先根据用户ID查询优惠券领用表（coupon_use表）同时连接查询优惠券基本信息表（coupon_info），得到用户领取过哪些优惠券的优惠券信息列表List<Couponlnfo>
​       然后拿着当前用户拥有的所有优惠券ID，去查询优惠券规则表（couponrange），查询到当前用户具备的优惠券的使用规则，再然后遍历优惠券使用规则以及购物车中的商品列表，判断每一张购物券能够被哪些商品使用，返回优惠券与当前优惠券可用的商品Sku的Map集合。KEY是优惠券ID，值是商品skuID列表。

  题外话：本来这里计算优惠券和优惠券对应的商品Skuld集合，感觉没必要这么详细，因为我们在讲业务，而不是业务中怎么去遍历怎么写的代码，于是我就删了。但是我把我删掉的内容放在下面家参考一下。

​    接下来就是遍历这个优惠券与商品关系的Map集合，求出来所有可用的优惠列表以及优惠力度最大的优惠券。
​    最后就是统一汇总带优惠券的购物车数据了。
​          我先遍历原版的购物车数据，做了一个加法计算，求出来没有任何优惠的原始购物车商品总金额。
​        然后用原始总金额减去促销活动力度最大的活动优惠金额，再减去可用的最大优惠额度的优惠卷金额，得出来最终金额。
​        最后，将这一切可参加的促销活动、促销活动优惠的金额、可用的优惠券列表最大的优惠券金额、原始购物车总金额、最终优惠后的金额这些数据返回给购物车微服务。购物车微服务将这些优惠数据返回给前端展示就可以了。

#### 17.订单确认：

需求说明：
    首先是在购物车中选择商品，点击立即购买，跳转到生成订单页面。
    在生成订单页面中，填写收货信息，提交订单。
    后端生成订单后，状态为待支付，等待用户进行支付。
    在当前订单生成流程中，要完成的就是根据购物车的商品信息、用户提货信息，生成订单。
​    我们要做的事情是：

1.  对订单进行确认
2. 现价、原价等信息的显示
3. 设置提货人的联系方式
4. 订单的生成操作



正式回答:

-  用户在前端购物车中选中了要购买的商品，点击立即购买，就会向后端发起订单确认请求。
- 在订单确认接口中，首先从Redis中获取到用户关联的团长信息和提货地点信息；
- 然后远程调用购物车微服务，获取用户勾选的购物车中的商品信息；
- 再然后使用雪花算法生成一个用来标识订单的唯一编号，并将该订单编号缓存到Redis当中，时间默认设置为24小时;
- 继续调用购物车微服务，查询当前用户选中的商品的优惠信息；
- 最终封装购物车优惠信息、团长信息以及订单编号信息，返回给前端，展示在小程序端的订单确认页面就可以了。
   如果前端用户在24小时内，没有确认正式提交订单，那么Redis中的订单唯一编号就会自动回收。用户将来再次访问时，重新这个流程就可以了。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4.png)

#### 19.订单生成： *
   题外话：

​            订单生成这个流程还是非常简单的，但是有几道最经典的面试题

   订单重复提交遇到过吗？你是怎么解决订单重复提交？  （经典回答：redis+lua脚本）

  下订单是吧？那库存是怎么锁定与解锁的？  （分布式锁）

  这个操作又是修改库存，又是修改订单，那你这个是跨多个服务远程调用吗？分布式事务怎么解决的？  （分布式事务）
​        

正式回答:
​        前端用户在订单确认页面中，确认收货地址、要结算的商品没有问题后，用户提交生成订单请求到订单微服务。请求参数中包含：订单确认流程中返回的订单编号、收货人姓名、电话、团长ID、用户选择的优惠券ID和参加的活动Id。
​         **1、防重校验**
​              在后端接收到请求进行处理时，首先我先做一个防止重复提交的校验。从请求中获取到订单编号，然后去Redis中核销订单编号，这个步骤我是通过执行原生的lua脚本进行的

```sh
String script="if(redis.call('get'，KEYS[11]） == ARGV[1]  then return "+"redis.cal（'del'，KEYS[1]） else return（  end";
```

lua脚本的意思就是我先get查询一下订单编号在Redis中的数据
- 如果存在，就删掉这个key，返回删除的结果为1；
- 如果不存在， 就返回0；
       然后判断这个结果，如果结果为1就表示正常提交订单，进行后续的正常业务处理；
       如果这个结果为0，就表示重复提交了，已经有一次请求先一步执行了，不能再往后执行这个请求，抛出自定义的重复提交异常，结束请求；

**2、锁定存:**
    如果正常往后执行的话，下一步就是锁定库存了。锁定库存的核心思路就是判断当前商品车存是否能够满足当前买家购物车提交过来的商品数量。锁定库存是由商品微服务实现。
    当前正在处理请求的订单微服务先调用购物车微服务，获取到当前用户购物车中选中的商品数据，确定当前用户要购买哪些商品。
     然后从商品信息中取到库存数据，我们的库存数据是直接保存在了商品sku表当中的，所以需要远程调用商品微服务锁定库存。
    在锁定库存的时候，订单微服务传过来的是一个要锁定的SkuList，代表一个订单有多个商品要同时锁定。所以锁定库存的业务需求是这样的
        一个订单内的商品库存要么一起全部锁定成功，要么全部不锁定
        如果锁定过程中，有一个商品库存不够了，那么就直接反向操作，释放掉已经锁定的同一个订单内的其他商品库存；
     所以在商品微服务处理锁定库存的流程中，先遍历所有的购买商品，挨个锁定每一个商品的库存。

   因为这个锁定商品库存的操作可能会有多个订单请求同时购买同一个商品情况出现，所以在锁定库存的时候，可能出现超卖问题。因为我们将来部署的话肯定是部署多个服务实例，所以加锁控制的时候必须使用分布式锁进行控制，我是采用redisson组件提供的分布式锁功能，将商品skuld作为锁。
   锁定每一个商品的时候，先进行加锁，加锁后再查询库存是否满足当前购买数量，如果满足的话，就锁定库存。
    锁定库存方式很简单，就是在我们的商品sku表中，除了有一个库存字段以外，还有一个锁定库存字段，将要锁定的库存数量增加到锁定库存字段原有的数值中即可。

 ```sh
update sku_info set lock_stock = lock stock +#{skuNum} where id=
 #{skuId}

# update语句执行成功，返回1，代表锁定成功，返回0，代表条件不满足，锁定失败。
 ```

   如果所有商品的库存都锁定成功后，就把商品skuList集合存储到Redis中，key是订单编号，值是skuList集合，为以后解锁或者真正扣减库存做准备。

  如果所有商品的库存都锁定成功后就把商品skuList集合存储到Redis中，key是订单编号，值是skuList集合，为以后解锁或者真正扣减库存做准备。
    如果说在锁定的过程中，有一个商品库存没有锁定成功，那么可能是库存不足，也可能是别的订单先一步进行了锁定。所以遇到这种情况，那么就回滚加锁成功的商品库存，实现思路很简单，就是把当前skulist中已经加锁成功的商品，做一个反向操作，将已经锁定的库存数量进行扣减就可以了。
    然后商品微服务返回加锁的结果给订单微服务，如果锁定失败，直接抛异常，结束流程
    如果锁定成功，就保存订单数据，主要是保存订单基本信息（order_info）和订单项
order item） 到数据库中

#### 3、保存订单：

​    题外话：这块原版课程中写的贼麻烦，有些业务实现博哥不太认可，例如：到这块了还要
计算促销活动和优惠券，包括促销活动原版课程中是可以同时参加多个促销活动，所以这块博哥进行了改造
​    在保存的时候  步骤还是比较麻烦的：

1. 首先是通过远程用用户微服务，得到当前用户的团长信息和提货点信息；

2. 然后就是计算当前购买的商品列表能够参加哪些营销活动和可以使用的优惠券。这里是远程调用了活动微服务的【查询带活动和优惠券的购物车接口】，返回可参加的活动、可使用的优惠券，以及最大优惠力度的活动和优惠券信息。

3. 然后从前端参数中获取到用户是否有手动选择使用的优惠券以及参加的促销活动ID。
    -  如果有的话，就遍历活动列表和优惠券列表，校验当前活动以及优惠券是否存在以及是否可用；
    -  如果没有的话，就直接使用优惠力度最大的活动和优惠力度最大的优惠券
    
4. 然后就是分摊促销活动的优惠：

         -   如果促销活动为满减折扣，则直接遍历所有购买的商品，按照折扣计算出来每一个商品优惠后的金额。
         -  如果促销活动为满减金额，则直接遍历所有购买的商品，商品单价除以订单原始总价，得出占比。占比乘以满减的金额，得出来每一个商品要优惠的价格，再用商品原价减去要优惠的价格，求出来每一个商品优惠后的金额
     
5. 然后就是分摊优惠券的优惠：

      -  判断优惠券的类型，如果是全场通用的优惠券，则直接按照商品单价占总价的占比进行分摊就可以了；
      - 如果优惠券的类型是限定商品分类，则遍历商品，求出来当前订单下，该分类下的商品，将优惠券的优惠分摊到该分类下的商品价格中就可以了；
      - 如果优惠券类型是限定某一个商品，则直接针对该商品进行价格扣减就可以了，需要注意的是，无论任何类型优惠券，优惠后的金额一定是大于0的，如果优惠券金额大于订单总金额，那么可能会出现负数，那就直接按照0元下单就可以了。

6. 最后返回经过优惠后的所有商品的集合，包含：每一个商品原价、优惠后的价格，当前订单使用的促销活动ID以及优惠券Id。

      -  根据这些得到的数据，计算出订单总金额，再按照封装订单基本信息，保存到订单表中；        

      -  遍历计算完毕的订单商品集合，保存到订单项表中；

      -  如果当前订单使用了优惠券，则远程调用活动微服务，将优惠券状态更新为已使用。最后就是从Redis中的用户购物车hash中删掉购买的商品，以及给团长计算佣金这两个操作时放到MQ里面异步实现。

      - 最后返回订单编号给到前端，代表订单生成成功。前端会根据订单编号，向后端发起查询，跳转到订单的支付页面进行支付。这就是订单生成的流程。

         

**课程中的漏洞：**

  - 锁定库存时是直接锁定sku，不区分仓库id，那假设某一个商品在A城市仓库有库存，城市仓库没库存，那请问B城市的买家是否能下单？
         答：不能，因为我们这个仓库补货是统一调度的，仓库有什么，我们就卖什么，不会跨仓库调货，因为这样做的话成本太高了。

  -   追问：那你这个锁定库存的时候，只用skuld锁定库存，合理吗？意思是某一个商品B城市仓库没货，A城市仓库有货，那么就可以继续锁库存然后下单购买？  （原版课程就是直接锁skuld）

        答：您说的这种情况是不可能出现的，因为我们的商品sku在上架或者补货的时候，都是直接绑定的仓库。也就是说，同一件商品，在AB两个城市售卖，上架的是两个sku，分别属于A城市仓库的以及属于B城市仓库的。他们的skuid也不一样，所以在加锁的时候，使用skuld加锁没问题，如果库存不够了，那就只代表着当前城市仓库的库存不够了，不会对其他城市的仓库库存有任何影响。
           您也不用担心这样会不会很麻烦，不会的。因为我们不会有太多的商品，并且每一个城市都有专属的运营经理，他负责当前城市的商品运营，这点事情对他来说根本就不算什么工作量。而且在后台管理系统中，商品详情是可以进行克隆的，就是A城市运营经理上架了一个商品以及商品详情，其他城市的运营经理直接在管理系统中可以一键克隆，铺货到当前城市的商城中。

  - 这个业务中有没有用到异步解耦？

        像订单流程这样经典的问题，必然有很多步骤，有些步骤是强一致性的，例如：锁定库存、生成订单信息、核销优惠券等；
            有些步骤是最终一致性的，例如：删掉购物车中的已购买的商品数据，给团长结算佣金。
           正式回答：订单生成过程中，关于佣金计算、删掉购物车已经购买的商品数据我们进行了异步实现。
           在最后我们是把消息封装成JSON格式数据，放到RabbitMQ当中。然后定义消费者进行消费处理。
           删掉购物车的消费者位于购物车微服务，这个很简单，就是调用redis的hash命令根据key删掉hash中的购物车数据就可以了。
           而团长佣金结算时位于用 微服务中的，消费者监听到消息后进行消费。消费流程是这样的。首先远程调用商品微服务，将购买的商品skuld传过去，查一下商品SKU和佣金比例关系表（佣金流程瞎编的），看一下当初上架的时候，设置的佣金比例是多少。不同的商品，佣金比例是不一样的，这些佣金比例数据是统一计算进行下发的，当运营上架商品后，在审核流程中，上级领导会审核商品数据以及佣金比例的。如果说商品没有设置佣金命令，那么就走默认的分成比例。在团长表中有一个佣金比例字段，这个比例是当初运营经理和团长代理在签订合同的时候，谈的佣金比例，得到佣金比例后，再遍历购买的商品，如果有单独设置佣金比例，就按照单独设置的计算。如
       没有单独设置佣金比例，就按照默认的佣金比例计算。最终得出当前订单交易成功后，能分配给该团长的具体佣金，最后远程调用订单微服务，将佣金更新到订单表中就可Id。

  - 没讲分布式事务，中途异常如何回滚，整个流程中涉及到的修改有：  

       -   订单数据库：插入订单信息、插入订单项信息；
       -   商品数据库：锁定库存，就是对lockStock锁定库存字段进行修改Redis:删除购物车中购买的商品；
       -   订单数据库：使用MQ异步的方式，计算佣金，并修改到订单表的团长佣金字段中；
       -  理论上来讲，按照平常培训机构讲法和小白的认知，认为这几个步骤中，任何一个环节失败都意味着其他的步骤需要回滚，然后又把微服务分布式事务、SeataAT种东西安排上。

       正式回答：

       ​    我们整个流程涉及到的写操作有插入订单数据、插入订单项数据、锁定商品库存、删除Redis中的购买的商品、计算佣金几个步骤。
       ​    其中，删除Redis中购买的商品和计算佣金是异步的形式实现的，在业务上不是强一致性的。
       ​    而插入订单信息、商品数据、锁定库存这几个修改数据库的操作必须保持强一致性。
       ​    所以我设计的时候，我是这样设计的：
       ​       首先，这几个步骤都是发生在订单微服务中的service法中的，所以关于任何一个步骤出错，比如：远程调用商品微服务锁定库存、调用Redis或者发送消息到MQ任何一个步骤出问题，我直接抛出异常，这样就可以将订单微服务中新增的订单数据、订单项数据直接给回滚掉了。
       ​         如果订单业务service方法能够执行完毕，那么每一个步骤肯定是能够正确执行成功，没有问题的，所以订单数据和订单项数据持久化到数据库表中是非常安全的。
       ​       至于说有可能出现远程调用商品微服务，库存锁定了，但是后续的步骤出异常，而商品微服务的库存没法得到释放，这个没关系！因为一旦出异常，订单微服务一定会把最重要的订单数据给回滚掉。然后我们又有定时任务，每隔1分钟扫描一下订单表未支付的订单，统计计算一下每一个未支付的商品购买数量，再将未支付的商品数量更新到库存表的锁定库存字段中就可以了。当然您不用担心性能问题，因为我们这个项目就不是啥并发项目，而且商品数量也不多，这个定时务我特意压测过，以3000件商品+3W比未支付订单场景统计，统计后同步完毕，整个流程不超过2s。

       -   至于删掉Redis中购物车中的购买的商品数据，这个异步解耦，由购物车微服务中的监听器进行实现。这个队列消费者手动ack都不需要开启，因为这个处理比较快，而且几乎不可能出问题，就算出问题无非就是购物车中的数据本次没删掉而已，一点关系都没用。

       -  而异步结算团长佣金就不一样了，这个消费的时候必须手动ack。如果结算过程中出异常，我们默认会进行一次重试，如果重试仍然异常，则直接拒绝消息，丢进死信队列，由人工介入进行结算。人工结算的时候，会从消息中取出来所有的订单购买的商品信息，在后台管理页面中自动计算出来佣金，客服手动提交修改到订单表的佣金字段中就可以了。

          

####   19.订单支付：

   需求说明：
       订单生成后，前端向后端发起查询，查到等待支付的订单数据，展示支付页面。
      点击支付订单按钮,使用微信付款支付。

正式回答
    我们项目中使用的是微信支付-JSAPI，当用户提交订单，生成订单后，前端就会跳转到订单结算页面。用户点击【支付订单】就可以进行支付，支付实现方式是这样的：

##### 1、预付单生成接口流程：

首先请求到达我们后端的支付微服务的预付单生成接口，根据请求参数中携带的订单编号，远程调用订单微服务查一下订单状态是否正确，是否处于待支付状态，如果是的话，就将订单状态改为正在支付中。

并且封装一个订单支付信息对象，设置支付状态为未支付，保存到支付信息表当中然后根据微信支付的下单接口规范，拼接支付相关参数，例如：应用ID、商户号、商品描述、商户的订单号、交易时间、回调地址、用户的openiD等信息吧，向微信支付平台发起远程调用，生成预付单，返回一个prepayld的一个预付单编号，代表本次交易的唯一标识。
备注：微信下单API官方文档`https/pay.weixin.q.comwikidoc/api3/apis/chapier3_5_1.himl`

再然后就是根据预付单编号、appiD、微信支付返回的随机字符串、时间、签名类型等数据,调用微信支付的工具类生成一个支付签名。

最后将这些数据以及支付签名一起返回给前端小程序

前端微信小程序得到后端返回的支付信息后，小程序端本地调用支付微信提供的支付方法，发起微信支付：

1.  首先小程序端携带支付信息，向微信支付平台发起调用，验证支付授权权限，微信支付平台校验没问题，返回支付授权；
2.    然后小程序端就会弹出支付窗口，用户输入密码，并确认支付，再次提交授权到微信支付平台，微信支付平台验证用户的支付信息没有问题，就会进行扣款。
3. ​    微信平台端对用户账户扣款的流程是异步的，就是说，他如果扣款成功，就会异步的通知到我们的后端接口，这个接口是当初生成订单时填写的回调地址。通知我们的后端支付结果，然后我们的后端会保存支付结果到本地数据库，并且返回响应，告诉微信支付平台我们成功接收处理了。
4.    然后微信支付平台还会返回支付结果给到微信小程序，并且以微信消息的形式提醒用户支付结果。

##### 2、 订单支付态查询：

   当然了，因为支付结果是异步的，有可能会因为客种原因，不管是网络延退，还是我们自己的服务问题，都有可能导致微信的第一次回调消息没有收到或者没有确认。所以微信支付也提供了查单接口，查询支付接口，我们可以自己主动调用微信支付平台，根据prepayID查询支付结果，所以我还单独写了一个查询订单支付状态的接口，实现流程也很简单：

-    封装AppiD、 商户ID、订单编号等参数;

-    向微信支付平台发起远程调用，得到返回结果；

-   从返回结果中就可以解析到支付状态，比如：支付成功、支付失败、支付中等状态，再返回给前端就可以了。

-    如果说订单状态为支付成功，那就更新一下订单表和支付信息表的状态以及真正扣减库存，当然这个状态可能已经被微信支付回调接口给更新过了，所以先判断一下支付状态:

   1.   如果支付状态为已支付，那么就不做任何操作。

   2.   如果支付状态为未支付，那么就更新一下支付信息表的状态为已支付。又因为当前服务是支付微服务，而那个订单修改位于订单微服务以及库存修改位于商品微服务，所以这块需要涉及到微服务调用，又因为这个业务流程并非强一致性的需求，所以我就将订单支付成功消息发送到RabbitMQ消息队列中，由订单微服务的消费者监听并修改订单状态，
      以及商品微服务的消费者监听并进行真正的库存扣减。

      

      

#####  3、微信支付平台回调接口：

​                另外就是微信支付完毕后，微信支付平台也会异步的形式调用我预先配置的回调接口，通知到后端服务当前的支付结果，并且我还要按照固定的格式进行应答SUCCESS成功 或者 FAIL失败。
​          微信支付成功，支付通知API官方手册：
​           https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_5.shtml



#### 20.退款流程有做过吗？

官方文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_9.shtm
   退款支付没教过，也不推荐说做个支付功能。

正式回答：
     退款流程大概业务需求是这样的，退款分为两种情况，一种是买家申请退款，退款可以分为仅退款或者退货退款，无论任何一种退款方式总之达到退货条件，就可以进行退款。不管任何退款方式， 都需要经过商户同意后才能执行退款流程
   另一种是我们区域运营经理主动给买家进行退款，出现这种情况的原因可能是

-     因为不可抗因素，导致买家下单的商品没货，或者一笔订单中买了多个商品，其中某一个商品因为某些特殊原因，导致没货了，所以需要区域运营经理亲自给买家打电话解释，并且在运营管理系统中直接给买家退款。
-     也可能是因为促销活动、买家直接电话投诉等各种原因，运营人员或者售后人员可以直接在运营平台给买家进行退款。
        但是话说回来，无论任何业务需求的退款，这个退款流程都是单独的，和业务本身是没有关系的。
   所以，我使用消息队列进行解耦，也就是说，不管啥原因退款，退款的业务只需要确认是否要退款，退多少钱，给谁退钱。
        比如投诉退款、售后退款还是活动退款，这些退款的原因和退款流程没有任何关系，所以我设计了一个退款消息队列，所有的要退款的场景中，统一将：
   - 微信支付订单号
   - 商户订单号       
   - 商户退款单号 
   - 退款原因
   - 退款结果回调URL
   - 退款资金来源
   - 金额信息
   -  退款商品详情
      

      这些数据进行封装，一方面是保存到退款记录表中，另一方面是远程调用微信支付平台，将这些参数进行封装，发送给微信平台，进行退款。
   当微信支付那边退款成功后，就会回调我参数中指定的URL，然后通知到我得支付微服务那么我就修改一下支付信息表的状态以及退款记录表的状态就可以了。
      另外还要发送一套消息到MQ中，由订单微服务的消费者监听，修改订单状态为退款成功或者
订单关闭。
  至于说商品微服务的库存，我们退货是不会影响库存的，不会把库存重新添加回去，因为像我们这种销售的东西，基本上退回来的话，很难直接二次销售，所以需要售后人员重新处理，重新走入库流程，这就是我大概负责的退款业务
当然了，为了防止运营或者售后客服因为各种原因导致退款流程处理不及时，或者售后仓库库管针对退货订单商品处理不及时，导致整个退货流程被延长，我们还编写了多个定时任务去定时扫描待处理的售后以及待入库的售后等任务进行兜底处理。

#### 21.前台会员领取优惠券，会遇到一些什么问题？

题外话：原版课程中是没有的，只是因为他在一开始的时候讲过优惠券管理，以及在后面结算的时候，查询过优惠券。

问题经典：
- 比如优惠券限时秒杀领取

- 优惠券防止超卖情况出现

- 优惠券定时上架管理

- 优惠券如何防止重复领取

-    优惠券如何防止小号批量刷走你的优惠券（打击黄牛/如何识别真实用户）
     
     ①要参加活动用户必须是下过订单的老/新用户
     
     ②要参加活动必须绑定手机号
     
     ③根据IP地址限制领取优惠卷
     
     ④根据地区限制领取优惠卷

正式回答：
   优惠券这块的话是我负责设计完成的。我们项目中的优惠券有全场通用、限定商品SKU专属的优惠券以及限定商品分类专属的优惠券这几个类型。
    然后优惠券领取的话，我们一般是在商品详情页、首页、活动促销页面，或者我们单独设计一个小程序页面，用来在微信朋友圈之间进行转发使用，可以直接在页面中点击领取优惠券等各种方式，也包括后台运营人员可以直接针对某些用户进行赠送优惠券。
    在后台管理系统中新增优惠券的时候，会限定优惠券的发行数量，如果为0的话，就代表不限制发行数量。但是，一定会限制优惠券领取的开始时间与结束时间，以及优惠券使用的开始时间、结束时间。
无论是通过哪种方式领取优惠券，总之在会员领取的优惠券时候，领取流程都是固定的，优惠券领取流程是在活动微服务中实现的，优惠券领取的流程步骤是这样的。

   - 首先判断优惠券状态是否可以领取，从前端请求中，获取到优惠券的ID，查询数据表，判断优惠券领取时间、优惠券状态是否正常。

   - 然后根据UserlD和优惠券ID，查询一下优惠券领用表，判断当前用户是否领取过优惠券，且领取的优惠券仍然在有效期内，如果是的话，就不能重复领取！

   - 然后校验用户是否具备领取优惠券的资格。我们设计优惠券的时候，设计了一个**优惠券的领取规则表**，这个规则表和优惠券主表是多对一的关系，通过外键关联优惠券的主键ID实现的。在后台管理系统中上架优惠券的时候可选的方式设计优惠券的规则，比如说可以设置

     1.    限定优惠券只能是新用户领取

     2.    限定优惠券只能是注册满指定天数的用户领取

     3.    限定优惠券必须是某些区域（校园）的用户进行领取

     4.    限定优惠券必须是绑定手机号以后才能领取
        并且这个优惠卷的规则可以动态的调整，新增或者减少、用户在领取优惠券的时候，有些优惠券活动力度比较大，并且限制发行的数量。所以为了防止有些非法的操作，例如有人恶意批量开小号刷优惠券接口，导致真实买家领不到优惠券，恶意账户各种羊毛的情况出现。所以，针对不同的优惠券在领取的过程中需要针对用户的资格进行校验。
             简单来说就是根据 优惠券ID 查询 优惠券规则表，取出来当前优惠券对应的规则，因为这个操作在优惠券秒杀的场景中，会涉及到并发，影响DB的服务器性能，并且优惠券规则属于读多写少的数据，于是我就使用Redis进行了缓存，优惠券ID作为Key，优惠券对应的领取规则作为值。
             如果当前领取的优惠券，没有设置任何规则，返回规则size为0，则直接默认为任何人都可以领取。
             遍历当前正在领取的优惠券规则，在每次循环中，判断当前用户是否满足某一条规则。如果满足，则直接返回true，代表可以领取。如果循环遍历完毕，没有任何一条规则符合当前用户，那就返回false，代表当前用户不可以领取，通知到前端“您不能领取该优惠券”。
             因为每一种优惠券领取规则的业务逻辑是不一样的，所以不能硬编码的方式写在代码中我是单独设计了一个规则校验接口，定义了规则校验方法。然后针对每一种校验规则，封装了一个子类，子类重写校验规则方法，根据当前子类的校验规则，例如：注册时间满多少天、是否是新用户等，编写不同子类的校验规则，进行调用。

         如果当前用户满足领取优惠券的资格，那么就进入到优惠券领取流程。
            然后判断优惠券是否有限制数量,如果没有限制发行的数量，并且库存充足的情况下，直接领取。

        ​    如果有限制发行的数量，且有库存数低于100的情况下，那就使用分布式锁进行控制领取优惠券的流程。 ==注意：分布式锁是强制排序，影响性能。==
        ​    我是使用Redisson进行加锁控制，优惠券id作为锁加锁以后，再查一下库存，如果优惠券的库存大于零，再写入couponuse优惠券领取记
        录表，以及修改优惠券表的剩余库存。
        ​    然后再释放锁。这就是大概获取优惠券领取流程。
        ​    另外就是还有一个优惠券定时上架与下架。这个是在后台录入优惠券信息的时候，填写的。然后我是通过定时任务，扫描优惠券表，条件就是根据优惠券发行时间字段以及优惠券的状态，判断一下时间到了，但是状态为等待发布状态的优惠券信息。然后将其状态修改为发布状态。同样道理，定时下架也一样，根据结束时间字段以及优惠券状态字段进行判断，如果到时间可以下线了，就将优惠券的状态字段改为已结束。

        

#### 如果面试官问高并发问题，万级QPS之类的问题。

回答的核心思想

1.    限流，应对突发并发流量，限流是一定的

2.    熔断，做好熔断，做好服务降级；

3.    解耦，非强一致性的步骤，比如：我只需要锁定库存，确定某一个用户抢到了，剩余的步都可以使用异步的方式进行解耦。
      又或者我使用redis的string类型声明一个库存量，每次秒杀过来，库存量decr递减1如果递减成功，证明用户抢到了，直接将剩余步骤丢到mg中异步解耦。

   ==像这种秒杀、高并发问题，没有固定答案。==
   只要能够解决问题，思路上没问题就行。
   如果实在不知道说，你就这样说
       我们这种项目根本就不可能有高并发，即便满世界的去无条件赠送优惠券，都不太可能吸引到高并发请求，所以QPS高峰期到1000都很难
       但是我自己也琢磨过一些思路，就是要做好限流、熔断、解耦等操作。






防止超领优惠卷问题：限流



加分布式锁，



## 大学课堂项目：

![img](D:/StudyViden/Java/%25E9%25A1%25B9%25E7%259B%25AE/%25E7%25A1%2585%25E8%25B0%25B7%25E8%25AF%25BE%25E5%25A0%2582/%25E7%25AC%2594%25E8%25AE%25B0/images/%25E5%258A%259F%25E8%2583%25BD%25E6%259E%25B6%25E6%259E%2584%25E5%259B%25BE.png)

1.  
2. 项目中使用了很多Api接口，像微信公众号导航栏啊、微信登录、微信支付、欢拓云直播接口，学习到了怎么对接



微信，首次使用微信公众会判断是否是新人，





## 权限盒子项目：

1、每个系统权限管理，他们的核心流程都是差不多的，如果每个后台单独开发一套权限管理系统，不仅很浪费时间和人力，所以权限盒子就是为了解决这个客户问题的，为他们提供了一套通用的权限解决方案。

​      大学的时候写了几个项目，发送每个项目都有权限管理模块，为了解决。

路径：http://139.198.152.148:8810/

   AOP是**在不惊动(改动)原有设计(代码)**的前提下对其功能进行增强。

1. 用户管理
2. 角色管理
3. 菜单管理
4. 权限管理
5. 岗位管理
6. 日志管理   ①操作日志  ②登录日志



## 树形结构：



# 企业做项目流程：

需求分析 => 设计(概要设计、详细设计) ==》技术选型 ==》初始化/引入需要的技术 ==》写Demo ==>写代码（实现业务逻辑） =》测试（单元测试等）`==》`代码评审 ==》部署 ==》发布。

# 简历篇：

   以下都是基于尚上优先项目编的。

## 应届生/实习生:

题外话：在校大学生我们就按照毕业设计、校内工作室项目进行包装
思路：包装一个校园创业项目
        校园创业项目，一定是轻资产项目，不可能自己搭建仓库以及维护配送、售后等重资产需求，所以采用合作的方式，有很多大型商超合作，由他们供货、配送、协商售后，虽然说利润一定会下降，但是非常符合轻资产创业项目，我们相当于搭建了一个运营平台，这样包装才真实，不然你们这些学校的小屁孩上哪儿搞那么多商品？你们哪儿有钱积物资？对不对。

- 校园项目就不整微服务，直接SpringBoot单体项目。
- 项目人员配比我写的比较多，因为大家还在上学，不可能有大把的时间完全对标实际工作情况。另外如果面试官问开发周期的话：做了4个月就上线了，并且维护了有半年，半年不断升级和选代，再往后的话我已经毕业了，由学弟们继续维护。
- 运营一些商城，必定需要营业执照等资料，所以就说导师给注册的。
- 合作的供应商你们自己在boss直聘、百度、天眼查找一个你们当地有名的供应链、商超之类的配送商合作就行了，实在找不到你编一个；

**项目介绍：**
   本项目为学院工作室项目，曾参与青创大赛选拔。后改造为工作室团队创业项目并以导师的公司进行汪册，开甲请下采创业激励资金，用于购买服务器以及开发成本。
   目前真实上线运营且处于较为稳定的运营规模并由专业的运营团队向周边高校进行推广。
   随着大学生活水平的提高，校园零食市场需求逐渐增加。然而传统的校园零食销售模式存在货品单一、价格断且昂贵、服务不规范、经营理念老旧（靠校园物业关系断销售）与大学生脱节等问题。
   本项目属于轻资产创业项目，与XX商超供应链达成合作，供应链提供商品与配送服务。由我方负责校园运营，围绕x供应链进行选品并上架，并以周为单位进行订单结算与利润核算。
==备注：面试的时候，给面试官吹牛逼，说这个项目做完后，参加完毕比赛，受到学校书记的支持，单独分了两间工作室用于办公和配送服务。项目真实落地，项目的启动资金也是学院向学交请了十几个W，目前每月订单在五千比以上。==
**核心业务：**
    后台管理系统：用户管理、商品管理、类目管理、订单管理、==供应链管理==、活动管理、优惠券管理、订单结算、==运营数据大屏展示、售后管理、商家渠道合作（瞎编的）==；
    校园代理终端：团购发起、物资清点管理、收益结算、售后处理、上门配送管理
    前台用户小程序端：微信登录、商品检索与查询、购物车、活动模块、个人中心；

**技术架构：**
   项目采用SpringBoot单体技术架构开发，结合MybatisPlus、 Redis、RabbitMQ、Elasticsearch、OSS、MySQL、Nginx、Vue/Vuecli、ELementul、微信小程序、高德电子地图围栏；

工作室人员配比：Java（6人）、前端（2人）、小程序（1人）、测试（1人）、客服&运营（2人）、兼职配送（若干）
岗位职责：
    负责项目创意设计、项目规划、核心业务拆解、项目立项
    负责项目技术架构、技术选型工作；
    与工作室其他小伙伴合理的分配工作任务，共同推进项目的落地
    负责后台系统：用户管理、商品管理、类目管理、优惠券管理、商家渠道合作等模块的开发；
     负责前台系统：微信登录、商品检索、购物车、订单下单与微信支付功能实现
     负责项目的上线，解决线上的问题，并不断优化和升级项目业务

**技术亮点：**
    使用Redis作为缓存组件，缓存了用户登录的状态信息、分类信息、活动数据、订单临时编号等数据;
    使用Redis设计了购物车模块，将用户的购物车数据使用Redis Hash进行保存，并设置Redis开启AOF持久化，以每秒频率进行持久化
    搭建ElasticSearch实现全文检索，设计了订单索引、商品索引、日志索引
    设计订单生成、商品上下架、用户浏览商品等业务模块时，针对非强一致性业务需求使用RabbitMQ进行解耦异步实现
    使用Redis+Spring Schedule定时任务实现用户行为数据采集，计算商品热度数据，并定时更到ElasticSearch，实现爆款商品的检索计算。
    项目引入了微信登录，前端调用wx.login(），后端通过 OAuth2.0 的形式交换到微信的Openld，实现三方认证，简化了传统的登录认证方式；
    在设计上门配送模块中，使用高德电子地图围栏，划定校园配送的范围、楼栋，通过调用高德开发者API，计算当前买家所在经纬度是否位于限定的配送区域。



## 1~3年经验 （初中级开发）：

   思路1：包装自研项目，依托于公司自有的供应链和食品渠道为合作方提供运营支持，公司为B2B2C运营模式（公司、校园代理商、学生买家），这种模式就是完全走校园版的拼夕夕买菜模式；
   思路2：包装外包公司，适合你不想一年跳一次槽，又不想在一家公司两三年只写一个项目你在这家外包公司写了很多项目，最近半年是做这个校园优选项目。
不管是哪方式，项目的介绍是一样的，
**项目介绍**
   食小仙校园优选供应链系统，随着大学生活水平的提高，校园零食市场需求逐渐增加。然而传统的校园零食销售模式存在着货品单一、价格断且昂贵、服务不规范、经营理念老旧（靠校园物业关系断销售）与大学生脱节等问题。
    食小仙致力于打造更适合年轻人喜爱的校园优选配送平台，依托于公司多年线下沉淀的供应渠道，为年轻人提供更优惠、商品种类更丰富、更好的购物服务以及更有乐趣的购物玩法项目核心为供应链合，打通公司自有的多种商品渠道与线上营销系统、物资配送服务全流程。集售前、售中、售后作业一站式聚合，真正实现一站式规范运营，一切作业流程标准化流程化。
    一流企业做标准，后续会基于本平台孵化不同的创业品牌、合作不同的创业项目。
**核心业务：**
    供应链平台管理端：渠道管理、商品管理、质量标准&参数管理、订单管理、合作商管理、优惠券管理、供应链结算、代理商结算、数据统计模块、售后管理、库房管理（ERP）、渠道线索管理（CRM）
   代理端：团购管理、物资清点&配送、收益结算、售后处理、意见反馈
   买家端（微信小程序）：微信登录、微信支付、商品检索、商品详情、购物车模块、订单模块、个人中心、售后申请、优惠券&促销活动。
**技术架构：**
    项目采用微服务技术架构，围绕业务需求拆分20+以上微服务，采用SpringCloud Alibaba系列微服务组件进行落地实现，组件包含：Nacos、Sentinel、SKyWalking、OpenFeign、Ribbon；
    业务微服务：SpringBoot、MybatisPlus、Redis、RabbitMQ、Kafka、ElasticSearch、Minlo、MySQL、Nginx、Vue/ueCli、ELementul、微信小程序；

**岗位职责：**
      从0~1全程参与项目的开发与落地，参与需求研讨、项目立项、核心业务拆解
      承担后端Java小组长角色，合理安排小伙伴工作任务的分配，共同推进项目的落地负责后台相关业务：渠道管理、用户管理、商品管理、类目管理、优惠券管理、抽奖活动等业务的开发；
       负责前台相关业务：团购发起、微信登录、商品检索、购物车、订单下单与微信支付功能实现；
     负责商品推荐系统设计：商品热度统计、用户行为统计、用户感兴趣商品推荐需求的设计与实现
      负责项目的上线，解决线上的问题，并不断优化和升级项目业务；
技术亮点：
      使用Redis作为缓存组件，缓存了用户登录的状态信息、分类信息、活动数据、订单临时编号等数据
      使用Redis ZSet设计用户行为限流、BitMap设计用户打卡、RedisHash保存用户购物车等业务流程，并设置Redis开启AOF持久化，以每秒频率进行持久化；
       采用Elasticsearch实现全文检索，设计了订单索引、商城商品索引、渠道商品索引、线索信息索引；并搭建GrayLog日志平台，聚合微服务业务日志检索；
     针对CRM线索回访、售后订单处理、订单生成、商品上下架、用户浏览商品等非强

一致性业务需求使用RabbitMQ异步实现，削峰填谷。
       用Kafka中间件缓存用户行为数据采集、系统日志采集等较高并发、大数据量场景数据存储；
       设计商品热度计算流程，使用定时计算+实时计算共同实现
       定时计算：Redis+XXL-JOB，每日零点针对用户商品行为数据进行统计计算
     实时计算：使用KafkaStream针对实时产生的热度数据进行计算，并更新到
ElasticSearch中实现爆款商品检索。
       使用Kafka Stream实时计算，统计每一个用户的浏览记录、商品检索关键字，并生成用户标签。在商品推荐栏目中根据用户标签反向匹配商品，为用户推荐他可能感兴趣的商品
​      项目引入了微信登录，前端调用wx.login，后端通过OAuth2.0的形式交换到微信的Openld，实现三方认证，简化了传统的登录认证方式。
​     合理的设计限流规则，包含：Sentinel微服务限流、Redis用户行为限流、WAF云盾全方位保护系统的安全可靠性。

## 3~5年经验（高级开发）：

  只有职责不一样，其他跟1~3年的都一样。

**岗位职责：**
        0~1全程参与项目的开发与落地，组织需求研讨、项目立项、核心业务拆解、技术评审等架构与项目管理工作；
       负责后端开发组团队组建，管理20人后端开发团队，完成人员招聘与培训
       承担后端Java项目经理角色，合理安排小伙伴工作任务的分配，共同推进项目的落地规划整体项目的结构，数据库模型设计、业务微服务拆解，技术难点解决方案
       设计可靠的项目架构、保障项目的稳定运行，做好服务监控，以及各种应对突发情况的手段措施。

