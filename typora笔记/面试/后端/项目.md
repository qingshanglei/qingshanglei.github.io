





  介绍完项目一般从：项目流程或技术(项目中ES和MQ了，那些场景使用的)亮点入手。

## 食界通小程序：

项目介绍：
    项目主要是一个面向大学生的团购平台。项目主要在高校经营的快递驿站或合作的校园驿站、便利超市、水果摊等为基础，小程序主要经营的鲜花、水果、饮料、面包等快速消费品。
   解决了校园零食市场需求逐渐增加。然而传统的校园零食销售模式存在货品单一、价格昂贵、服务不规范、经营理念老旧（靠校园物业关系垄断销售）与大学生脱节等问题。
   主要要负责 权限模块、区域管理、商品信息管理、营销活动 (小程序用户登录、首页模块、商品分类、商品检索、商品详情页展示、购物车模块、订单支付)等接口开发。 
  主要使用 SpringBoot、SpringCloud、MybatisPlus、Redis、 RabbitMQ、Elasticsearch、OSS、MySQL等。
   后台管理系统：用户管理、商品管理、类目管理、订单管理、==供应链管理==、活动管理、优惠券管理、订单结算、==运营数据大屏展示、售后管理、商家渠道合作（瞎编的）==；
    前台用户小程序端：微信登录、商品检索与查询、购物车、活动模块、个人中心；



## 大学课堂：

项目介绍：

1.   这个项目主要面向学生群体以及那些有学习需求但时间较少的用户。
2.   解决了疫情期间校园：

- 疫情期间上课难：由于疫情的影响，很多学生无法到教室上课。因此，大学课堂公众号提供了在线课程和直播课堂，让学生可以在家中学习。
- 学习资源不足：由于学生人数众多，很多学生无法获得优质的学习资源。大学课堂公众号提供了各种学习资料，帮助学生更好地学习。
- 缺乏学习动力：由于缺乏学习动力，很多学生无法坚持学习。大学课堂公众号提供了各种互动活动和奖励机制，可以激励学生学习。

​    主要要负责 商品信息、营销活动、直播微服务、课堂资料

1. 课程微服务：大学课堂公众号可以提供各种在线课程，主要包括计算机、英语、数学、物理等学科。这些课程都由专业的教师录制，可以满足不同学科的需求。
2. 直播微服务：大学课堂公众号还可以提供直播课堂，让学生可以和老师进行实时互动，及时解决问题。
3. 课堂资料：大学课堂公众号还会提供各种学习资料，包括PPT、教学视频、题目解析等，可以帮助学生更好地学习。
   ​     (公众号用户登录、商品分类、商品检索、商品详情页展示、购物车模块、订单支付)等接口开发。



## 登录流程：

1. 用户打开微信小程序，并进入登录页面。此时，小程序会展示登录页面，并显示“微信登录”按钮。
2. 用户点击“微信登录”按钮，这会触发一个登录事件。小程序会调用wx.login()接口，向微信服务器发送登录凭证请求。
3. 微信服务器返回一个登录凭证code给小程序。这个code就是用户登录的凭证，它将被用于后续的验证过程。
4. 小程序将获取到的code发送给开发者后台服务器。开发者后台服务器收到code后，使用微信提供的AppID和AppSecret等信息，调用微信开放平台的登录凭证校验接口，验证code的有效性。
5. 微信开放平台返回验证结果，包括用户的唯一标识openid和会话密钥session_key。开发者后台服务器将用户的openid和session_key存储在会话中，用于后续的用户身份验证和数据访问。
6. 开发者后台服务器生成一个自定义的用户身份标识(例如用户ID)，并将这个标识返回给小程序前端。
7. 小程序前端接收到用户身份标识后，将其存储在本地缓存或本地存储中，用于后续的用户身份验证和接口访问。
8. 用户登录成功后，小程序前端根据业务需求，可能会进行页面跳转，例如跳转到主页或其他需要登录才能访问的页面。
9. 在后续的使用中，小程序前端可以在接口请求中携带用户身份标识(例如token)来进行身份验证。开发者后台服务器通过验证用户身份标识来确认用户的合法性，并返回相应的数据给小程序前端。









## 食界通小程序（B2B2C）：

### 常识：

#### 1．请介绍一下你最近做的这个项目吧？

  食界通是一套面向大学生的团购优选平台。本项目主要在高校经营的快递驿站或合作的校园驿站、便利超市、水果摊等为基础，面向校园大学生群体精细化运营，打造垂直化的电商、社交平台。

项目平台：

- 公司运营平台：仓储、配送调度、供应链、结算、订单管理、营销中心。
- 团长终端：团购发起、物资清单分拣、收益结算、售后处理。
- 用户小程序终端：搜索、购物车、订单、用户中心、活动。

技术架构：
   项目基于微服务技术架构，主要以Alibaba 系列微服务组件进行构建，围绕业务拆分需求，每一块业务对应一个微服务，例如：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务。
   项目中用到的其他技术栈也挺多的，比如：SpringBoot、MybatisPlus、Redis、 RabbitMQ、Elasticsearch、OSS、MySQL、Nginx等等。

岗位职责：
   我在这个主要承担Java后端开发，算是一个核心人员吧，因为我刚入职的时候，这个项目才刚开始，所以我也算老员工了。有的时候也会帮助新同事快速适应这个项目的技术栈。到项目后期，我也会指导一下实习生，帮忙写一写接口文档和使用手册。
    这个项目怎么说呢，我们对于工作划分没有那么细致，每一个业务模块我都有所参与。我比较熟悉的模块比如：权限管理模块、商品模块、订单模块、购物车模块、搜索模块是我主要负责完成的。

这就是我最近这个项目的大致情况。



#### 2．说一下你们项目的数据库表是怎么设计的吧，分了几个库和表，你负责设计过哪些数据表？

  数据库设计是在项目初期阶段完成的。当时我们先确立了基本需求以及采用微服务技术架构后，围绕业务设计数据库表结构。

  我们一共分了设计了6个数据库，分别是：权限管理、活动、订单、商品、系统管理、用户管理这6个数据库。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E6%95%B0%E6%8D%AE%E5%BA%93.png)

  我当时主要负责权限管理、商品管理、订单管理相关的数据模型设计，当然不全是我一个人说了算，这些数据表设计完成后，是需要开会评审的，经过项目经理审核通过才能使用。

  我设计数据模型的思路就是，围绕业务进行设计。

  首先我们是拆分出来有哪些业务模块，优先梳理出核心业务，围绕核心业务进行设计数据表，这部分工作主要是产品经理完成的，他会给出初版的需求文档。然后我围绕我负责的几个模块，分析相关的业务流程，每一个流程的业务涉及到哪些实体，整个业务流程围绕这几个实体是怎么运转的，当我把这些想明白后，我直接使用 **PowerDesigner**(破我滴晒呢)绘制物理数据模型，就是ER图。评审的时候，就是围绕ER图进行讨论，审核通过，就导出数据库的建表语句进行开发。
  我设计的权限相关的数据表有：管理员表、角色表、权限表、管理员角色中间表、角色权限中间表、后台用户登录日志表。

   订单数据库相关的表：购物车表、订单配送表、订单表、订单项信息表、订单操作日志记录表、订单退货申请表、退货原因表表、订单设置表、支付信息表、退款信息表

  商品管理数据库相关的表：商品属性表、属性分组表、三级分类表、商品评价表、商品评价回复表、sku表、sku属性表、sku详情表、sku图片表、sku海报表、sku的库存历史记录。

   备注：回答一半就行了。

  这些数据表其实也是随着业务需求不断改变的，我们项目是以月度为单位下发需求的，有的时候需求变动了，多少会改一些数据库字段、新增一两张数据库。

#### 项目整体技术架构给我介绍一下？

​      ==注意：别直接回复我们项目中用的了SpringCloud Alibaba、Nacos、OpenFeign等技术。 没多大的意义,最好结合项目业务来讲。==

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%842.png)

  我们项目基于微服务技术架构，围绕业务拆分了十个核心的业务微服务，分别是：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务
    项目前后端分离开发和部署。前端分了平台运营管理、会员小程序端、团长端三个终端当前端请求后端时，首先经过网关层。网关这边我们设置了两层网关
    首先是使用Nginx搭建入口网关，我们采用主备的方式搭建的，保障Nginx的高可用我们把前端项目和前端的静态资源部署在Nginx，当请求过来后，直接从Nginx服务器返回。
    如果是动态请求，Nginx服务器会转发给Gateway网关微服务，网关这边我们设计了灰度发布、登录状态校验等全局过器
    Gateway网关微服务会从Nacos中拉取服务列表，按照配置的路由规则转发给后面的业务微服务，默认规则是轮询。
    微服务相关的组件我们用到了：Nacos、OpenFeign、Sentinel、SkyWalking、Seata等微服务组件。
    另外在业务设计的时候，也会用到一些中间件或者第三方服务，比如：阿里云的OSS对象存储、基于Redisson实现的分布式锁、使用Redis作为缓存组件、RabbitMQ消息队列满足一些非强一致性和服务解耦的场景、使用ElasticSearch设计搜索服务，并且基于ELK技术栈搭建日志收集平台等等
    而像业务微服务中的开发，还是以SpringBoot、MybatisPlus、MySQL、Redis这些基本的开发技术作为主要实现
    日常工作中也用到了PostMan、Knife4、JMeter等开发工具
    别的话也没什么了，还有就是交付的时候，我们使用Jenkins做了整合，实现自动构建Docker镜像、自动部署
    我们是提前编写好Jenkins脚本，需要的时候只需要在JenkinsWeb页面中操作，一键部署项目。

#### 4.大概介绍一下这个项目的工程结构吧，说一说为什么这么设计？

​    此方法不常问。

 实体类模块，保存了实体类和, VO（参数传递封装类）,枚举类。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png)

我们项目采用前后端分类设计开发，我们后端工程只编写后端代码。使用Maven管理整个项目。
    首先，在父工程pom文件中统一管理依赖，锁定依赖的版本号，避免版本号冲突的问题，并且聚合所有的子工程
     然后创建service()工程，工程类型为pom格式，也是用来聚合所有的业务微服务，并统一管理了所有业务微服务的通用依赖，例如：web场景启动器、MybatisPlus场景启动器、MySQL、Nacos、Sentinel、OpenFeign等等。这样每一个业务微服务只需要继承父工程后就自动拥有了这些依赖，不用重复导入了。
    在实际开发过程中，总有一些工具类需要在多个工程中重复使用，所以我们又创建了common工程，用来存放一些封装的工具类，比如：字符串处理相关、RabbitMQ、Redis等相关的工具类
    还有就是为了方便微服务之间的调用，我们单独创建了一个service-client工程，用来保存每一个业务微服务对外提供服务的Feign接口，一个业务微服务相关的Feign接口，在一个service-client的子工程中。
    因为微服务调用的时候，一些实体类需要在双方微服务之间传递，所以创建了model工程，统一管理了所有的V0、实体类、枚举类等。
      最后还有一个网关微服务，请求到后端后，先由网关微服务处理，网关微服务根据预先配置的路由规则，路由到业务微服务中对请求进行处理

### 业务篇：

#### 5.介绍一下你们项目中的权限管理模块吧

题外话：课程中讲的这块权限管理太简单，就是：用户、角色、权限的CRUD以及一个菜单列表的递归查询，如果就这样给面试官说的话，说不出来什么花样来。思路如下：
   后台管理系统是面向公司运营人员的，前台是面向普通用户的，我们这里做的是后台管理系统的权限控制，和前台项目面向普通用户的客户端没有任何关系这一点一定要分清楚啊！
   单独设计权限微服务负责后台系统的权限模块
   权限管理采用SpringSecurity进行控制
   前端要体现不同权限的用户，展示的菜单项是不一样的。
正式回答
    我们项目的平台运营管理端是面向于平台运营人员、管理人员、审核、物资配送、客服等不同岗位的人员进行使用。所以这是一个权限比较复杂的管理系统，我们设计了一个独立的权限微服务实现权限控制
    不同岗位的账户登录到系统后，看到的菜单项是不一样的，这是因为他们具备的权限不一样。
    我们关于平台运营管理平台的权限微服务，是采用SpringSecurity权限框架+RBAC模型普通用户没有这个权限，平台管理员权限最高。

​    不同岗位的账户登录到系统后，看到的菜单项是不一样的，这是因为他们具备的权限不一样。
​     我们关于平台运营管理平台的权限微服务，是采用SpringSecurity权限框架+RBAC模型实现的。不同岗位的用户，具备的角色是不一样的，能够在管理系统中看到的菜单项自然也是不一样的。
​          角色和菜单的关联关系，是由管理员进行维护的
​       这个权限管理相关的模块有：**角色管理、用户管理、菜单管理**几个模块
​       后台管理系统我们是不对外提供注册的，如果有新的团长、司机、平台运营等新人加入是由直属领导也就是对应的部门经理为其分配新的账号。
​      用户在管理平台首次登录是需要重置密码的，用户登录成功后，会把用户信息、权限信息是存储在Session中，当然，这个Session我们使用SpringSession进行整合，将用户登录信息存储在Redis当中，实现了分布式会话。
​       另外还会返回前端一个UUID的Token，作为用户的唯一标识，前端会保存在本地Cookie后续访问时，在请求头中携带该Cookie，后端根据这个Cookie校验用户的登录状态以及权限信息。
​     后续用户在访问项目资源时，由SpringSecurity完成授权操作，它会校验用户所具备的权限是否满当前正在访问的资源需要的权限
​     另外就是用户每次登录成功后，前端都会自动请求后端，查询当前用户能够访问的菜单列表，并缓存到前端本地Cookie。当用户退出登录或者关闭浏览器，Cookie数据自动失效。用户下次登录重新查询。
​    而前端会根据查询到的用户菜单列表，在页面的左侧菜单列表中进行展示。
​    还有一点和权限相关的，就是前端每次请求时，会在请求头中携带用户Token，请求到达网关微服务，网关微服务校验如果请求头中没有携带用户Token，且当前请求不是和登录相关的请求，就会直接拒绝访问，前端重定向到登录页面进行登录。



#### 6.区域管理模块：

题外话：
     区域管理在课程中只是基本的CRUD功能，所以在讲解类似这种特别单的CRUD案例时，大家不结合实际业务场景，给面试官去吹。
     另外就是课程中讲解的区域覆盖全国，但是我不想把公司经营规模说这么大，毕竟我们是包装简历，不要吹的太大。可以改一下，比如把全国改为全省，把区域改为校园
    例如：
         上家公司主营XX省内的业务，在省内招了很多代理（团长），精细化的去营销上家公司主营高校业务，在省内各大高校招了很多代理（团长），针对大学生打造垂直领域的精准营销。
说实话，这个流程真的太简单，主要是课程中讲过，所以博哥这里才都列出来。如果面试的时候，面试官不问，你就不用主动讲这个特别简单的CRUD模块了。

正式回答，可以把区域改为校园
    我们公司目前在全省30多所大学校园中都发展了代理，每一个校级代理针对他所在校园进行运营。
    首先我们会录入全省的所有高校的校园信息。
    每当运营发展了-新的校园代理后，会为这个校园开通运营权限。
    开通校园运营权限流包含：录入代理商的各项信息（基本信息、银行账号等）、绑定校园与仓库的关联关系我们公司在每一个开通运营的城市中，都搭建了一个仓库，校园需要和仓库进行绑定后续每天商品的配送，都是由校园绑定的仓库发出的
    而用户在小程序端登录以后，必须先选择他所在校园，如果他所选的城市或校园没有开通运营，则无法使用，会提示用户尚未开通。
    在我设计这块业务的时候，我设计了4张表，分别是：校园代理商信息表（我临时编的）、校园表、仓库表、校园仓库关联表来保存代理商、校园和仓库的关联关系
    编写过的相关业务流程有：校园信息的管理流程、仓库信息的管理流程，以及校园区域开通流程和取消流程
    其中，校园信息和仓库信息管理都是基本的增删改查。比较复杂的是，在校园区域开通流程中，就是判断当前校园是否已经有代理商、当前城市是否开通了该业务。如果当前城市开通了该业务，并且该校园之前没有入住过代理商，那么就保存校园和仓库的关联关系，代表该校园业务开通成功。

```sh
3、Redis
  ①用户登录微信小程序后，使用String类型存放当前用户信息
  ②首页数据的爆款商品，使用zset类型存储商品信息
  ③当前用户的购物车信息，使用hash类型存储
  ④生产订单，商品锁定库存和其他信息
4、Redisson(分布式锁)
   ①生成订单，使用分布式锁，锁定商品库存
5、RabbitMQ
  ①上下架商品
  ②生成订单后，使用RabbitMQ删除当前用户的购物车信息
  ③支付完成后，根据订单号更新订单的状态(改为待发货)和库存（减库存）
6、ElasticsEarch(ES)
  ①使用SpringData简化ES索引库的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。
  ②ES存储商品上下架信息 和10件热销产品,来提高用户查询的速度。
  ③点击查看商品信息，使用Redis的Zset类型存储当前商品的Id,判断除以10等于零后添加到索引库中；可以减少索引库中的数据量，提高索引库的查询效率。
```





#### 7.商品信息管理模块

​    关于商品管理，我们是拆分了一个单独的商品微服务实现的，主要围绕商品相关的业务设计包含：商品分类、平台属性、平台属性分组、商品SKU信息、商品评价与回复这些相关的业务流程。
  关于这些业务流程都是我做的，需要我个给您介绍一下嘛
备注：一般到这个时候，面试官就两个选择：1、可以，你挑重点的说一下；2、不用，你把XX流程说一下。

##### 7.1商品分类管理流程：

   商性分组商品分类这块我们大概分了十几个一级商品类目，因为我们经营的商品类目大多以快消品为主，相对来说比较垂直 所以商品品类不会太多，只设计了一级分类就足够用了。比如说水果、海鲜、冻品、乳品烘焙、面包蛋糕、休闲流式、鲜花宠物之类的。

   分类管理相关流程比较简单，必须是具备管理员权限的账户登录进来，可以针对商品分类进行管理，商品分类字段就是主键id、商品分类名称、分类图片、分类状态以及排序顺序这么几个字段。          

   类似拼多多的首页分类那样：                                                                                                                   ![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86.png)

#####  7.2商品属性和属性分组流程：

​     每一个商品都有很多属性，为了便于管理商品属性，我们针对属性进行了分组
​     每一个属性分组对应某一类型的商品，例如：生鲜水果、速冻食品。
​     然后就是商品和属性分组的绑定关系为一对一，可以在商品SKU管理中进行设置
​      而属性和属性分组的关系是多对一，业务流程是这样的，首先创建属性分组，在属性分组列表中，可以点击添加属性，为当前属性分组添加多个属性。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%88%86%E7%BB%84%E6%B5%81%E7%A8%8B.png)

保存的时候使用两张表进行保存，分别是属性分组表和属性表
保存商品属性的时候,通过外检列，关联属性分组表的数据记录。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E5%88%86%E7%BB%84%E6%B5%81%E7%A8%8B2.png)



##### 7.3商品SKU管理流程:

题外话： 商品SKU管理流程中,这里最多加一个防重提交的验证。
     在我们项目中，没有SPU的概念，直接就是SKU。因为我们的商品其实都是提前打包或者分类好的，也不存在一个商品要区分不同的购买选择，包括详情页介绍也是非常简单的，因为我们卖的大多都是快消品，而且顾客在我们这里购买，也不会有太多的分类要求
    例如：我们把西瓜按照8-10斤，10-12斤这种方式分类，然后按个卖。或者苹果、香蕉按照斤来卖，提前分好斤数并塑封包装好。包括像酸奶、面包、零食等等，也都是按照个或盒的形式进行售卖，买家如果想要购买多个，只需要填写不同的数量就可以了。
    所以在后台运营上架商品的时候，直接填写单个SKU的信息就可以了。
    在上传商品SKU的时候，使用SKU基本信息表、详情表、图片表、海报图片表、SKU属性值表5张表进行保存。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81SKu%E8%A1%A8.png)

在填写商品详情时，前端使用富文本编辑器进行编辑,将编辑完毕的商品详情，在前端转为HTML代码，保存在商品详情表中。
     当选择了商品关联属性分组时，会异步的形式向后端查询商品分组的所有属性，并展示在页面中，由管理员手动录入商品的各项属性值，使用SKU属性值表进行保存
     关于商品图片部分，我们是购买了阿里云的OSS对象存储资源，将图片保存到了阿里云服务中，在数据表中保存的是图片的URL路径。
     当商品SKU新增完成后，并不代表就可以立刻购买，还需要通过审核和上架流程，才能正式被购买。
    审核流程是需要经过运营的领导，一般是城市经理进行审核。审核通过后，运营人员才可以决定是否上架。
     而在上下架的过程中，我们是使用**Elasticsearch+RabbitMQ**进行实现的
    其他流程就是修改和删除，是最基本的功能，代码实现也非常简单
    只不过需要注意的是，在针对商品SKU进行增删改的时候，为了防止重复提交，我们会在前端进入到页面之前，后端会下发一个临时的验证Token，这个Token一份存在Redis，一分返回到前端。当前端正式提交增删改操作时，这个防重Token也会随着请求一起发送到后端。
    后端在处理的时候，先从Redis中检查该防重Token是否存在。如果不存在，则表明该表单已经提交过了，应该拒绝处理，如果存在，则先删掉这个Token，  返回值为1， 代表删除。

只不过需要注意的是，在针对商品SKU进行增删改的时候，为了防止重复提交，我们会在前端进入到页面之前，后端会下发一个临时的验证Token，这个Token 一份存在Redis，份返回到前端。当前端正式提交增删改操作时，这个防重Token也会随着请求一起发送到后端。
    后端在处理的时候，先从Redis中检查该防重Token是否存在。如果不存在，则表明该表单已经提交过了，应该拒绝处理。如果存在，则先删掉这个Token，且返回值为1，代表删除成功，允许继续执行提交请求。反之，如果返回0则代表删除失败，拒绝处理提交请求。
    还有一个细节就是，如果商品处于上架状态，是不允许被删除的，必须先下架，才能被删除。因为商品信息如果上架后，会在ES中保存一份，所以必须要先执行下架。在下架流程中，会清理掉ES中的商品数据，下架后才可以删除该商品。    

##### 7.4商品评价流程:

​    题外话：商品评价在课程中没有讲的。
正式回答：
​     商品评价功能是商品微服务中实现的，使用商品评论表和商品回复表进行保存。

   当订单确认交易成功后，买家是可以针对商品进行评价的。当买家评价完毕后，商家可以进行回复。分别使用评价表保存首次评价，使用评价回复表保存评价回复评价和评价回复不同之处在于，评价数据可以包含文字、图片、视频，并且其他买家可以给评价进行点赞。
   而评价回复只能是文字的形式另外就是在评价的时候，我们设计了敏感词过滤，防止一些不文明的词汇出现我设计了单独的一张敏感词汇表，保存敏感词汇。并且利用**DFA算法**封装了一个工具类简化敏感词匹配的过程。如果买家评论的内容有敏感词汇，则不允许发布评论额外扩展。
   DFA算法是一种确定有穷自动机的方式。以前我们是使用的传统的字符串比较方式，就是遍历所有的敏感词，然后在每次循环中，将整片文章字符串传入，然后调用contains方法进行判断，这种方式效率非常差。所以我们改成基于DFA算法的实现方式。
   在实际使用的时候，我是封装了一个工具类，一次性的把有的敏感词存储到了多个map中，然后和文章内容进行比对，map中的某一个词项能够和文章中的词项比对上，就结束这种算法的原理，我大概理解就是将预先输入的词项，构建成一个类似索引的数据结构，匹配的时候也是按照顺序进行匹配，如果输入的内容能够匹配到某一个索引的终点，就代表某一个词项在文章中出现过。

####   8.商品上下架流程 （技术亮点： Elasticsearch RabbitMQ）

​       题外话：这个流程算是第一个复杂流程，但称不上复杂业务，只能说技术上有点亮点，实现过程稍微有点复杂。
​       这种问题只适合面试官问到：Elasticsearch、MQ哪里用到过？可以提一下在商品上下架流程中用到过。
​       如果面试官问：请你介绍一个最复杂的业务流程吧，那就干万别介绍这个业务流程，可以介绍下面的**订单流程**。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E6%95%B4%E5%90%88ES+MQ%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E4%B8%8A%E4%B8%8B%E6%9E%B6%E6%B5%81%E7%A8%8B.png)        

​    商品上下架这块也是我做的。业务需求是这样的，检索商品时，我们设计了单独的检索微服务，底层利用ElasticSearch进行实现，这是因为ElasticSearch支持分词、性能高、支持复杂语法查询。
   所以当商品上架后，需要将商品信息同步到Elasticsearch中，在实现的过程中，因为涉及到多次微服务之的调用，而这个商品上下架业务流程并不需要等待ES同步完毕再响应请求。于是我们就使用RabbitMQ进行解耦，将上下架流程和同步数据到ElasticSearch的流程分离。
​    只要商品上下架的时候，SKU表中状态修改成功，并保证这个上下架商品的id发送到MQ中成功，那么当前请求就可以立即响应了。                             
   而检索微服务这边定义MQ消费者，分别监听商品上架队列和商品下架队列中的消息，一旦监听到有新的消息，就说明有新的商品上下架的情况，那么就进行相应的业务处理。       
​     检索微服务消费者这边的业务处理逻辑是这样的：
​      首先，我们使用SpringData、Elasticsearch进行整合，它提供了类似于JPA的操作方式，通过实现通用接口就可以完成对ElasticSearch中数据的基本增删改查操作。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E5%9C%A8ES%E4%B8%AD.png)

​    然后我们封装了商品数据映射到ES索引库中的POJO实体类，里面包含：商品基本信息、商品分类信息等数据。
   当见听到商品上架队列消息，则从消息队列中取到商品SKUID，然后远程调用商品微服务，根据skuid查询到商品分类信息、商品SKU信息，并封装为POJO实体类调用SpringData、ElasticSearch提供的通用方法保存到ES中即可。
   当监听到商品下架队列消息，直接从消息队列中取到商品SKUID，根据文档ID删除掉ES中的数据就可以了。



#### 9.后台营销活动管理模块：满减规则设置

 题外话：这里在后台管理系统中，针对满减规则进行基础的CRUD，算不上复杂业务流程不过，博哥认为，这里都是为后面的订单业务流程做铺垫，比如：以后前台项目中，用户下订单了，如何判断订单中的订单项是达到活动标准？如何拆分优惠金额到每一个订单项？这个就是一个非常精彩的复杂业务流程了，所以大家不要着急。同样，关于这里的业务讲解，我们乃然是非常清晰的讲清楚每一个步骤即可。
 这个满减规则设置的流程，一共涉及到三张表，三张相关的表如下：
   关于营销活动，我们项目中是单独设计了一个营销微服务进行实现的。营销管理模块相关的业务有：满减、优惠券、秒杀、抽奖等业务流程
而关于满减规则设置的业务流程是这样的
   首先，平台运营经理登录后台运营管理系统后，先创建活动信息，设置活动名称、活动详情、开始和结束时间，还有活动类型，活动类型可以为满减或者折扣，使用**活动信息表**保存活动的信息。
   活动创建成功后，可以为活动添加优惠规则，优惠类型可以是满减或者折扣，例如：满100元减5元，或者满100元打9.5折。使用**活动优惠规则表**保存优惠的信息，一个活动可以设置多个优惠规则，活动优惠规则是,通过外键列关联活动表的主键ID。
   最后就是为活动关联参加活动的商品了。 并不是每一种商品都可以参加活动，有些商品利润比较低，例如：可口可乐、娃哈哈之类的品牌快消品，单品利润率不超过30%，就几乎很少参加活动，即便参加互动也是满减5元之类的小活动。而像应季水果、非品牌的零食饮料、巧克力鲜花利润率普遍50%以上，我们就几乎天天上活动。所以我们需要针对不同的商品，关联不同的优惠力度的活动。于是我设计了**活动参与范围表**，这是一个中间表活动ID关联活动数据库的活动信息表主键ID，商品SKUID关联商品数据库的商品SKU信息表的主键ID。

   前端在展示商品详情页面的时候，会查询当前商品是否参加活动，如果参加活，会在商品标题下面列出来活动规则，例如：全场满100减5元，或者端午节专场满100减10元。并且在最后结算订单的时候，这些活动规则不能相互叠加，我们会列出来当前订单能够参加哪些活动，并且自动选择优惠力度最大的活动规则。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E8%90%A5%E9%94%80%E6%B4%BB%E5%8A%A8.png)

​    

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E4%BC%98%E6%83%A0%E5%8A%9B%E5%BA%A6.png)





#### 10.后台营销活动管理模块：优惠券管理

题外：这里优惠券管理模块，和上面的满减规则差不多

正式回答
    后台优惠券管理这块，我主要是完成了优惠券的增删改查和优惠券规则的增删改查
    我个给您介绍一下这块业务流程吧
    首先是表结构，我一共设计了两张表，用于优惠券的管理，分别是：优惠券信息表和优惠券范围表。
    优惠券信息表保存了优惠券的相关信息，比如：优惠券类型是现金券还是满减券、优惠券名字、优惠券金额、使用门槛、优惠券领取日期与结束日期、优惠券过期时间、优惠券使用范围、发行数量等等。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E4%BC%98%E6%83%A0%E5%8D%B7%E7%AE%A1%E7%90%86%E8%A1%A8.png)

  由于我们业务上要求优惠券需要限定使用范围。有的优惠券可以全场商品使用，有的优惠券只能针对某一个商品进行使用或者针对一个商品类目进行使用
    列如我设计了一个饮料专场优惠卷，那么整个饮品类目都可以使用这张优惠券
    所以我又单独的设计了一张优惠券范围表，描述了优惠券的使用规则。
    主要字段有关联的优惠券ID、范围类型是商品还是分类或者全场通用、以及范围ID。如果范围ID为0，就代表全场通用。
    如果范围类型为商品，那么范围ID就是使用优惠券的商品skuId
    如果范围类型为分类，那么范围ID就是使用优惠券的商品分类ID
    优惠券范围表和优惠券表是多对一关系，也就是说，一张优惠券可以被多个指定的商品使用，或者被多个指定的商品分类使用。

![](../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E4%BC%98%E6%83%A0%E5%8D%B7.png)

这就是我设计的两张表，并且围统这两张表完成了基本的增删改查操作，比如ID查询、分页查询、新增流程等
    我给您介绍几个稍微复杂点的流程吧
       首先是优惠券的修改，在页面中修改优惠券信息的时候，会同时列出来优惠券的使用规则，有可能前端同时也把优惠券使用规则也修改了。所以在修改优惠券信息的时候，我先删掉当前优惠券关联的优惠券规则数据，然后再更新优惠券信息到优惠券信息表中，新增优惠券规则信息到优惠券范围表中。
        然后就是优惠券的删除，我会判断优惠券的领取时间是否开始。如果优惠券的领取时未开启，那么才可以进行删除，同时会级联删除掉优惠券关联的优惠券范围表中的无惠券规则数据。如果说优惠券已经开始被领取了，那么就不能被删除，只能是暂停领取，修改优惠券状态为不可用！并设置发行数量为0。
    题外话：优惠券领取这块我们可以设计类似优惠券领取的秒杀业务场景，但是和这块的业务没有关系。这块的业务属于后台管理系统。我们先继续往下走，按照课程中讲解的流程先把课程中的业务流程梳理完毕，最后如果说他后面关于优惠券领取流程没有讲或者讲的不过源，博哥会给大家专门梳理一个优惠券秒杀流程。

#### 11.微信登录 （技术亮点：Redis、 JWT、 微信登录）

   题外话：注意：要实现微信登录需要先接入到微信开发，申请微信开发者账号、申请小程序号（测试号），前端使用微信开发者工具开发。
实现流程图如下：



正式回答：
    面向普通买家用户的前端项目，我们是使用微信小程序开发实现的。    使用微信小程序的话，一个是节省前端App的开发成本，其次就是更容易留住买家，买家只需关注扫码就可以长期保存在用户的微信列表中。
    开发的时候，首先我们是在微信开发者中心以公司的资质进行了认证。这样，就可以正式发布微信小程序以及接入微信支付和微信登录，有了开发者账号，就可以申请小程序应用，得到小程序ID和小程序秘钥，然后关于用户相关的业务，我们后端单独创建了一个用户微服务进行实现。
    微信登录业务流程：首先用户在小程序点击登录，前端会调用微信的登录方法wx.login()进行登录，用户在小程序点击允许登录后。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png)

​    当用户允许登录后，微信服务端就会返回一个临时票据code，前端将这个临时票据code发送给我们后端。
​     我们后端需要带着自己的AppID和App秘钥以及这个临时票据code，去向微信服务端发起请求，获取一个Sessionkey和openld。
​        Sessionkey代表一个会话的秘钥，用于校验会话数据的签名和解密，这个是有效期的。
​        而Openld代表用户的唯一标识，这个是不会改变的，所以后面我们也是通过Openl判断用户的唯一性。
​      因为这是一个HTTP的远程调用，所有我封装了一个Httpclient (Http可辣特)的工具类专门用于对接微信的开放API
​      得到用户的Sessionkey和Openld以后，根据Openld判断用户是否是首次登录
​     如果是首次登录，那么在用户表插入新的用户信息，因为新版的微信api关闭了getUserlnfo接口，所以我们只能用Openld+随机字符串作为默认用户名，用户将来可以在个人中心进行修改。
​     然后就是查询用户关联的团长信息、关联的自提点信息，查到用户信息后，我们就根据用户id和用户name，我使用JWT生成一个自定义的Token。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/token/JWT/jwt%E6%B5%81%E7%A8%8B.png)

   最后就是封装返回给客户端的数据，比如Token、用户信息、关联的团长信息返回给前端。另外还要把用户的个人信息缓存到Redis中,以后前端访问的时候，就需要在请求头中携带这个JWT的Token，后端需要判断Token是否过期、签名是否被算改。如果判断未通过，就返回异常情况，让前端重新登录，如果判断通过，再返回业务数据，这个微信登录流程结束了。

  我再给您详细说一下我关于登录以后，用户再次请求的一个认证流程吧(可以不用说这个)，**网关中实现也可以。**
        实现方式是这样的当用户登录成功后，前端每次请求都会把Token放到请求头里面，这个Token就是登录时下发的JWT格式的Token。
      我在后端代码中，设计了一个拦截器，拦截到请求后，从Request请求头中获取Token，然后调用预先封装好的JWT工具类校验Token有没有问题，从Token中取到Userld，再拿着Userld去Redis中获取用户信息。如果用户信息没有过期，那么就可以获取到，如果过期了，前端需要重新登录。
        当获取到用户信息后，我直接把用户信息封装到 ThreadLocal （特勒老狗）中，这样，在后续的处理业务的过程中，就可以随时取到用户信息进行相应的业务处理了。

#### 12.首页数据显示：

题外话：
     和原本课程中有点不同。
        查询用户信息，原版课程中是分两次查询，远程调用用户微服务查询用户提货信息，远程调用用户微服务查询用户是否是新用户
          原版课程这么做的原因可能是出于单一职责的原因考虑吧，一个接口只负责一件事情。但是博哥认为，有的时候，软件设计时，不能太遵守一些规范。如果我将这两次远程调用合二为一，那么就可以在首页流程中优化一次网络IO。
       另一个改动的地方就是分类数据查询，原版课程是远程调用商品微服务查询分类数据。
         但是博哥不这么认为，商品分类数据作为经常查询且极少修改的数据。我就算是把商品分类数据写到一个common工程的常量类中，每次访问时直接本地返回，redis都不带的查询，合理不合理？我认为非常合理！因为就算调用redis，也要付出一份网络IO，对不对？
       所以我这里改了一下，商品分类数据缓存在Redis，common工程中维护了Redis中所有的KEY的常量，商品服务将商品分类数据缓存到Redis，首页服务从Redis获取就可以了。
   还有就是爆款商品查询，这里是调用检索微服务查询的。这个没啥问题，只不过这里在最后补充了一下**爆款商品的计算规则和实现方式**。



正式回答：
用户登录成功后，首先是直接跳转到首页面的。在首页面中，我们会展示

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE.png)

1. 当前登录用户的提货点信息，例如：某某校园
2. 还有新人专享的商品，我们在user表中，有一个is new字段，代表是否是新用户，如果是新用户，就会查询新人活动数据，展示新人活动专享的商品

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%94%A8%E6%88%B7%E8%A1%A8.png)

3. 还有商品分类、秒杀活动  热销商品等数据;
       实现方式是这样的，我们是单独设计了一个首页微服务进行实现。关于首页数据接口这块，业务是这样的：

4. 首先判断用户是否已经选择了提货地址，这是用户登录成功后，前端根据后端返回的数据判断当前用户是否有关联团长信息，也就是提货点信息。如果没有的话，直接在前端弹出对话框，强制要求用户选择提货点信息，因为我们后面商品展示是以当前提货点地址来关联仓库进行查询的，所有用户必须选中一个他所属的提货点。

5. 如果当前用户没有关联的 提货点信息，他应该是个新用户。前端会把用户的经纬度坐标发送给后端用户微服务，后端用户微服务预先在Redis中使用GEO数据类型缓存了所有的代理商提货点的经纬度信息，所以可以借助Redis的GEO Hash的方法，根据当前用户的经纬度坐标求出距离用户最近的提货点信息，并且按照距离进行降序排序返回给前端。用户在前端可以手动选择提货点。

6. 当用户选择提货点以后，就直接发起一个异步提交，向后端保存用户的提货地址信息，其实就是保存会员、团长和仓库的关联关系。

   ![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%94%A8%E6%88%B7%E4%B8%8E%E4%BB%93%E5%BA%93%E5%85%B3%E7%B3%BB%E8%A1%A8.png)

7. **然后根据Userld远程调用用户微服务**，查询用户信息，包含①用户的提货地址信息  ②以及当前用户是否是新用户

8. 如果当前用户是新用户，那么就调用商品微服务，查询新人专享的活动商品列表。默认首页只展示3个活动商品。如果说新用户对新人专享活动感兴趣，那么他可以点击进入到新人活动专区，在新人活动专区中，再重新查询更加详细的活动商品数据。

9. **还有就是查询当前的爆款商品**。爆款商品是根据商品的点击、销量、评价星级等用户行为计算出来的，这是商品微服务的一个业务流程。我们这块首页查询的时候，直接调用检索微服务按照热度分值进行降序排序，返回前10条商品数据作为爆款商品展示在前端页面中就可以了。

10. 最后，从Redis中取出来商品的分类数据，和前面的用户提货点信息、新人专享活动、爆款商品统一进行封装，返回给前端展示就可以了。

11. 另外这个爆款商品计算规则，是商品微服务中的一个业务流程，也是我独立负责的。主要是针对商品不同维度的用户行为进行统计，比如：购买、浏览时长、加购、评价星级，进行计算，得出来的一个分数，这个分数就是商品的热度

    

    

#### 13.爆款商品热度是怎么计算的？

​    题外话：现编的。参考头条项目的文章热度计算流程进行改写。
​    头条的文章热度计算有定时计算和实时计算，但是考虑到这种电商项目，商品的热度业务角度来看，并不是一个非常强一致性的东西，再加上实时计算使用KafkaStream，也会带来很大的学习成本，所以就改成定时计算实现，主要借助Redis+XXL-JOB实现。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E7%88%86%E6%AC%BE%E5%95%86%E5%93%81%E7%83%AD%E5%BA%A6%E6%B5%81%E7%A8%8B.png)

正式回答：
   爆款商品热度是根据用户对商品发生的各种行为进行计算的，主要有：浏览商品、评价商品、商品上下架  商品支付成功、商品退货、商品加购等行为进行汇总计算。
    每一种用户行为对应的分值不一样，浏览商品加1分，评价商品根据评价星级加分或减分，商品下单加5分，退货减5分。
    因为这些行为涉及到多个微服务的业务流程，而商品热度计算并不是强一致性的，于是我将原有的业务流程和商品热度计算流程解耦。这里我并没有使用MQ进行实现，而是采用Redis实现。
   使用Redis的ZSet集合，保存商品的热度数据，每一条数据的分值就是商品热度
    并且定时每隔10分钟，执行一遍数据同步任务，将Redis中的商品热度同步到
ElasticSearch中的Sku索引中就可以了，
     因为我们的商品数量最多也就一两千种，所以不用担心Redis中的全部商品热度数据同步时，带来的一些性能问题，这些根本不会对性能有任何影响。
    在以后遇到一些检索需求时，除了根据商品的名称、价格、属性等信息进行检索，还可以针对检索结果按照热度分值进行排序，例如首页数据展示中查询爆款商品，就是按照热度分值进行降序排序查询的。

#### 14.商品查询(检索)你是怎么实现的：

  需求：根据搜索关键字查询商品或者根据商品分类查询其下的商品列表。
当前需求属于首页微服务，所以：
1、首页微服务远程调用商品微服务，查询商品分类列表
2、首页微服务调用检索微服务，查询商品信息以及活动信息                      
3、查询商品的活动信息                               

  在原版课程中，是讲了两个接口，分别是**查询商品分类**和**根据条件查询商品**，这里博哥认为，这是两回事不应该放在一个问题中，并且查询商品分类太简单了，一行查询就搞定。所以这里就只详细聊怎么进行商品检索。
正式回答 

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%88%86%E7%B1%BB.png)

 商品搜索这块也是我做的，业务流程大概是这样的

-  用户点击小程序底部菜单栏，点击【分类】跳转到分类查询页面中，在分类查询页面中支持根据分类类型查询商品以及根据关键字查询商品两种方式。
-  后端会根据请求入参，拼接查询条件，返回查询到的数据， 展示在前端中。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E5%95%86%E5%93%81.png)

- 首先校验用户的登录状态，这是由我提前封装好的通用拦截器实现，他校验通过后，会把用户信息从Redis中取出来放到ThreadLocal中；
- 然后在处理请求的时候，我从ThreadLocal中取出来用户关联的仓库ID，还有从请求参数列表中取取出来分类ID、商品关键字以及分页参数，拼接到一个自定义的查询VO中。
- 远程调用检索微服务，检索微服务会根据传入的查询条件，去ES中查询到符合条件的商品列表信息。这还没完，我还要拿着这些查询到的商品ID,远程调用活动微服务。
- 在活动微服务中，我会按照商品ID、活动的起止时间、活动状进行查询，返回每一个商品ID对应的活动信息，比如说满减、折扣等优惠信息，因为每一个商品可能可以同时参加多个活动，所以每一个商品对应的活动是一个List集合保存多个活动信息。
- 最终，首页微服务返回给前端的格式就是自定义封装的一个Page分页对象，而查询到的数据，使用List集合进行封装。每一个商品使用自定义的VO对象代表，其中包含商品名称、价格、图片、是否是新人专享、满减、折扣等数据。
- 这些数据返回给前端后，前端展示在列表页面中，这就是我负责的商品检素业务流程的实现。



#### 15.商品详情页功能：

   根据商品SKUID查询商品详情

查询的数据有：
   商品基本信息表 product.sku_info
   商品图片表：product.sku_image
   商品海报表：product.sku_poster
   商品活动信息：activity.activity_info、activity.activity_sku、activity.activity_rule
   商品优惠券：activity.coupon.info、activity.coupon.range
另外再做一件事，就是更新一下商品热度，还记得13题讲的商品的热度计算规则吗？商品浏览一次，加1分。
注意：原版课程是调用检索微服务，分值先缓存到Redis，并每次达到10的整数倍就更新Redis数据到ES。这里改造了一下，在第13题中我们统一使用了Redis+XXL-JOB进行实现。

正式回答
商品详情页查询是我做的，当用户在搜索页面点击商品进入到详情页时，后端由首页微服务进行处理。执行步骤是这样的

-  首先**调用商品微服务查询SKU信息**，包含SKU基本信息、SKU图片、SKU海报图、SKU属性列表数据；

- 然后调用活动微服务根据skuld和用户id,**查询商品的活动信息和优惠券信息**
       查询商品活动信息:
          首先是直接根据skuld进行查询，查到当前商品关联的活动。
          还要根据skuld查询商品基本信息，得到分类ID，再根据分类ID查询这个分类当前有没有参加活动，将当前商品所属分类关联的活动信息也查询出来，活动类型有满减和折扣两种类型。

- 合并商品直接关联的活动信息和分类关联的活动信息为一个活动列表，然后继续查询优惠券信息：

- 无论任何优惠券，首先是当前用户需要领取过才可以查询出来，我们有一张coupon_use表，记录了优惠券领取记录，根据用户ID查询到当前用户领取过的优惠券，同时用内连接查询的方式连接查询优惠券使用范围表（规则表），判断当前用户具备的多张优惠券是否是当前商品可用或者当前商品所属分类可用（因为我们的优惠券类型有商品、分类两种形式）以及是否是在优惠券使用的时间范围内。最终返回当前用户针对该商品可用的优惠券列表，如果没有的话就返回空。

- 需要注意的是，优惠券必须是用户先拥有了优惠券，才能够使用，不会在下单的时候自动领取的(拼多多就是下单自动领取)。而优惠券的获取方式有用户在活动页面获取、也可以是后台运营人员直接赠送的。

- 还有就是根据userld判断当前用户是否是新用户。如果是新用户，则拿着用户ID+skuld去新用户活动表中查询一下当前商品是否正在参加新用户专享活动。如果是，则把这个新人活动信息，和前面的那个满减、折扣活动信息进行合并。

- 活动微服务最终返回的是当前商品正在参与的活动列表以及当前用户针对当前商品可以使用的优惠券列表给到首页微服务。

    

- 接着就是**更新一下当前商品在Redis中的热度数据**，我们使用Redis的一个zset集合保存每一个商品SKU的热度，当用户浏览一次商品，就对他的score分值+1，并且定时同步给ES中的商品Sku索引中。这样就能实现其他一些热度查询、爆款商品查询的需求。
       因为这几个步骤：查询商品信息、活动信息、更新商品热度，他们之间没有顺序要求，所以我这里使用 CompleteFuture （看薄了父车）异步编排，让他们以异步的方式执行，等待3个子线程任务执行完毕后，主线程汇总结果，将商品信息、活动信息封装好返回给前端。这就是我写的商品详情页的流程。

   

####  16.购物车功能：

 购物车是一个电商场景中经典的一个面试题，最经典的几个问题是
     用户未登录，怎么记录用户的购物车？
    用户登录后，登录前的购物车信息如何合并？
     购物车持久化是使用Redis保存还是MySQL保存？

需求说明
       ​ 商品首先添加到购物车中，购物车中保存商品的信息以及购买熟练。
​        在结算的时候，是在购物车中进行结算，可以选中多样品进行结算；结算的同时，要显示可用的优惠信息。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E8%B4%AD%E7%89%A9%E8%BD%A6.png)

​     一个用户的购物车，使用一个类型为hash类型的数据类型保存外层的key（大key）为用户ID，hash内部可以存储多个KV键值对数据，这里的key是每一个商品ID，值为商品信息（封装了一个Cartlnfo对象表示）。

正式回答：
 关于购物车模块相关的业务，相关的接口是放在购物车微服务中实现的，比如我写过的相关接口有：

-   商品加入购物车
-   查询购物车列表
-   切换购物车商品的选中状态
-   删除购物车
-   带活动和优惠卷信息的购物车列表查询
    ​      购物车数据，我们是使用Redis的 hash类型进行存储的。每一个用户的购物车数据，都是一个hash类型集合进行存储。用户的id作为key，用户的购物车数据作为值，使用hash类型进行数据保存。在hash集合内部，商品skuld作为key，自定义了一个Cartlnfo对象作为值。
    ​      在存储的时候，会将Cartlnfo对象转为JSON格式存储在hash结构中的value中去。

#####   1加入购物车流程：

​    我先说一下商品加入购物车流程吧：
​    首先根据用户ID从Redis中取出来当前用户对应的购物车数据，就是将用户在redis中用于保存用户购物车数据的hash结构类型数据取回到本地。
​     然后根据Skuld判断当前商品在购物车Hash中是否存在，我们封装了一个Cartlnfo对象代表一个商品在用户购物车中的数据。
​    这个Cartlnfo中包含有：用户ID、商品分类ID、商品类型、活动数据、价格、购买个数、关联的仓库ID、限购个数、是否被选中等数据
​    如果存在，我们就先判断一下是否超出当前商品的限购数量，如果超出了限购数量，直接抛出异常，结束方法。
​    如果不限购或者没有达到限购数量，则会将当前购买的数量，加到Cartlnfo原本的购买个数当中去，并且将当前商品在购物车中的选中状态改为1，代表选中。
​    如果存在，那以前肯定添加过该商品，所有我们就先判断一下是否超出当前商品的限购数量，如果超出了限购数量，直接抛出异常，结束方法。
​    如果不限购或者没有达到限购数量，则会将当前购买的数量，加到Cartlnfo原本的购买个数当中去，并且将当前商品在购物车中的选中状态改为1，代表选中
 如果不存在，则新建一个Cartlnfo对象，远程调用商品微服务，根据skuld查询到Sku的详细信息，将Sku详情封装到Cartlnfo中，以及当前要新增的数量，并且把选中状态改为1代表选中状态。
   最后将Cartlnfo数据更新到Redis中就可以了。
   还有就是购物车数据我们业务上是不需要永久保存的，所以针对每一个用户对应的购物车过期时间设置为30天过期。至于说为什么是30天，原因是这样的，基本上每隔1个月，像我们卖的一些时令水果、应季产品就会换代好多，或者更新新的打包售卖方式。所以就是用户长期不使用的话，那么大概率他的购物车数据中很多商品已经下架了，所以我们设置有效期为30天不使用，就删掉用户对应的Redis中的购物车数据。



##### 2删除购物车：

​    删除流程很简单，有两种删除方式，一种是清空购物车，一种是删除单个购物项
​    说下清空购物车吧，直接就是将用户对应的购物车hash给删掉了，然后重新新建一个空的购物车key，放到Redis就可以了
​    然后就是删除购物车中的某一个商品，我们的业务流程是这样的。在前端中，假设用户针对红薯商品添加了两次，购买数量为2。那么当用户点击减号的时候，会向后端发送一次修改数量操作，将前端要修改的数量增加或者减少发送给后端进行修改，实现步骤就是将用户的购物车数据取出来，重新更新一下商品数据，将购物车中的购物车项购买数量进行更新，再存回到Redis中去。
​    当前端的剩余数量为1的时候，用户再次点击减号，前端就会提示用户要从购物车中删除当前商品，那么如果用户同意，则向后端发送删除请求，将要删除的商品从用户的购物车中移除。实现步骤就是根据userld找到用户的购物车Hash，然后调用hash的方法根据key删除当前商品就可以了。

#####   3查询带优惠券的购物车  *

   题外话：这个流程是整个项目中最复杂的流程之一，另一个是下面的订单相关流程。还有一个比较复杂的流程就是查询带活动和优惠券信息的购物车流程。

   业务流程是这样的，首先用户在购物车中勾选了几个要结账的购物车商品进行结账。
   所以每次勾选一个购物车商品的时候，都会向后端发起一次查询，查询当前用户在购物车中选择的几个商品，判断用户如果购买这几个选中的商品，可以参加哪些促销活动以及可用的优惠券，同时还要根据多个活动规则，计算出来优惠的金额等等一起返回给前端。
​    步骤是这样的，用户请求的是购物车微服务，购物车微服务提供了查询购物车优惠计算的接口，在实现的时候：
​        根据用户的id，从redis中获取到购物车数据，并且进行过滤，过滤出来用户选中的商品数据，作为要计算优惠的购物车商品数据。然后远程调用活动微服务，将购物车数据传给活动微服务的优惠计算接口，查询出来当前购物车中选中的商品能够参加哪些活动以及可以使用的优惠券信息和优惠力度。
​        在活动微服务的优惠计算接口中：
​             首先是先查询当前购物车中的所有商品可以参加哪些活动，哪些商品不参加任何活动，实现步骤是这样的：

​      先根据购物车中的skuid， 查询活动商品关联 activity Sku）  表  得出当前购物车中的哪些商品可以参加哪些活动。
​    因为可能会出现一个活动对应购物车中的一个商品，也可能一个活动对应购物车中的多个商品。而在计算优惠规则的时候，例如满减、折扣，是需要按照活动范围内的商品的总金额或者购买数量来统计是否达标或者优惠力度，所以还需要先针对活动进行分组，才能计算优惠力度。
   活动分组数据计算就是遍历当前购物车中可参加活动的商品与活动关联关系
集合，然后以JDK8的流式编程写法遍历集合，得到了每一个活动和参加该活动的商品集合的Map映射关系。活动ID作为Key，商品ID集合作为值进行保存。
   当然了，光得到活动分组数据还不够，我还需要知道活动的规则，才能去计算满减或者折扣的优惠。所以根据上一步计算出来的可参加的活动ID集合，去查询活动规则表（activity_rule），得到当前购物车中的商品能够参加的所有活动对应的活动规则。

 我们的业务需求是这样的，就是一笔订单中的所有购物车商品，可能同时满足多个活动，但是只能同时参加一个促销活动。因为一个商品可能在多个活动中都能够达到单或者满减的规则，那我们不可能给用户反复的叠加活动的优惠啊，这样会赔钱的
        ==原课程中是直接将所有的达标活动都拿出来进行优惠，在求出所有的活，不太合理。以下为修改版==

​    所以我们会针对当前购物车商品达标的多个活动分组分别进行计算，求出来每一个用户选中的购物车商品可以参加的每一种活动的优惠数据，这个优惠数据包含：总金额、总购买数量、满减、折扣的各项数据。
​    最后算出来每一种活动的数据，保存在一个购物车活动列表List集合中，还有就是有些商品可能不参加任何活动，所以再根据购物车商品总的集合减去参加活动的商品集合，求出来没有参加任何活动的商品集合，并且也保存到购物车活动列表List集合中。
   这样我就得到当前购物车商品可以参加哪些活动，以及不参加任何活动的商品数据了。
   然后我就可以遍历这个活动List集合，根据每一种活动的规则以及位于当前活动然后我就可以遍历这个活动List集合，根据每一种活动的规则以及位于当前活动下中的商品进行计算，计算出来每一种活动优惠后的金额计算规则很简单，因为我在上一个步骤中已经知道了每一个活动的规则和参加该活动的商品，所以遍历活动List集合，求出来优惠金额最大的活动信息。
  计算完了促销活动，还有一个购物车可以使用的优惠券的计算流程，实现步骤是
这样的。首先根据用户ID查询优惠券领用表（coupon_use表）同时连接查询优惠券基本信息表（coupon_info），得到用户领取过哪些优惠券的优惠券信息列表List<Couponlnfo>
​       然后拿着当前用户拥有的所有优惠券ID，去查询优惠券规则表（couponrange），查询到当前用户具备的优惠券的使用规则，再然后遍历优惠券使用规则以及购物车中的商品列表，判断每一张购物券能够被哪些商品使用，返回优惠券与当前优惠券可用的商品Sku的Map集合。KEY是优惠券ID，值是商品skuID列表。

  题外话：本来这里计算优惠券和优惠券对应的商品Skuld集合，感觉没必要这么详细，因为我们在讲业务，而不是业务中怎么去遍历怎么写的代码，于是我就删了。但是我把我删掉的内容放在下面家参考一下。

​    接下来就是遍历这个优惠券与商品关系的Map集合，求出来所有可用的优惠列表以及优惠力度最大的优惠券。
​    最后就是统一汇总带优惠券的购物车数据了。
​          我先遍历原版的购物车数据，做了一个加法计算，求出来没有任何优惠的原始购物车商品总金额。
​        然后用原始总金额减去促销活动力度最大的活动优惠金额，再减去可用的最大优惠额度的优惠卷金额，得出来最终金额。
​        最后，将这一切可参加的促销活动、促销活动优惠的金额、可用的优惠券列表最大的优惠券金额、原始购物车总金额、最终优惠后的金额这些数据返回给购物车微服务。购物车微服务将这些优惠数据返回给前端展示就可以了。

#### 17.订单确认：

需求说明：
    首先是在购物车中选择商品，点击立即购买，跳转到生成订单页面。
    在生成订单页面中，填写收货信息，提交订单。
    后端生成订单后，状态为待支付，等待用户进行支付。
    在当前订单生成流程中，要完成的就是根据购物车的商品信息、用户提货信息，生成订单。
​    我们要做的事情是：

1.  对订单进行确认
2.  现价、原价等信息的显示
3.  设置提货人的联系方式
4.  订单的生成操作



正式回答:

-  用户在前端购物车中选中了要购买的商品，点击立即购买，就会向后端发起订单确认请求。
-  在订单确认接口中，首先从Redis中获取到用户关联的团长信息和提货地点信息；
-  然后远程调用购物车微服务，获取用户勾选的购物车中的商品信息；
-  再然后使用雪花算法生成一个用来标识订单的唯一编号，并将该订单编号缓存到Redis当中，时间默认设置为24小时;
-  继续调用购物车微服务，查询当前用户选中的商品的优惠信息；
-  最终封装购物车优惠信息、团长信息以及订单编号信息，返回给前端，展示在小程序端的订单确认页面就可以了。
   如果前端用户在24小时内，没有确认正式提交订单，那么Redis中的订单唯一编号就会自动回收。用户将来再次访问时，重新这个流程就可以了。

![](../../../%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/Java/%E9%A1%B9%E7%9B%AE/%E5%B0%9A%E4%B8%8A%E4%BC%98%E9%80%89/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4.png)

#### 19.订单生成： *

   题外话：

   订单生成这个流程还是非常简单的，但是有几道最经典的面试题

1. 订单重复提交遇到过吗？
2. 你是怎么解决订单重复提交？  （经典回答：redis+lua脚本）
3. 下订单是吧？那库存是怎么锁定与解锁的？  （分布式锁）
​ 这个操作又是修改库存，又是修改订单，那你这个是跨多个服务远程调用吗？分布式事务怎么解决的？  （分布式事务）
​        

正式回答:
​        前端用户在订单确认页面中，确认收货地址、要结算的商品没有问题后，用户提交生成订单请求到订单微服务。请求参数中包含：订单确认流程中返回的订单编号、收货人姓名、电话、团长ID、用户选择的优惠券ID和参加的活动Id。
​         **1、防重校验**
​     在后端接收到请求进行处理时，首先我先做一个防止重复提交的校验。从请求中获取到订单编号，然后去Redis中核销订单编号，这个步骤我是通过执行原生的lua脚本进行的

```sh
String script="if(redis.call('get'，KEYS[11]） == ARGV[1]  then return "+"redis.cal（'del'，KEYS[1]） else return（  end";
```

lua脚本的意思就是我先get查询一下订单编号在Redis中的数据

- 如果存在，就删掉这个key，返回删除的结果为1；
- 如果不存在， 就返回0；
       然后判断这个结果，如果结果为1就表示正常提交订单，进行后续的正常业务处理；
       如果这个结果为0，就表示重复提交了，已经有一次请求先一步执行了，不能再往后执行这个请求，抛出自定义的重复提交异常，结束请求；

**2、锁定存:**
    如果正常往后执行的话，下一步就是锁定库存了。锁定库存的核心思路就是判断当前商品车存是否能够满足当前买家购物车提交过来的商品数量。锁定库存是由商品微服务实现。
    当前正在处理请求的订单微服务先调用购物车微服务，获取到当前用户购物车中选中的商品数据，确定当前用户要购买哪些商品。
     然后从商品信息中取到库存数据，我们的库存数据是直接保存在了商品sku表当中的，所以需要远程调用商品微服务锁定库存。
    在锁定库存的时候，订单微服务传过来的是一个要锁定的SkuList，代表一个订单有多个商品要同时锁定。所以锁定库存的业务需求是这样的
        一个订单内的商品库存要么一起全部锁定成功，要么全部不锁定
        如果锁定过程中，有一个商品库存不够了，那么就直接反向操作，释放掉已经锁定的同一个订单内的其他商品库存；
     所以在商品微服务处理锁定库存的流程中，先遍历所有的购买商品，挨个锁定每一个商品的库存。

   因为这个锁定商品库存的操作可能会有多个订单请求同时购买同一个商品情况出现，所以在锁定库存的时候，可能出现超卖问题。因为我们将来部署的话肯定是部署多个服务实例，所以加锁控制的时候必须使用分布式锁进行控制，我是采用redisson组件提供的分布式锁功能，将商品skuld作为锁。
   锁定每一个商品的时候，先进行加锁，加锁后再查询库存是否满足当前购买数量，如果满足的话，就锁定库存。
    锁定库存方式很简单，就是在我们的商品sku表中，除了有一个库存字段以外，还有一个锁定库存字段，将要锁定的库存数量增加到锁定库存字段原有的数值中即可。

 ```sh
update sku_info set lock_stock = lock stock +#{skuNum} where id=
 #{skuId}

# update语句执行成功，返回1，代表锁定成功，返回0，代表条件不满足，锁定失败。
 ```

   如果所有商品的库存都锁定成功后，就把商品skuList集合存储到Redis中，key是订单编号，值是skuList集合，为以后解锁或者真正扣减库存做准备。

  如果所有商品的库存都锁定成功后就把商品skuList集合存储到Redis中，key是订单编号，值是skuList集合，为以后解锁或者真正扣减库存做准备。
    如果说在锁定的过程中，有一个商品库存没有锁定成功，那么可能是库存不足，也可能是别的订单先一步进行了锁定。所以遇到这种情况，那么就回滚加锁成功的商品库存，实现思路很简单，就是把当前skulist中已经加锁成功的商品，做一个反向操作，将已经锁定的库存数量进行扣减就可以了。
    然后商品微服务返回加锁的结果给订单微服务，如果锁定失败，直接抛异常，结束流程
    如果锁定成功，就保存订单数据，主要是保存订单基本信息（order_info）和订单项
order item） 到数据库中

#### 3、保存订单：

​    题外话：这块原版课程中写的贼麻烦，有些业务实现博哥不太认可，例如：到这块了还要
计算促销活动和优惠券，包括促销活动原版课程中是可以同时参加多个促销活动，所以这块博哥进行了改造
​    在保存的时候  步骤还是比较麻烦的：

1. 首先是通过远程用用户微服务，得到当前用户的团长信息和提货点信息；

2. 然后就是计算当前购买的商品列表能够参加哪些营销活动和可以使用的优惠券。这里是远程调用了活动微服务的【查询带活动和优惠券的购物车接口】，返回可参加的活动、可使用的优惠券，以及最大优惠力度的活动和优惠券信息。

3. 然后从前端参数中获取到用户是否有手动选择使用的优惠券以及参加的促销活动ID。

   -  如果有的话，就遍历活动列表和优惠券列表，校验当前活动以及优惠券是否存在以及是否可用；
   -  如果没有的话，就直接使用优惠力度最大的活动和优惠力度最大的优惠券

4. 然后就是分摊促销活动的优惠：

       -   如果促销活动为满减折扣，则直接遍历所有购买的商品，按照折扣计算出来每一个商品优惠后的金额。
       -  如果促销活动为满减金额，则直接遍历所有购买的商品，商品单价除以订单原始总价，得出占比。占比乘以满减的金额，得出来每一个商品要优惠的价格，再用商品原价减去要优惠的价格，求出来每一个商品优惠后的金额

5. 然后就是分摊优惠券的优惠：

   -  判断优惠券的类型，如果是全场通用的优惠券，则直接按照商品单价占总价的占比进行分摊就可以了；
   -  如果优惠券的类型是限定商品分类，则遍历商品，求出来当前订单下，该分类下的商品，将优惠券的优惠分摊到该分类下的商品价格中就可以了；
   -  如果优惠券类型是限定某一个商品，则直接针对该商品进行价格扣减就可以了，需要注意的是，无论任何类型优惠券，优惠后的金额一定是大于0的，如果优惠券金额大于订单总金额，那么可能会出现负数，那就直接按照0元下单就可以了。

6. 最后返回经过优惠后的所有商品的集合，包含：每一个商品原价、优惠后的价格，当前订单使用的促销活动ID以及优惠券Id。

   - 根据这些得到的数据，计算出订单总金额，再按照封装订单基本信息，保存到订单表中；        

   - 遍历计算完毕的订单商品集合，保存到订单项表中；

   - 如果当前订单使用了优惠券，则远程调用活动微服务，将优惠券状态更新为已使用。最后就是从Redis中的用户购物车hash中删掉购买的商品，以及给团长计算佣金这两个操作时放到MQ里面异步实现。

   - 最后返回订单编号给到前端，代表订单生成成功。前端会根据订单编号，向后端发起查询，跳转到订单的支付页面进行支付。这就是订单生成的流程。

       

**课程中的漏洞：**

  - 锁定库存时是直接锁定sku，不区分仓库id，那假设某一个商品在A城市仓库有库存，城市仓库没库存，那请问B城市的买家是否能下单？
      答：不能，因为我们这个仓库补货是统一调度的，仓库有什么，我们就卖什么，不会跨仓库调货，因为这样做的话成本太高了。

  - 追问：那你这个锁定库存的时候，只用skuld锁定库存，合理吗？意思是某一个商品B城市仓库没货，A城市仓库有货，那么就可以继续锁库存然后下单购买？  （原版课程就是直接锁skuld）

      答：您说的这种情况是不可能出现的，因为我们的商品sku在上架或者补货的时候，都是直接绑定的仓库。也就是说，同一件商品，在AB两个城市售卖，上架的是两个sku，分别属于A城市仓库的以及属于B城市仓库的。他们的skuid也不一样，所以在加锁的时候，使用skuld加锁没问题，如果库存不够了，那就只代表着当前城市仓库的库存不够了，不会对其他城市的仓库库存有任何影响。
         您也不用担心这样会不会很麻烦，不会的。因为我们不会有太多的商品，并且每一个城市都有专属的运营经理，他负责当前城市的商品运营，这点事情对他来说根本就不算什么工作量。而且在后台管理系统中，商品详情是可以进行克隆的，就是A城市运营经理上架了一个商品以及商品详情，其他城市的运营经理直接在管理系统中可以一键克隆，铺货到当前城市的商城中。

  - 这个业务中有没有用到异步解耦？

      像订单流程这样经典的问题，必然有很多步骤，有些步骤是强一致性的，例如：锁定库存、生成订单信息、核销优惠券等；
          有些步骤是最终一致性的，例如：删掉购物车中的已购买的商品数据，给团长结算佣金。
         正式回答：订单生成过程中，关于佣金计算、删掉购物车已经购买的商品数据我们进行了异步实现。
         在最后我们是把消息封装成JSON格式数据，放到RabbitMQ当中。然后定义消费者进行消费处理。
         删掉购物车的消费者位于购物车微服务，这个很简单，就是调用redis的hash命令根据key删掉hash中的购物车数据就可以了。
         而团长佣金结算时位于用 微服务中的，消费者监听到消息后进行消费。消费流程是这样的。首先远程调用商品微服务，将购买的商品skuld传过去，查一下商品SKU和佣金比例关系表（佣金流程瞎编的），看一下当初上架的时候，设置的佣金比例是多少。不同的商品，佣金比例是不一样的，这些佣金比例数据是统一计算进行下发的，当运营上架商品后，在审核流程中，上级领导会审核商品数据以及佣金比例的。如果说商品没有设置佣金命令，那么就走默认的分成比例。在团长表中有一个佣金比例字段，这个比例是当初运营经理和团长代理在签订合同的时候，谈的佣金比例，得到佣金比例后，再遍历购买的商品，如果有单独设置佣金比例，就按照单独设置的计算。如
     没有单独设置佣金比例，就按照默认的佣金比例计算。最终得出当前订单交易成功后，能分配给该团长的具体佣金，最后远程调用订单微服务，将佣金更新到订单表中就可Id。

  - 没讲分布式事务，中途异常如何回滚，整个流程中涉及到的修改有：  

    -   订单数据库：插入订单信息、插入订单项信息；
    -   商品数据库：锁定库存，就是对lockStock锁定库存字段进行修改Redis:删除购物车中购买的商品；
    -   订单数据库：使用MQ异步的方式，计算佣金，并修改到订单表的团长佣金字段中；
    -   理论上来讲，按照平常培训机构讲法和小白的认知，认为这几个步骤中，任何一个环节失败都意味着其他的步骤需要回滚，然后又把微服务分布式事务、SeataAT种东西安排上。

    正式回答：

    ​    我们整个流程涉及到的写操作有插入订单数据、插入订单项数据、锁定商品库存、删除Redis中的购买的商品、计算佣金几个步骤。
    ​    其中，删除Redis中购买的商品和计算佣金是异步的形式实现的，在业务上不是强一致性的。
    ​    而插入订单信息、商品数据、锁定库存这几个修改数据库的操作必须保持强一致性。
    ​    所以我设计的时候，我是这样设计的：
    ​       首先，这几个步骤都是发生在订单微服务中的service法中的，所以关于任何一个步骤出错，比如：远程调用商品微服务锁定库存、调用Redis或者发送消息到MQ任何一个步骤出问题，我直接抛出异常，这样就可以将订单微服务中新增的订单数据、订单项数据直接给回滚掉了。
    ​         如果订单业务service方法能够执行完毕，那么每一个步骤肯定是能够正确执行成功，没有问题的，所以订单数据和订单项数据持久化到数据库表中是非常安全的。
    ​       至于说有可能出现远程调用商品微服务，库存锁定了，但是后续的步骤出异常，而商品微服务的库存没法得到释放，这个没关系！因为一旦出异常，订单微服务一定会把最重要的订单数据给回滚掉。然后我们又有定时任务，每隔1分钟扫描一下订单表未支付的订单，统计计算一下每一个未支付的商品购买数量，再将未支付的商品数量更新到库存表的锁定库存字段中就可以了。当然您不用担心性能问题，因为我们这个项目就不是啥并发项目，而且商品数量也不多，这个定时务我特意压测过，以3000件商品+3W比未支付订单场景统计，统计后同步完毕，整个流程不超过2s。

    - 至于删掉Redis中购物车中的购买的商品数据，这个异步解耦，由购物车微服务中的监听器进行实现。这个队列消费者手动ack都不需要开启，因为这个处理比较快，而且几乎不可能出问题，就算出问题无非就是购物车中的数据本次没删掉而已，一点关系都没用。

    - 而异步结算团长佣金就不一样了，这个消费的时候必须手动ack。如果结算过程中出异常，我们默认会进行一次重试，如果重试仍然异常，则直接拒绝消息，丢进死信队列，由人工介入进行结算。人工结算的时候，会从消息中取出来所有的订单购买的商品信息，在后台管理页面中自动计算出来佣金，客服手动提交修改到订单表的佣金字段中就可以了。

       

####   19.订单支付：

   需求说明：
       订单生成后，前端向后端发起查询，查到等待支付的订单数据，展示支付页面。
      点击支付订单按钮,使用微信付款支付。

正式回答
    我们项目中使用的是微信支付-JSAPI，当用户提交订单，生成订单后，前端就会跳转到订单结算页面。用户点击【支付订单】就可以进行支付，支付实现方式是这样的：

##### 1、预付单生成接口流程：

首先请求到达我们后端的支付微服务的预付单生成接口，根据请求参数中携带的订单编号，远程调用订单微服务查一下订单状态是否正确，是否处于待支付状态，如果是的话，就将订单状态改为正在支付中。

并且封装一个订单支付信息对象，设置支付状态为未支付，保存到支付信息表当中然后根据微信支付的下单接口规范，拼接支付相关参数，例如：应用ID、商户号、商品描述、商户的订单号、交易时间、回调地址、用户的openiD等信息吧，向微信支付平台发起远程调用，生成预付单，返回一个prepayld的一个预付单编号，代表本次交易的唯一标识。
备注：微信下单API官方文档`https/pay.weixin.q.comwikidoc/api3/apis/chapier3_5_1.himl`

再然后就是根据预付单编号、appiD、微信支付返回的随机字符串、时间、签名类型等数据,调用微信支付的工具类生成一个支付签名。

最后将这些数据以及支付签名一起返回给前端小程序

前端微信小程序得到后端返回的支付信息后，小程序端本地调用支付微信提供的支付方法，发起微信支付：

1.  首先小程序端携带支付信息，向微信支付平台发起调用，验证支付授权权限，微信支付平台校验没问题，返回支付授权；
2.  然后小程序端就会弹出支付窗口，用户输入密码，并确认支付，再次提交授权到微信支付平台，微信支付平台验证用户的支付信息没有问题，就会进行扣款。
3.  ​    微信平台端对用户账户扣款的流程是异步的，就是说，他如果扣款成功，就会异步的通知到我们的后端接口，这个接口是当初生成订单时填写的回调地址。通知我们的后端支付结果，然后我们的后端会保存支付结果到本地数据库，并且返回响应，告诉微信支付平台我们成功接收处理了。
4.  然后微信支付平台还会返回支付结果给到微信小程序，并且以微信消息的形式提醒用户支付结果。

##### 2、 订单支付态查询：

   当然了，因为支付结果是异步的，有可能会因为客种原因，不管是网络延退，还是我们自己的服务问题，都有可能导致微信的第一次回调消息没有收到或者没有确认。所以微信支付也提供了查单接口，查询支付接口，我们可以自己主动调用微信支付平台，根据prepayID查询支付结果，所以我还单独写了一个查询订单支付状态的接口，实现流程也很简单：

- 封装AppiD、 商户ID、订单编号等参数;

- 向微信支付平台发起远程调用，得到返回结果；

- 从返回结果中就可以解析到支付状态，比如：支付成功、支付失败、支付中等状态，再返回给前端就可以了。

- 如果说订单状态为支付成功，那就更新一下订单表和支付信息表的状态以及真正扣减库存，当然这个状态可能已经被微信支付回调接口给更新过了，所以先判断一下支付状态:

   1. 如果支付状态为已支付，那么就不做任何操作。

   2. 如果支付状态为未支付，那么就更新一下支付信息表的状态为已支付。又因为当前服务是支付微服务，而那个订单修改位于订单微服务以及库存修改位于商品微服务，所以这块需要涉及到微服务调用，又因为这个业务流程并非强一致性的需求，所以我就将订单支付成功消息发送到RabbitMQ消息队列中，由订单微服务的消费者监听并修改订单状态，
      以及商品微服务的消费者监听并进行真正的库存扣减。

      

      

#####  3、微信支付平台回调接口：

​                另外就是微信支付完毕后，微信支付平台也会异步的形式调用我预先配置的回调接口，通知到后端服务当前的支付结果，并且我还要按照固定的格式进行应答SUCCESS成功 或者 FAIL失败。
​          微信支付成功，支付通知API官方手册：
​           https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_5.shtml



#### 20.退款流程有做过吗？

官方文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_9.shtm
   退款支付没教过，也不推荐说做个支付功能。

正式回答：
     退款流程大概业务需求是这样的，退款分为两种情况，一种是买家申请退款，退款可以分为仅退款或者退货退款，无论任何一种退款方式总之达到退货条件，就可以进行退款。不管任何退款方式， 都需要经过商户同意后才能执行退款流程
   另一种是我们区域运营经理主动给买家进行退款，出现这种情况的原因可能是

- 因为不可抗因素，导致买家下单的商品没货，或者一笔订单中买了多个商品，其中某一个商品因为某些特殊原因，导致没货了，所以需要区域运营经理亲自给买家打电话解释，并且在运营管理系统中直接给买家退款。

- 也可能是因为促销活动、买家直接电话投诉等各种原因，运营人员或者售后人员可以直接在运营平台给买家进行退款。
     但是话说回来，无论任何业务需求的退款，这个退款流程都是单独的，和业务本身是没有关系的。
   所以，我使用消息队列进行解耦，也就是说，不管啥原因退款，退款的业务只需要确认是否要退款，退多少钱，给谁退钱。
        比如投诉退款、售后退款还是活动退款，这些退款的原因和退款流程没有任何关系，所以我设计了一个退款消息队列，所有的要退款的场景中，统一将：

   - 微信支付订单号

   - 商户订单号       

   - 商户退款单号 

   - 退款原因

   - 退款结果回调URL

   - 退款资金来源

   - 金额信息

   - 退款商品详情


      这些数据进行封装，一方面是保存到退款记录表中，另一方面是远程调用微信支付平台，将这些参数进行封装，发送给微信平台，进行退款。
      当微信支付那边退款成功后，就会回调我参数中指定的URL，然后通知到我得支付微服务那么我就修改一下支付信息表的状态以及退款记录表的状态就可以了。
      另外还要发送一套消息到MQ中，由订单微服务的消费者监听，修改订单状态为退款成功或者
      订单关闭。
      至于说商品微服务的库存，我们退货是不会影响库存的，不会把库存重新添加回去，因为像我们这种销售的东西，基本上退回来的话，很难直接二次销售，所以需要售后人员重新处理，重新走入库流程，这就是我大概负责的退款业务
      当然了，为了防止运营或者售后客服因为各种原因导致退款流程处理不及时，或者售后仓库库管针对退货订单商品处理不及时，导致整个退货流程被延长，我们还编写了多个定时任务去定时扫描待处理的售后以及待入库的售后等任务进行兜底处理。

#### 21.前台会员领取优惠券，会遇到一些什么问题？

题外话：原版课程中是没有的，只是因为他在一开始的时候讲过优惠券管理，以及在后面结算的时候，查询过优惠券。

问题经典：

- 比如优惠券限时秒杀领取

- 优惠券防止超卖情况出现

- 优惠券定时上架管理

- 优惠券如何防止重复领取

- 优惠券如何防止小号批量刷走你的优惠券（打击黄牛/如何识别真实用户）

   ①要参加活动用户必须是下过订单的老/新用户

   ②要参加活动必须绑定手机号

   ③根据IP地址限制领取优惠卷

   ④根据地区限制领取优惠卷

正式回答：
   优惠券这块的话是我负责设计完成的。我们项目中的优惠券有全场通用、限定商品SKU专属的优惠券以及限定商品分类专属的优惠券这几个类型。
    然后优惠券领取的话，我们一般是在商品详情页、首页、活动促销页面，或者我们单独设计一个小程序页面，用来在微信朋友圈之间进行转发使用，可以直接在页面中点击领取优惠券等各种方式，也包括后台运营人员可以直接针对某些用户进行赠送优惠券。
    在后台管理系统中新增优惠券的时候，会限定优惠券的发行数量，如果为0的话，就代表不限制发行数量。但是，一定会限制优惠券领取的开始时间与结束时间，以及优惠券使用的开始时间、结束时间。
无论是通过哪种方式领取优惠券，总之在会员领取的优惠券时候，领取流程都是固定的，优惠券领取流程是在活动微服务中实现的，优惠券领取的流程步骤是这样的。

   - 首先判断优惠券状态是否可以领取，从前端请求中，获取到优惠券的ID，查询数据表，判断优惠券领取时间、优惠券状态是否正常。

   - 然后根据UserlD和优惠券ID，查询一下优惠券领用表，判断当前用户是否领取过优惠券，且领取的优惠券仍然在有效期内，如果是的话，就不能重复领取！

   - 然后校验用户是否具备领取优惠券的资格。我们设计优惠券的时候，设计了一个**优惠券的领取规则表**，这个规则表和优惠券主表是多对一的关系，通过外键关联优惠券的主键ID实现的。在后台管理系统中上架优惠券的时候可选的方式设计优惠券的规则，比如说可以设置

     1. 限定优惠券只能是新用户领取

     2. 限定优惠券只能是注册满指定天数的用户领取

     3. 限定优惠券必须是某些区域（校园）的用户进行领取

     4. 限定优惠券必须是绑定手机号以后才能领取
        并且这个优惠卷的规则可以动态的调整，新增或者减少、用户在领取优惠券的时候，有些优惠券活动力度比较大，并且限制发行的数量。所以为了防止有些非法的操作，例如有人恶意批量开小号刷优惠券接口，导致真实买家领不到优惠券，恶意账户各种羊毛的情况出现。所以，针对不同的优惠券在领取的过程中需要针对用户的资格进行校验。
             简单来说就是根据 优惠券ID 查询 优惠券规则表，取出来当前优惠券对应的规则，因为这个操作在优惠券秒杀的场景中，会涉及到并发，影响DB的服务器性能，并且优惠券规则属于读多写少的数据，于是我就使用Redis进行了缓存，优惠券ID作为Key，优惠券对应的领取规则作为值。
             如果当前领取的优惠券，没有设置任何规则，返回规则size为0，则直接默认为任何人都可以领取。
             遍历当前正在领取的优惠券规则，在每次循环中，判断当前用户是否满足某一条规则。如果满足，则直接返回true，代表可以领取。如果循环遍历完毕，没有任何一条规则符合当前用户，那就返回false，代表当前用户不可以领取，通知到前端“您不能领取该优惠券”。
             因为每一种优惠券领取规则的业务逻辑是不一样的，所以不能硬编码的方式写在代码中我是单独设计了一个规则校验接口，定义了规则校验方法。然后针对每一种校验规则，封装了一个子类，子类重写校验规则方法，根据当前子类的校验规则，例如：注册时间满多少天、是否是新用户等，编写不同子类的校验规则，进行调用。

         如果当前用户满足领取优惠券的资格，那么就进入到优惠券领取流程。
            然后判断优惠券是否有限制数量,如果没有限制发行的数量，并且库存充足的情况下，直接领取。

        ​    如果有限制发行的数量，且有库存数低于100的情况下，那就使用分布式锁进行控制领取优惠券的流程。 ==注意：分布式锁是强制排序，影响性能。==
        ​    我是使用Redisson进行加锁控制，优惠券id作为锁加锁以后，再查一下库存，如果优惠券的库存大于零，再写入couponuse优惠券领取记
        录表，以及修改优惠券表的剩余库存。
        ​    然后再释放锁。这就是大概获取优惠券领取流程。
        ​    另外就是还有一个优惠券定时上架与下架。这个是在后台录入优惠券信息的时候，填写的。然后我是通过定时任务，扫描优惠券表，条件就是根据优惠券发行时间字段以及优惠券的状态，判断一下时间到了，但是状态为等待发布状态的优惠券信息。然后将其状态修改为发布状态。同样道理，定时下架也一样，根据结束时间字段以及优惠券状态字段进行判断，如果到时间可以下线了，就将优惠券的状态字段改为已结束。

        

#### 如果面试官问高并发问题，万级QPS之类的问题。

回答的核心思想

1. 限流，应对突发并发流量，限流是一定的

2. 熔断，做好熔断，做好服务降级；

3. 解耦，非强一致性的步骤，比如：我只需要锁定库存，确定某一个用户抢到了，剩余的步都可以使用异步的方式进行解耦。
   又或者我使用redis的string类型声明一个库存量，每次秒杀过来，库存量decr递减1如果递减成功，证明用户抢到了，直接将剩余步骤丢到mg中异步解耦。

   ==像这种秒杀、高并发问题，没有固定答案。==
   只要能够解决问题，思路上没问题就行。
   如果实在不知道说，你就这样说
       我们这种项目根本就不可能有高并发，即便满世界的去无条件赠送优惠券，都不太可能吸引到高并发请求，所以QPS高峰期到1000都很难
       但是我自己也琢磨过一些思路，就是要做好限流、熔断、解耦等操作。






防止超领优惠卷问题：限流



加分布式锁，



## 大学课堂公众号：

### 1．请介绍一下你最近做的这个项目吧？

  大学课堂是一套面向大学生的团购优选平台。本项目主要在高校经营的快递驿站或合作的校园驿站、便利超市、水果等为基础，面向校园大学生群体精细化运营，打造垂直化的电商、社交平台。

技术架构：
   项目基于微服务技术架构，主要以Alibaba 系列微服务组件进行构建，围绕业务拆分需求，每一块业务对应一个微服务，例如：会员服务、系统服务、商品服务、营销服务、搜索服务、购物车服务、订单服务、支付服务、认证服务、物流服务。
   项目中用到的其他技术栈也挺多的，比如：SpringBoot、MybatisPlus、Redis、 RabbitMQ、Elasticsearch、OSS、MySQL、Nginx等等。

岗位职责：
   我在这个主要承担Java后端开发，算是一个核心人员吧，因为我刚入职的时候，这个项目才刚开始，所以我也算老员工了。有的时候也会帮助新同事快速适应这个项目的技术栈。到项目后期，我也会指导一下实习生，帮忙写一写接口文档和使用手册。
    这个项目怎么说呢，我们对于工作划分没有那么细致，每一个业务模块我都有所参与。我比较熟悉的模块比如：权限管理模块、商品模块、订单模块、购物车模块、搜索模块是我主要负责完成的。



![img](D:/StudyViden/Java/%25E9%25A1%25B9%25E7%259B%25AE/%25E7%25A1%2585%25E8%25B0%25B7%25E8%25AF%25BE%25E5%25A0%2582/%25E7%25AC%2594%25E8%25AE%25B0/images/%25E5%258A%259F%25E8%2583%25BD%25E6%259E%25B6%25E6%259E%2584%25E5%259B%25BE.png)

1.  
2.  项目中使用了很多Api接口，像微信公众号导航栏啊、微信登录、微信支付、欢拓云直播接口，学习到了怎么对接



微信，首次使用微信公众会判断是否是新人，





## 权限盒子项目：

1、每个系统权限管理，他们的核心流程都是差不多的，如果每个后台单独开发一套权限管理系统，不仅很浪费时间和人力，所以权限盒子就是为了解决这个客户问题的，为他们提供了一套通用的权限解决方案。

​      大学的时候写了几个项目，发送每个项目都有权限管理模块，为了解决。

路径：http://139.198.152.148:8810/

   AOP是**在不惊动(改动)原有设计(代码)**的前提下对其功能进行增强。

1. 用户管理
2. 角色管理
3. 菜单管理
4. 权限管理
5. 岗位管理
6. 日志管理   ①操作日志  ②登录日志